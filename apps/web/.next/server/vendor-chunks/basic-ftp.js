"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/basic-ftp";
exports.ids = ["vendor-chunks/basic-ftp"];
exports.modules = {

/***/ "(rsc)/../../node_modules/basic-ftp/dist/Client.js":
/*!***************************************************!*\
  !*** ../../node_modules/basic-ftp/dist/Client.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Client = void 0;\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst FtpContext_1 = __webpack_require__(/*! ./FtpContext */ \"(rsc)/../../node_modules/basic-ftp/dist/FtpContext.js\");\nconst parseList_1 = __webpack_require__(/*! ./parseList */ \"(rsc)/../../node_modules/basic-ftp/dist/parseList.js\");\nconst ProgressTracker_1 = __webpack_require__(/*! ./ProgressTracker */ \"(rsc)/../../node_modules/basic-ftp/dist/ProgressTracker.js\");\nconst StringWriter_1 = __webpack_require__(/*! ./StringWriter */ \"(rsc)/../../node_modules/basic-ftp/dist/StringWriter.js\");\nconst parseListMLSD_1 = __webpack_require__(/*! ./parseListMLSD */ \"(rsc)/../../node_modules/basic-ftp/dist/parseListMLSD.js\");\nconst netUtils_1 = __webpack_require__(/*! ./netUtils */ \"(rsc)/../../node_modules/basic-ftp/dist/netUtils.js\");\nconst transfer_1 = __webpack_require__(/*! ./transfer */ \"(rsc)/../../node_modules/basic-ftp/dist/transfer.js\");\nconst parseControlResponse_1 = __webpack_require__(/*! ./parseControlResponse */ \"(rsc)/../../node_modules/basic-ftp/dist/parseControlResponse.js\");\n// Use promisify to keep the library compatible with Node 8.\nconst fsReadDir = (0, util_1.promisify)(fs_1.readdir);\nconst fsMkDir = (0, util_1.promisify)(fs_1.mkdir);\nconst fsStat = (0, util_1.promisify)(fs_1.stat);\nconst fsOpen = (0, util_1.promisify)(fs_1.open);\nconst fsClose = (0, util_1.promisify)(fs_1.close);\nconst fsUnlink = (0, util_1.promisify)(fs_1.unlink);\nconst defaultClientOptions = {\n    allowSeparateTransferHost: true\n};\nconst LIST_COMMANDS_DEFAULT = ()=>[\n        \"LIST -a\",\n        \"LIST\"\n    ];\nconst LIST_COMMANDS_MLSD = ()=>[\n        \"MLSD\",\n        \"LIST -a\",\n        \"LIST\"\n    ];\n/**\n * High-level API to interact with an FTP server.\n */ class Client {\n    /**\n     * Instantiate an FTP client.\n     *\n     * @param timeout  Timeout in milliseconds, use 0 for no timeout. Optional, default is 30 seconds.\n     */ constructor(timeout = 30000, options = defaultClientOptions){\n        this.availableListCommands = LIST_COMMANDS_DEFAULT();\n        this.ftp = new FtpContext_1.FTPContext(timeout);\n        this.prepareTransfer = this._enterFirstCompatibleMode([\n            transfer_1.enterPassiveModeIPv6,\n            options.allowSeparateTransferHost ? transfer_1.enterPassiveModeIPv4 : transfer_1.enterPassiveModeIPv4_forceControlHostIP\n        ]);\n        this.parseList = parseList_1.parseList;\n        this._progressTracker = new ProgressTracker_1.ProgressTracker();\n    }\n    /**\n     * Close the client and all open socket connections.\n     *\n     * Close the client and all open socket connections. The client canâ€™t be used anymore after calling this method,\n     * you have to either reconnect with `access` or `connect` or instantiate a new instance to continue any work.\n     * A client is also closed automatically if any timeout or connection error occurs.\n     */ close() {\n        this.ftp.close();\n        this._progressTracker.stop();\n    }\n    /**\n     * Returns true if the client is closed and can't be used anymore.\n     */ get closed() {\n        return this.ftp.closed;\n    }\n    /**\n     * Connect (or reconnect) to an FTP server.\n     *\n     * This is an instance method and thus can be called multiple times during the lifecycle of a `Client`\n     * instance. Whenever you do, the client is reset with a new control connection. This also implies that\n     * you can reopen a `Client` instance that has been closed due to an error when reconnecting with this\n     * method. In fact, reconnecting is the only way to continue using a closed `Client`.\n     *\n     * @param host  Host the client should connect to. Optional, default is \"localhost\".\n     * @param port  Port the client should connect to. Optional, default is 21.\n     */ connect(host = \"localhost\", port = 21) {\n        this.ftp.reset();\n        this.ftp.socket.connect({\n            host,\n            port,\n            family: this.ftp.ipFamily\n        }, ()=>this.ftp.log(`Connected to ${(0, netUtils_1.describeAddress)(this.ftp.socket)} (${(0, netUtils_1.describeTLS)(this.ftp.socket)})`));\n        return this._handleConnectResponse();\n    }\n    /**\n     * As `connect` but using implicit TLS. Implicit TLS is not an FTP standard and has been replaced by\n     * explicit TLS. There are still FTP servers that support only implicit TLS, though.\n     */ connectImplicitTLS(host = \"localhost\", port = 21, tlsOptions = {}) {\n        this.ftp.reset();\n        this.ftp.socket = (0, tls_1.connect)(port, host, tlsOptions, ()=>this.ftp.log(`Connected to ${(0, netUtils_1.describeAddress)(this.ftp.socket)} (${(0, netUtils_1.describeTLS)(this.ftp.socket)})`));\n        this.ftp.tlsOptions = tlsOptions;\n        return this._handleConnectResponse();\n    }\n    /**\n     * Handles the first reponse by an FTP server after the socket connection has been established.\n     */ _handleConnectResponse() {\n        return this.ftp.handle(undefined, (res, task)=>{\n            if (res instanceof Error) {\n                // The connection has been destroyed by the FTPContext at this point.\n                task.reject(res);\n            } else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {\n                task.resolve(res);\n            } else {\n                // Don't stay connected but don't replace the socket yet by using reset()\n                // so the user can inspect properties of this instance.\n                task.reject(new FtpContext_1.FTPError(res));\n            }\n        });\n    }\n    /**\n     * Send an FTP command and handle the first response.\n     */ send(command, ignoreErrorCodesDEPRECATED = false) {\n        if (ignoreErrorCodesDEPRECATED) {\n            this.ftp.log(\"Deprecated call using send(command, flag) with boolean flag to ignore errors. Use sendIgnoringError(command).\");\n            return this.sendIgnoringError(command);\n        }\n        return this.ftp.request(command);\n    }\n    /**\n     * Send an FTP command and ignore an FTP error response. Any other kind of error or timeout will still reject the Promise.\n     *\n     * @param command\n     */ sendIgnoringError(command) {\n        return this.ftp.handle(command, (res, task)=>{\n            if (res instanceof FtpContext_1.FTPError) {\n                task.resolve({\n                    code: res.code,\n                    message: res.message\n                });\n            } else if (res instanceof Error) {\n                task.reject(res);\n            } else {\n                task.resolve(res);\n            }\n        });\n    }\n    /**\n     * Upgrade the current socket connection to TLS.\n     *\n     * @param options  TLS options as in `tls.connect(options)`, optional.\n     * @param command  Set the authentication command. Optional, default is \"AUTH TLS\".\n     */ async useTLS(options = {}, command = \"AUTH TLS\") {\n        const ret = await this.send(command);\n        this.ftp.socket = await (0, netUtils_1.upgradeSocket)(this.ftp.socket, options);\n        this.ftp.tlsOptions = options; // Keep the TLS options for later data connections that should use the same options.\n        this.ftp.log(`Control socket is using: ${(0, netUtils_1.describeTLS)(this.ftp.socket)}`);\n        return ret;\n    }\n    /**\n     * Login a user with a password.\n     *\n     * @param user  Username to use for login. Optional, default is \"anonymous\".\n     * @param password  Password to use for login. Optional, default is \"guest\".\n     */ login(user = \"anonymous\", password = \"guest\") {\n        this.ftp.log(`Login security: ${(0, netUtils_1.describeTLS)(this.ftp.socket)}`);\n        return this.ftp.handle(\"USER \" + user, (res, task)=>{\n            if (res instanceof Error) {\n                task.reject(res);\n            } else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {\n                task.resolve(res);\n            } else if (res.code === 331) {\n                this.ftp.send(\"PASS \" + password);\n            } else {\n                task.reject(new FtpContext_1.FTPError(res));\n            }\n        });\n    }\n    /**\n     * Set the usual default settings.\n     *\n     * Settings used:\n     * * Binary mode (TYPE I)\n     * * File structure (STRU F)\n     * * Additional settings for FTPS (PBSZ 0, PROT P)\n     */ async useDefaultSettings() {\n        const features = await this.features();\n        // Use MLSD directory listing if possible. See https://tools.ietf.org/html/rfc3659#section-7.8:\n        // \"The presence of the MLST feature indicates that both MLST and MLSD are supported.\"\n        const supportsMLSD = features.has(\"MLST\");\n        this.availableListCommands = supportsMLSD ? LIST_COMMANDS_MLSD() : LIST_COMMANDS_DEFAULT();\n        await this.send(\"TYPE I\"); // Binary mode\n        await this.sendIgnoringError(\"STRU F\"); // Use file structure\n        await this.sendIgnoringError(\"OPTS UTF8 ON\"); // Some servers expect UTF-8 to be enabled explicitly and setting before login might not have worked.\n        if (supportsMLSD) {\n            await this.sendIgnoringError(\"OPTS MLST type;size;modify;unique;unix.mode;unix.owner;unix.group;unix.ownername;unix.groupname;\"); // Make sure MLSD listings include all we can parse\n        }\n        if (this.ftp.hasTLS) {\n            await this.sendIgnoringError(\"PBSZ 0\"); // Set to 0 for TLS\n            await this.sendIgnoringError(\"PROT P\"); // Protect channel (also for data connections)\n        }\n    }\n    /**\n     * Convenience method that calls `connect`, `useTLS`, `login` and `useDefaultSettings`.\n     *\n     * This is an instance method and thus can be called multiple times during the lifecycle of a `Client`\n     * instance. Whenever you do, the client is reset with a new control connection. This also implies that\n     * you can reopen a `Client` instance that has been closed due to an error when reconnecting with this\n     * method. In fact, reconnecting is the only way to continue using a closed `Client`.\n     */ async access(options = {}) {\n        var _a, _b;\n        const useExplicitTLS = options.secure === true;\n        const useImplicitTLS = options.secure === \"implicit\";\n        let welcome;\n        if (useImplicitTLS) {\n            welcome = await this.connectImplicitTLS(options.host, options.port, options.secureOptions);\n        } else {\n            welcome = await this.connect(options.host, options.port);\n        }\n        if (useExplicitTLS) {\n            // Fixes https://github.com/patrickjuchli/basic-ftp/issues/166 by making sure\n            // host is set for any future data connection as well.\n            const secureOptions = (_a = options.secureOptions) !== null && _a !== void 0 ? _a : {};\n            secureOptions.host = (_b = secureOptions.host) !== null && _b !== void 0 ? _b : options.host;\n            await this.useTLS(secureOptions);\n        }\n        // Set UTF-8 on before login in case there are non-ascii characters in user or password.\n        // Note that this might not work before login depending on server.\n        await this.sendIgnoringError(\"OPTS UTF8 ON\");\n        await this.login(options.user, options.password);\n        await this.useDefaultSettings();\n        return welcome;\n    }\n    /**\n     * Get the current working directory.\n     */ async pwd() {\n        const res = await this.send(\"PWD\");\n        // The directory is part of the return message, for example:\n        // 257 \"/this/that\" is current directory.\n        const parsed = res.message.match(/\"(.+)\"/);\n        if (parsed === null || parsed[1] === undefined) {\n            throw new Error(`Can't parse response to command 'PWD': ${res.message}`);\n        }\n        return parsed[1];\n    }\n    /**\n     * Get a description of supported features.\n     *\n     * This sends the FEAT command and parses the result into a Map where keys correspond to available commands\n     * and values hold further information. Be aware that your FTP servers might not support this\n     * command in which case this method will not throw an exception but just return an empty Map.\n     */ async features() {\n        const res = await this.sendIgnoringError(\"FEAT\");\n        const features = new Map();\n        // Not supporting any special features will be reported with a single line.\n        if (res.code < 400 && (0, parseControlResponse_1.isMultiline)(res.message)) {\n            // The first and last line wrap the multiline response, ignore them.\n            res.message.split(\"\\n\").slice(1, -1).forEach((line)=>{\n                // A typical lines looks like: \" REST STREAM\" or \" MDTM\".\n                // Servers might not use an indentation though.\n                const entry = line.trim().split(\" \");\n                features.set(entry[0], entry[1] || \"\");\n            });\n        }\n        return features;\n    }\n    /**\n     * Set the working directory.\n     */ async cd(path) {\n        const validPath = await this.protectWhitespace(path);\n        return this.send(\"CWD \" + validPath);\n    }\n    /**\n     * Switch to the parent directory of the working directory.\n     */ async cdup() {\n        return this.send(\"CDUP\");\n    }\n    /**\n     * Get the last modified time of a file. This is not supported by every FTP server, in which case\n     * calling this method will throw an exception.\n     */ async lastMod(path) {\n        const validPath = await this.protectWhitespace(path);\n        const res = await this.send(`MDTM ${validPath}`);\n        const date = res.message.slice(4);\n        return (0, parseListMLSD_1.parseMLSxDate)(date);\n    }\n    /**\n     * Get the size of a file.\n     */ async size(path) {\n        const validPath = await this.protectWhitespace(path);\n        const command = `SIZE ${validPath}`;\n        const res = await this.send(command);\n        // The size is part of the response message, for example: \"213 555555\". It's\n        // possible that there is a commmentary appended like \"213 5555, some commentary\".\n        const size = parseInt(res.message.slice(4), 10);\n        if (Number.isNaN(size)) {\n            throw new Error(`Can't parse response to command '${command}' as a numerical value: ${res.message}`);\n        }\n        return size;\n    }\n    /**\n     * Rename a file.\n     *\n     * Depending on the FTP server this might also be used to move a file from one\n     * directory to another by providing full paths.\n     */ async rename(srcPath, destPath) {\n        const validSrc = await this.protectWhitespace(srcPath);\n        const validDest = await this.protectWhitespace(destPath);\n        await this.send(\"RNFR \" + validSrc);\n        return this.send(\"RNTO \" + validDest);\n    }\n    /**\n     * Remove a file from the current working directory.\n     *\n     * You can ignore FTP error return codes which won't throw an exception if e.g.\n     * the file doesn't exist.\n     */ async remove(path, ignoreErrorCodes = false) {\n        const validPath = await this.protectWhitespace(path);\n        if (ignoreErrorCodes) {\n            return this.sendIgnoringError(`DELE ${validPath}`);\n        }\n        return this.send(`DELE ${validPath}`);\n    }\n    /**\n     * Report transfer progress for any upload or download to a given handler.\n     *\n     * This will also reset the overall transfer counter that can be used for multiple transfers. You can\n     * also call the function without a handler to stop reporting to an earlier one.\n     *\n     * @param handler  Handler function to call on transfer progress.\n     */ trackProgress(handler) {\n        this._progressTracker.bytesOverall = 0;\n        this._progressTracker.reportTo(handler);\n    }\n    /**\n     * Upload data from a readable stream or a local file to a remote file.\n     *\n     * @param source  Readable stream or path to a local file.\n     * @param toRemotePath  Path to a remote file to write to.\n     */ async uploadFrom(source, toRemotePath, options = {}) {\n        return this._uploadWithCommand(source, toRemotePath, \"STOR\", options);\n    }\n    /**\n     * Upload data from a readable stream or a local file by appending it to an existing file. If the file doesn't\n     * exist the FTP server should create it.\n     *\n     * @param source  Readable stream or path to a local file.\n     * @param toRemotePath  Path to a remote file to write to.\n     */ async appendFrom(source, toRemotePath, options = {}) {\n        return this._uploadWithCommand(source, toRemotePath, \"APPE\", options);\n    }\n    /**\n     * @protected\n     */ async _uploadWithCommand(source, remotePath, command, options) {\n        if (typeof source === \"string\") {\n            return this._uploadLocalFile(source, remotePath, command, options);\n        }\n        return this._uploadFromStream(source, remotePath, command);\n    }\n    /**\n     * @protected\n     */ async _uploadLocalFile(localPath, remotePath, command, options) {\n        const fd = await fsOpen(localPath, \"r\");\n        const source = (0, fs_1.createReadStream)(\"\", {\n            fd,\n            start: options.localStart,\n            end: options.localEndInclusive,\n            autoClose: false\n        });\n        try {\n            return await this._uploadFromStream(source, remotePath, command);\n        } finally{\n            await ignoreError(()=>fsClose(fd));\n        }\n    }\n    /**\n     * @protected\n     */ async _uploadFromStream(source, remotePath, command) {\n        const onError = (err)=>this.ftp.closeWithError(err);\n        source.once(\"error\", onError);\n        try {\n            const validPath = await this.protectWhitespace(remotePath);\n            await this.prepareTransfer(this.ftp);\n            // Keep the keyword `await` or the `finally` clause below runs too early\n            // and removes the event listener for the source stream too early.\n            return await (0, transfer_1.uploadFrom)(source, {\n                ftp: this.ftp,\n                tracker: this._progressTracker,\n                command,\n                remotePath: validPath,\n                type: \"upload\"\n            });\n        } finally{\n            source.removeListener(\"error\", onError);\n        }\n    }\n    /**\n     * Download a remote file and pipe its data to a writable stream or to a local file.\n     *\n     * You can optionally define at which position of the remote file you'd like to start\n     * downloading. If the destination you provide is a file, the offset will be applied\n     * to it as well. For example: To resume a failed download, you'd request the size of\n     * the local, partially downloaded file and use that as the offset. Assuming the size\n     * is 23, you'd download the rest using `downloadTo(\"local.txt\", \"remote.txt\", 23)`.\n     *\n     * @param destination  Stream or path for a local file to write to.\n     * @param fromRemotePath  Path of the remote file to read from.\n     * @param startAt  Position within the remote file to start downloading at. If the destination is a file, this offset is also applied to it.\n     */ async downloadTo(destination, fromRemotePath, startAt = 0) {\n        if (typeof destination === \"string\") {\n            return this._downloadToFile(destination, fromRemotePath, startAt);\n        }\n        return this._downloadToStream(destination, fromRemotePath, startAt);\n    }\n    /**\n     * @protected\n     */ async _downloadToFile(localPath, remotePath, startAt) {\n        const appendingToLocalFile = startAt > 0;\n        const fileSystemFlags = appendingToLocalFile ? \"r+\" : \"w\";\n        const fd = await fsOpen(localPath, fileSystemFlags);\n        const destination = (0, fs_1.createWriteStream)(\"\", {\n            fd,\n            start: startAt,\n            autoClose: false\n        });\n        try {\n            return await this._downloadToStream(destination, remotePath, startAt);\n        } catch (err) {\n            const localFileStats = await ignoreError(()=>fsStat(localPath));\n            const hasDownloadedData = localFileStats && localFileStats.size > 0;\n            const shouldRemoveLocalFile = !appendingToLocalFile && !hasDownloadedData;\n            if (shouldRemoveLocalFile) {\n                await ignoreError(()=>fsUnlink(localPath));\n            }\n            throw err;\n        } finally{\n            await ignoreError(()=>fsClose(fd));\n        }\n    }\n    /**\n     * @protected\n     */ async _downloadToStream(destination, remotePath, startAt) {\n        const onError = (err)=>this.ftp.closeWithError(err);\n        destination.once(\"error\", onError);\n        try {\n            const validPath = await this.protectWhitespace(remotePath);\n            await this.prepareTransfer(this.ftp);\n            // Keep the keyword `await` or the `finally` clause below runs too early\n            // and removes the event listener for the source stream too early.\n            return await (0, transfer_1.downloadTo)(destination, {\n                ftp: this.ftp,\n                tracker: this._progressTracker,\n                command: startAt > 0 ? `REST ${startAt}` : `RETR ${validPath}`,\n                remotePath: validPath,\n                type: \"download\"\n            });\n        } finally{\n            destination.removeListener(\"error\", onError);\n            destination.end();\n        }\n    }\n    /**\n     * List files and directories in the current working directory, or from `path` if specified.\n     *\n     * @param [path]  Path to remote file or directory.\n     */ async list(path = \"\") {\n        const validPath = await this.protectWhitespace(path);\n        let lastError;\n        for (const candidate of this.availableListCommands){\n            const command = validPath === \"\" ? candidate : `${candidate} ${validPath}`;\n            await this.prepareTransfer(this.ftp);\n            try {\n                const parsedList = await this._requestListWithCommand(command);\n                // Use successful candidate for all subsequent requests.\n                this.availableListCommands = [\n                    candidate\n                ];\n                return parsedList;\n            } catch (err) {\n                const shouldTryNext = err instanceof FtpContext_1.FTPError;\n                if (!shouldTryNext) {\n                    throw err;\n                }\n                lastError = err;\n            }\n        }\n        throw lastError;\n    }\n    /**\n     * @protected\n     */ async _requestListWithCommand(command) {\n        const buffer = new StringWriter_1.StringWriter();\n        await (0, transfer_1.downloadTo)(buffer, {\n            ftp: this.ftp,\n            tracker: this._progressTracker,\n            command,\n            remotePath: \"\",\n            type: \"list\"\n        });\n        const text = buffer.getText(this.ftp.encoding);\n        this.ftp.log(text);\n        return this.parseList(text);\n    }\n    /**\n     * Remove a directory and all of its content.\n     *\n     * @param remoteDirPath  The path of the remote directory to delete.\n     * @example client.removeDir(\"foo\") // Remove directory 'foo' using a relative path.\n     * @example client.removeDir(\"foo/bar\") // Remove directory 'bar' using a relative path.\n     * @example client.removeDir(\"/foo/bar\") // Remove directory 'bar' using an absolute path.\n     * @example client.removeDir(\"/\") // Remove everything.\n     */ async removeDir(remoteDirPath) {\n        return this._exitAtCurrentDirectory(async ()=>{\n            await this.cd(remoteDirPath);\n            // Get the absolute path of the target because remoteDirPath might be a relative path, even `../` is possible.\n            const absoluteDirPath = await this.pwd();\n            await this.clearWorkingDir();\n            const dirIsRoot = absoluteDirPath === \"/\";\n            if (!dirIsRoot) {\n                await this.cdup();\n                await this.removeEmptyDir(absoluteDirPath);\n            }\n        });\n    }\n    /**\n     * Remove all files and directories in the working directory without removing\n     * the working directory itself.\n     */ async clearWorkingDir() {\n        for (const file of (await this.list())){\n            if (file.isDirectory) {\n                await this.cd(file.name);\n                await this.clearWorkingDir();\n                await this.cdup();\n                await this.removeEmptyDir(file.name);\n            } else {\n                await this.remove(file.name);\n            }\n        }\n    }\n    /**\n     * Upload the contents of a local directory to the remote working directory.\n     *\n     * This will overwrite existing files with the same names and reuse existing directories.\n     * Unrelated files and directories will remain untouched. You can optionally provide a `remoteDirPath`\n     * to put the contents inside a directory which will be created if necessary including all\n     * intermediate directories. If you did provide a remoteDirPath the working directory will stay\n     * the same as before calling this method.\n     *\n     * @param localDirPath  Local path, e.g. \"foo/bar\" or \"../test\"\n     * @param [remoteDirPath]  Remote path of a directory to upload to. Working directory if undefined.\n     */ async uploadFromDir(localDirPath, remoteDirPath) {\n        return this._exitAtCurrentDirectory(async ()=>{\n            if (remoteDirPath) {\n                await this.ensureDir(remoteDirPath);\n            }\n            return await this._uploadToWorkingDir(localDirPath);\n        });\n    }\n    /**\n     * @protected\n     */ async _uploadToWorkingDir(localDirPath) {\n        const files = await fsReadDir(localDirPath);\n        for (const file of files){\n            const fullPath = (0, path_1.join)(localDirPath, file);\n            const stats = await fsStat(fullPath);\n            if (stats.isFile()) {\n                await this.uploadFrom(fullPath, file);\n            } else if (stats.isDirectory()) {\n                await this._openDir(file);\n                await this._uploadToWorkingDir(fullPath);\n                await this.cdup();\n            }\n        }\n    }\n    /**\n     * Download all files and directories of the working directory to a local directory.\n     *\n     * @param localDirPath  The local directory to download to.\n     * @param remoteDirPath  Remote directory to download. Current working directory if not specified.\n     */ async downloadToDir(localDirPath, remoteDirPath) {\n        return this._exitAtCurrentDirectory(async ()=>{\n            if (remoteDirPath) {\n                await this.cd(remoteDirPath);\n            }\n            return await this._downloadFromWorkingDir(localDirPath);\n        });\n    }\n    /**\n     * @protected\n     */ async _downloadFromWorkingDir(localDirPath) {\n        await ensureLocalDirectory(localDirPath);\n        for (const file of (await this.list())){\n            const localPath = (0, path_1.join)(localDirPath, file.name);\n            if (file.isDirectory) {\n                await this.cd(file.name);\n                await this._downloadFromWorkingDir(localPath);\n                await this.cdup();\n            } else if (file.isFile) {\n                await this.downloadTo(localPath, file.name);\n            }\n        }\n    }\n    /**\n     * Make sure a given remote path exists, creating all directories as necessary.\n     * This function also changes the current working directory to the given path.\n     */ async ensureDir(remoteDirPath) {\n        // If the remoteDirPath was absolute go to root directory.\n        if (remoteDirPath.startsWith(\"/\")) {\n            await this.cd(\"/\");\n        }\n        const names = remoteDirPath.split(\"/\").filter((name)=>name !== \"\");\n        for (const name of names){\n            await this._openDir(name);\n        }\n    }\n    /**\n     * Try to create a directory and enter it. This will not raise an exception if the directory\n     * couldn't be created if for example it already exists.\n     * @protected\n     */ async _openDir(dirName) {\n        await this.sendIgnoringError(\"MKD \" + dirName);\n        await this.cd(dirName);\n    }\n    /**\n     * Remove an empty directory, will fail if not empty.\n     */ async removeEmptyDir(path) {\n        const validPath = await this.protectWhitespace(path);\n        return this.send(`RMD ${validPath}`);\n    }\n    /**\n     * FTP servers can't handle filenames that have leading whitespace. This method transforms\n     * a given path to fix that issue for most cases.\n     */ async protectWhitespace(path) {\n        if (!path.startsWith(\" \")) {\n            return path;\n        }\n        // Handle leading whitespace by prepending the absolute path:\n        // \" test.txt\" while being in the root directory becomes \"/ test.txt\".\n        const pwd = await this.pwd();\n        const absolutePathPrefix = pwd.endsWith(\"/\") ? pwd : pwd + \"/\";\n        return absolutePathPrefix + path;\n    }\n    async _exitAtCurrentDirectory(func) {\n        const userDir = await this.pwd();\n        try {\n            return await func();\n        } finally{\n            if (!this.closed) {\n                await ignoreError(()=>this.cd(userDir));\n            }\n        }\n    }\n    /**\n     * Try all available transfer strategies and pick the first one that works. Update `client` to\n     * use the working strategy for all successive transfer requests.\n     *\n     * @returns a function that will try the provided strategies.\n     */ _enterFirstCompatibleMode(strategies) {\n        return async (ftp)=>{\n            ftp.log(\"Trying to find optimal transfer strategy...\");\n            let lastError = undefined;\n            for (const strategy of strategies){\n                try {\n                    const res = await strategy(ftp);\n                    ftp.log(\"Optimal transfer strategy found.\");\n                    this.prepareTransfer = strategy;\n                    return res;\n                } catch (err) {\n                    // Try the next candidate no matter the exact error. It's possible that a server\n                    // answered incorrectly to a strategy, for example a PASV answer to an EPSV.\n                    lastError = err;\n                }\n            }\n            throw new Error(`None of the available transfer strategies work. Last error response was '${lastError}'.`);\n        };\n    }\n    /**\n     * DEPRECATED, use `uploadFrom`.\n     * @deprecated\n     */ async upload(source, toRemotePath, options = {}) {\n        this.ftp.log(\"Warning: upload() has been deprecated, use uploadFrom().\");\n        return this.uploadFrom(source, toRemotePath, options);\n    }\n    /**\n     * DEPRECATED, use `appendFrom`.\n     * @deprecated\n     */ async append(source, toRemotePath, options = {}) {\n        this.ftp.log(\"Warning: append() has been deprecated, use appendFrom().\");\n        return this.appendFrom(source, toRemotePath, options);\n    }\n    /**\n     * DEPRECATED, use `downloadTo`.\n     * @deprecated\n     */ async download(destination, fromRemotePath, startAt = 0) {\n        this.ftp.log(\"Warning: download() has been deprecated, use downloadTo().\");\n        return this.downloadTo(destination, fromRemotePath, startAt);\n    }\n    /**\n     * DEPRECATED, use `uploadFromDir`.\n     * @deprecated\n     */ async uploadDir(localDirPath, remoteDirPath) {\n        this.ftp.log(\"Warning: uploadDir() has been deprecated, use uploadFromDir().\");\n        return this.uploadFromDir(localDirPath, remoteDirPath);\n    }\n    /**\n     * DEPRECATED, use `downloadToDir`.\n     * @deprecated\n     */ async downloadDir(localDirPath) {\n        this.ftp.log(\"Warning: downloadDir() has been deprecated, use downloadToDir().\");\n        return this.downloadToDir(localDirPath);\n    }\n}\nexports.Client = Client;\nasync function ensureLocalDirectory(path) {\n    try {\n        await fsStat(path);\n    } catch (_a) {\n        await fsMkDir(path, {\n            recursive: true\n        });\n    }\n}\nasync function ignoreError(func) {\n    try {\n        return await func();\n    } catch (_a) {\n        // Ignore\n        return undefined;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2ljLWZ0cC9kaXN0L0NsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsTUFBTUcsT0FBT0MsbUJBQU9BLENBQUMsY0FBSTtBQUN6QixNQUFNQyxTQUFTRCxtQkFBT0EsQ0FBQyxrQkFBTTtBQUM3QixNQUFNRSxRQUFRRixtQkFBT0EsQ0FBQyxnQkFBSztBQUMzQixNQUFNRyxTQUFTSCxtQkFBT0EsQ0FBQyxrQkFBTTtBQUM3QixNQUFNSSxlQUFlSixtQkFBT0EsQ0FBQywyRUFBYztBQUMzQyxNQUFNSyxjQUFjTCxtQkFBT0EsQ0FBQyx5RUFBYTtBQUN6QyxNQUFNTSxvQkFBb0JOLG1CQUFPQSxDQUFDLHFGQUFtQjtBQUNyRCxNQUFNTyxpQkFBaUJQLG1CQUFPQSxDQUFDLCtFQUFnQjtBQUMvQyxNQUFNUSxrQkFBa0JSLG1CQUFPQSxDQUFDLGlGQUFpQjtBQUNqRCxNQUFNUyxhQUFhVCxtQkFBT0EsQ0FBQyx1RUFBWTtBQUN2QyxNQUFNVSxhQUFhVixtQkFBT0EsQ0FBQyx1RUFBWTtBQUN2QyxNQUFNVyx5QkFBeUJYLG1CQUFPQSxDQUFDLCtGQUF3QjtBQUMvRCw0REFBNEQ7QUFDNUQsTUFBTVksWUFBWSxDQUFDLEdBQUdULE9BQU9VLFNBQVMsRUFBRWQsS0FBS2UsT0FBTztBQUNwRCxNQUFNQyxVQUFVLENBQUMsR0FBR1osT0FBT1UsU0FBUyxFQUFFZCxLQUFLaUIsS0FBSztBQUNoRCxNQUFNQyxTQUFTLENBQUMsR0FBR2QsT0FBT1UsU0FBUyxFQUFFZCxLQUFLbUIsSUFBSTtBQUM5QyxNQUFNQyxTQUFTLENBQUMsR0FBR2hCLE9BQU9VLFNBQVMsRUFBRWQsS0FBS3FCLElBQUk7QUFDOUMsTUFBTUMsVUFBVSxDQUFDLEdBQUdsQixPQUFPVSxTQUFTLEVBQUVkLEtBQUt1QixLQUFLO0FBQ2hELE1B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b0csVUFBVSxDQUFDQyxhQUFhQyxnQkFBZ0JDO0lBQ3hEO0lBQ0E7OztLQUdDLEdBQ0QsTUFBTXdELFVBQVV6QixZQUFZLEVBQUVWLGFBQWEsRUFBRTtRQUN6QyxJQUFJLENBQUMvSSxHQUFHLENBQUNtQixHQUFHLENBQUM7UUFDYixPQUFPLElBQUksQ0FBQ3FJLGFBQWEsQ0FBQ0MsY0FBY1Y7SUFDNUM7SUFDQTs7O0tBR0MsR0FDRCxNQUFNb0MsWUFBWTFCLFlBQVksRUFBRTtRQUM1QixJQUFJLENBQUN6SixHQUFHLENBQUNtQixHQUFHLENBQUM7UUFDYixPQUFPLElBQUksQ0FBQytJLGFBQWEsQ0FBQ1Q7SUFDOUI7QUFDSjtBQUNBOUwsY0FBYyxHQUFHRTtBQUNqQixlQUFldU0scUJBQXFCM0YsSUFBSTtJQUNwQyxJQUFJO1FBQ0EsTUFBTXpGLE9BQU95RjtJQUNqQixFQUNBLE9BQU9wQixJQUFJO1FBQ1AsTUFBTXZFLFFBQVEyRixNQUFNO1lBQUUyRyxXQUFXO1FBQUs7SUFDMUM7QUFDSjtBQUNBLGVBQWVyRSxZQUFZNEQsSUFBSTtJQUMzQixJQUFJO1FBQ0EsT0FBTyxNQUFNQTtJQUNqQixFQUNBLE9BQU90SCxJQUFJO1FBQ1AsU0FBUztRQUNULE9BQU8zQjtJQUNYO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2ljLWZ0cC9kaXN0L0NsaWVudC5qcz84Y2E2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DbGllbnQgPSB2b2lkIDA7XG5jb25zdCBmc18xID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgcGF0aF8xID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCB0bHNfMSA9IHJlcXVpcmUoXCJ0bHNcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IEZ0cENvbnRleHRfMSA9IHJlcXVpcmUoXCIuL0Z0cENvbnRleHRcIik7XG5jb25zdCBwYXJzZUxpc3RfMSA9IHJlcXVpcmUoXCIuL3BhcnNlTGlzdFwiKTtcbmNvbnN0IFByb2dyZXNzVHJhY2tlcl8xID0gcmVxdWlyZShcIi4vUHJvZ3Jlc3NUcmFja2VyXCIpO1xuY29uc3QgU3RyaW5nV3JpdGVyXzEgPSByZXF1aXJlKFwiLi9TdHJpbmdXcml0ZXJcIik7XG5jb25zdCBwYXJzZUxpc3RNTFNEXzEgPSByZXF1aXJlKFwiLi9wYXJzZUxpc3RNTFNEXCIpO1xuY29uc3QgbmV0VXRpbHNfMSA9IHJlcXVpcmUoXCIuL25ldFV0aWxzXCIpO1xuY29uc3QgdHJhbnNmZXJfMSA9IHJlcXVpcmUoXCIuL3RyYW5zZmVyXCIpO1xuY29uc3QgcGFyc2VDb250cm9sUmVzcG9uc2VfMSA9IHJlcXVpcmUoXCIuL3BhcnNlQ29udHJvbFJlc3BvbnNlXCIpO1xuLy8gVXNlIHByb21pc2lmeSB0byBrZWVwIHRoZSBsaWJyYXJ5IGNvbXBhdGlibGUgd2l0aCBOb2RlIDguXG5jb25zdCBmc1JlYWREaXIgPSAoMCwgdXRpbF8xLnByb21pc2lmeSkoZnNfMS5yZWFkZGlyKTtcbmNvbnN0IGZzTWtEaXIgPSAoMCwgdXRpbF8xLnByb21pc2lmeSkoZnNfMS5ta2Rpcik7XG5jb25zdCBmc1N0YXQgPSAoMCwgdXRpbF8xLnByb21pc2lmeSkoZnNfMS5zdGF0KTtcbmNvbnN0IGZzT3BlbiA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KShmc18xLm9wZW4pO1xuY29uc3QgZnNDbG9zZSA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KShmc18xLmNsb3NlKTtcbmNvbnN0IGZzVW5saW5rID0gKDAsIHV0aWxfMS5wcm9taXNpZnkpKGZzXzEudW5saW5rKTtcbmNvbnN0IGRlZmF1bHRDbGllbnRPcHRpb25zID0ge1xuICAgIGFsbG93U2VwYXJhdGVUcmFuc2Zlckhvc3Q6IHRydWVcbn07XG5jb25zdCBMSVNUX0NPTU1BTkRTX0RFRkFVTFQgPSAoKSA9PiBbXCJMSVNUIC1hXCIsIFwiTElTVFwiXTtcbmNvbnN0IExJU1RfQ09NTUFORFNfTUxTRCA9ICgpID0+IFtcIk1MU0RcIiwgXCJMSVNUIC1hXCIsIFwiTElTVFwiXTtcbi8qKlxuICogSGlnaC1sZXZlbCBBUEkgdG8gaW50ZXJhY3Qgd2l0aCBhbiBGVFAgc2VydmVyLlxuICovXG5jbGFzcyBDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIGFuIEZUUCBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGltZW91dCAgVGltZW91dCBpbiBtaWxsaXNlY29uZHMsIHVzZSAwIGZvciBubyB0aW1lb3V0LiBPcHRpb25hbCwgZGVmYXVsdCBpcyAzMCBzZWNvbmRzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRpbWVvdXQgPSAzMDAwMCwgb3B0aW9ucyA9IGRlZmF1bHRDbGllbnRPcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXZhaWxhYmxlTGlzdENvbW1hbmRzID0gTElTVF9DT01NQU5EU19ERUZBVUxUKCk7XG4gICAgICAgIHRoaXMuZnRwID0gbmV3IEZ0cENvbnRleHRfMS5GVFBDb250ZXh0KHRpbWVvdXQpO1xuICAgICAgICB0aGlzLnByZXBhcmVUcmFuc2ZlciA9IHRoaXMuX2VudGVyRmlyc3RDb21wYXRpYmxlTW9kZShbXG4gICAgICAgICAgICB0cmFuc2Zlcl8xLmVudGVyUGFzc2l2ZU1vZGVJUHY2LFxuICAgICAgICAgICAgb3B0aW9ucy5hbGxvd1NlcGFyYXRlVHJhbnNmZXJIb3N0ID8gdHJhbnNmZXJfMS5lbnRlclBhc3NpdmVNb2RlSVB2NCA6IHRyYW5zZmVyXzEuZW50ZXJQYXNzaXZlTW9kZUlQdjRfZm9yY2VDb250cm9sSG9zdElQXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLnBhcnNlTGlzdCA9IHBhcnNlTGlzdF8xLnBhcnNlTGlzdDtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NUcmFja2VyID0gbmV3IFByb2dyZXNzVHJhY2tlcl8xLlByb2dyZXNzVHJhY2tlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgY2xpZW50IGFuZCBhbGwgb3BlbiBzb2NrZXQgY29ubmVjdGlvbnMuXG4gICAgICpcbiAgICAgKiBDbG9zZSB0aGUgY2xpZW50IGFuZCBhbGwgb3BlbiBzb2NrZXQgY29ubmVjdGlvbnMuIFRoZSBjbGllbnQgY2Fu4oCZdCBiZSB1c2VkIGFueW1vcmUgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCxcbiAgICAgKiB5b3UgaGF2ZSB0byBlaXRoZXIgcmVjb25uZWN0IHdpdGggYGFjY2Vzc2Agb3IgYGNvbm5lY3RgIG9yIGluc3RhbnRpYXRlIGEgbmV3IGluc3RhbmNlIHRvIGNvbnRpbnVlIGFueSB3b3JrLlxuICAgICAqIEEgY2xpZW50IGlzIGFsc28gY2xvc2VkIGF1dG9tYXRpY2FsbHkgaWYgYW55IHRpbWVvdXQgb3IgY29ubmVjdGlvbiBlcnJvciBvY2N1cnMuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuZnRwLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX3Byb2dyZXNzVHJhY2tlci5zdG9wKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2xpZW50IGlzIGNsb3NlZCBhbmQgY2FuJ3QgYmUgdXNlZCBhbnltb3JlLlxuICAgICAqL1xuICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ0cC5jbG9zZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgKG9yIHJlY29ubmVjdCkgdG8gYW4gRlRQIHNlcnZlci5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gaW5zdGFuY2UgbWV0aG9kIGFuZCB0aHVzIGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIHRoZSBsaWZlY3ljbGUgb2YgYSBgQ2xpZW50YFxuICAgICAqIGluc3RhbmNlLiBXaGVuZXZlciB5b3UgZG8sIHRoZSBjbGllbnQgaXMgcmVzZXQgd2l0aCBhIG5ldyBjb250cm9sIGNvbm5lY3Rpb24uIFRoaXMgYWxzbyBpbXBsaWVzIHRoYXRcbiAgICAgKiB5b3UgY2FuIHJlb3BlbiBhIGBDbGllbnRgIGluc3RhbmNlIHRoYXQgaGFzIGJlZW4gY2xvc2VkIGR1ZSB0byBhbiBlcnJvciB3aGVuIHJlY29ubmVjdGluZyB3aXRoIHRoaXNcbiAgICAgKiBtZXRob2QuIEluIGZhY3QsIHJlY29ubmVjdGluZyBpcyB0aGUgb25seSB3YXkgdG8gY29udGludWUgdXNpbmcgYSBjbG9zZWQgYENsaWVudGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaG9zdCAgSG9zdCB0aGUgY2xpZW50IHNob3VsZCBjb25uZWN0IHRvLiBPcHRpb25hbCwgZGVmYXVsdCBpcyBcImxvY2FsaG9zdFwiLlxuICAgICAqIEBwYXJhbSBwb3J0ICBQb3J0IHRoZSBjbGllbnQgc2hvdWxkIGNvbm5lY3QgdG8uIE9wdGlvbmFsLCBkZWZhdWx0IGlzIDIxLlxuICAgICAqL1xuICAgIGNvbm5lY3QoaG9zdCA9IFwibG9jYWxob3N0XCIsIHBvcnQgPSAyMSkge1xuICAgICAgICB0aGlzLmZ0cC5yZXNldCgpO1xuICAgICAgICB0aGlzLmZ0cC5zb2NrZXQuY29ubmVjdCh7XG4gICAgICAgICAgICBob3N0LFxuICAgICAgICAgICAgcG9ydCxcbiAgICAgICAgICAgIGZhbWlseTogdGhpcy5mdHAuaXBGYW1pbHlcbiAgICAgICAgfSwgKCkgPT4gdGhpcy5mdHAubG9nKGBDb25uZWN0ZWQgdG8gJHsoMCwgbmV0VXRpbHNfMS5kZXNjcmliZUFkZHJlc3MpKHRoaXMuZnRwLnNvY2tldCl9ICgkeygwLCBuZXRVdGlsc18xLmRlc2NyaWJlVExTKSh0aGlzLmZ0cC5zb2NrZXQpfSlgKSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVDb25uZWN0UmVzcG9uc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXMgYGNvbm5lY3RgIGJ1dCB1c2luZyBpbXBsaWNpdCBUTFMuIEltcGxpY2l0IFRMUyBpcyBub3QgYW4gRlRQIHN0YW5kYXJkIGFuZCBoYXMgYmVlbiByZXBsYWNlZCBieVxuICAgICAqIGV4cGxpY2l0IFRMUy4gVGhlcmUgYXJlIHN0aWxsIEZUUCBzZXJ2ZXJzIHRoYXQgc3VwcG9ydCBvbmx5IGltcGxpY2l0IFRMUywgdGhvdWdoLlxuICAgICAqL1xuICAgIGNvbm5lY3RJbXBsaWNpdFRMUyhob3N0ID0gXCJsb2NhbGhvc3RcIiwgcG9ydCA9IDIxLCB0bHNPcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5mdHAucmVzZXQoKTtcbiAgICAgICAgdGhpcy5mdHAuc29ja2V0ID0gKDAsIHRsc18xLmNvbm5lY3QpKHBvcnQsIGhvc3QsIHRsc09wdGlvbnMsICgpID0+IHRoaXMuZnRwLmxvZyhgQ29ubmVjdGVkIHRvICR7KDAsIG5ldFV0aWxzXzEuZGVzY3JpYmVBZGRyZXNzKSh0aGlzLmZ0cC5zb2NrZXQpfSAoJHsoMCwgbmV0VXRpbHNfMS5kZXNjcmliZVRMUykodGhpcy5mdHAuc29ja2V0KX0pYCkpO1xuICAgICAgICB0aGlzLmZ0cC50bHNPcHRpb25zID0gdGxzT3B0aW9ucztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUNvbm5lY3RSZXNwb25zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBmaXJzdCByZXBvbnNlIGJ5IGFuIEZUUCBzZXJ2ZXIgYWZ0ZXIgdGhlIHNvY2tldCBjb25uZWN0aW9uIGhhcyBiZWVuIGVzdGFibGlzaGVkLlxuICAgICAqL1xuICAgIF9oYW5kbGVDb25uZWN0UmVzcG9uc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ0cC5oYW5kbGUodW5kZWZpbmVkLCAocmVzLCB0YXNrKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY29ubmVjdGlvbiBoYXMgYmVlbiBkZXN0cm95ZWQgYnkgdGhlIEZUUENvbnRleHQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICAgICAgICB0YXNrLnJlamVjdChyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKDAsIHBhcnNlQ29udHJvbFJlc3BvbnNlXzEucG9zaXRpdmVDb21wbGV0aW9uKShyZXMuY29kZSkpIHtcbiAgICAgICAgICAgICAgICB0YXNrLnJlc29sdmUocmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlamVjdCBhbGwgb3RoZXIgY29kZXMsIGluY2x1ZGluZyAxMjAgXCJTZXJ2aWNlIHJlYWR5IGluIG5ubiBtaW51dGVzXCIuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBzdGF5IGNvbm5lY3RlZCBidXQgZG9uJ3QgcmVwbGFjZSB0aGUgc29ja2V0IHlldCBieSB1c2luZyByZXNldCgpXG4gICAgICAgICAgICAgICAgLy8gc28gdGhlIHVzZXIgY2FuIGluc3BlY3QgcHJvcGVydGllcyBvZiB0aGlzIGluc3RhbmNlLlxuICAgICAgICAgICAgICAgIHRhc2sucmVqZWN0KG5ldyBGdHBDb250ZXh0XzEuRlRQRXJyb3IocmVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGFuIEZUUCBjb21tYW5kIGFuZCBoYW5kbGUgdGhlIGZpcnN0IHJlc3BvbnNlLlxuICAgICAqL1xuICAgIHNlbmQoY29tbWFuZCwgaWdub3JlRXJyb3JDb2Rlc0RFUFJFQ0FURUQgPSBmYWxzZSkge1xuICAgICAgICBpZiAoaWdub3JlRXJyb3JDb2Rlc0RFUFJFQ0FURUQpIHsgLy8gRGVwcmVjYXRlZCBzdGFydGluZyBmcm9tIDMuOS4wXG4gICAgICAgICAgICB0aGlzLmZ0cC5sb2coXCJEZXByZWNhdGVkIGNhbGwgdXNpbmcgc2VuZChjb21tYW5kLCBmbGFnKSB3aXRoIGJvb2xlYW4gZmxhZyB0byBpZ25vcmUgZXJyb3JzLiBVc2Ugc2VuZElnbm9yaW5nRXJyb3IoY29tbWFuZCkuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZElnbm9yaW5nRXJyb3IoY29tbWFuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZnRwLnJlcXVlc3QoY29tbWFuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYW4gRlRQIGNvbW1hbmQgYW5kIGlnbm9yZSBhbiBGVFAgZXJyb3IgcmVzcG9uc2UuIEFueSBvdGhlciBraW5kIG9mIGVycm9yIG9yIHRpbWVvdXQgd2lsbCBzdGlsbCByZWplY3QgdGhlIFByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tbWFuZFxuICAgICAqL1xuICAgIHNlbmRJZ25vcmluZ0Vycm9yKGNvbW1hbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnRwLmhhbmRsZShjb21tYW5kLCAocmVzLCB0YXNrKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgRnRwQ29udGV4dF8xLkZUUEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGFzay5yZXNvbHZlKHsgY29kZTogcmVzLmNvZGUsIG1lc3NhZ2U6IHJlcy5tZXNzYWdlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0YXNrLnJlamVjdChyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFzay5yZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGdyYWRlIHRoZSBjdXJyZW50IHNvY2tldCBjb25uZWN0aW9uIHRvIFRMUy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zICBUTFMgb3B0aW9ucyBhcyBpbiBgdGxzLmNvbm5lY3Qob3B0aW9ucylgLCBvcHRpb25hbC5cbiAgICAgKiBAcGFyYW0gY29tbWFuZCAgU2V0IHRoZSBhdXRoZW50aWNhdGlvbiBjb21tYW5kLiBPcHRpb25hbCwgZGVmYXVsdCBpcyBcIkFVVEggVExTXCIuXG4gICAgICovXG4gICAgYXN5bmMgdXNlVExTKG9wdGlvbnMgPSB7fSwgY29tbWFuZCA9IFwiQVVUSCBUTFNcIikge1xuICAgICAgICBjb25zdCByZXQgPSBhd2FpdCB0aGlzLnNlbmQoY29tbWFuZCk7XG4gICAgICAgIHRoaXMuZnRwLnNvY2tldCA9IGF3YWl0ICgwLCBuZXRVdGlsc18xLnVwZ3JhZGVTb2NrZXQpKHRoaXMuZnRwLnNvY2tldCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZnRwLnRsc09wdGlvbnMgPSBvcHRpb25zOyAvLyBLZWVwIHRoZSBUTFMgb3B0aW9ucyBmb3IgbGF0ZXIgZGF0YSBjb25uZWN0aW9ucyB0aGF0IHNob3VsZCB1c2UgdGhlIHNhbWUgb3B0aW9ucy5cbiAgICAgICAgdGhpcy5mdHAubG9nKGBDb250cm9sIHNvY2tldCBpcyB1c2luZzogJHsoMCwgbmV0VXRpbHNfMS5kZXNjcmliZVRMUykodGhpcy5mdHAuc29ja2V0KX1gKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9naW4gYSB1c2VyIHdpdGggYSBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyICBVc2VybmFtZSB0byB1c2UgZm9yIGxvZ2luLiBPcHRpb25hbCwgZGVmYXVsdCBpcyBcImFub255bW91c1wiLlxuICAgICAqIEBwYXJhbSBwYXNzd29yZCAgUGFzc3dvcmQgdG8gdXNlIGZvciBsb2dpbi4gT3B0aW9uYWwsIGRlZmF1bHQgaXMgXCJndWVzdFwiLlxuICAgICAqL1xuICAgIGxvZ2luKHVzZXIgPSBcImFub255bW91c1wiLCBwYXNzd29yZCA9IFwiZ3Vlc3RcIikge1xuICAgICAgICB0aGlzLmZ0cC5sb2coYExvZ2luIHNlY3VyaXR5OiAkeygwLCBuZXRVdGlsc18xLmRlc2NyaWJlVExTKSh0aGlzLmZ0cC5zb2NrZXQpfWApO1xuICAgICAgICByZXR1cm4gdGhpcy5mdHAuaGFuZGxlKFwiVVNFUiBcIiArIHVzZXIsIChyZXMsIHRhc2spID0+IHtcbiAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRhc2sucmVqZWN0KHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoMCwgcGFyc2VDb250cm9sUmVzcG9uc2VfMS5wb3NpdGl2ZUNvbXBsZXRpb24pKHJlcy5jb2RlKSkgeyAvLyBVc2VyIGxvZ2dlZCBpbiBwcm9jZWVkIE9SIENvbW1hbmQgc3VwZXJmbHVvdXNcbiAgICAgICAgICAgICAgICB0YXNrLnJlc29sdmUocmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlcy5jb2RlID09PSAzMzEpIHsgLy8gVXNlciBuYW1lIG9rYXksIG5lZWQgcGFzc3dvcmRcbiAgICAgICAgICAgICAgICB0aGlzLmZ0cC5zZW5kKFwiUEFTUyBcIiArIHBhc3N3b3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBBbHNvIHJlcG9ydCBlcnJvciBvbiAzMzIgKE5lZWQgYWNjb3VudClcbiAgICAgICAgICAgICAgICB0YXNrLnJlamVjdChuZXcgRnRwQ29udGV4dF8xLkZUUEVycm9yKHJlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB1c3VhbCBkZWZhdWx0IHNldHRpbmdzLlxuICAgICAqXG4gICAgICogU2V0dGluZ3MgdXNlZDpcbiAgICAgKiAqIEJpbmFyeSBtb2RlIChUWVBFIEkpXG4gICAgICogKiBGaWxlIHN0cnVjdHVyZSAoU1RSVSBGKVxuICAgICAqICogQWRkaXRpb25hbCBzZXR0aW5ncyBmb3IgRlRQUyAoUEJTWiAwLCBQUk9UIFApXG4gICAgICovXG4gICAgYXN5bmMgdXNlRGVmYXVsdFNldHRpbmdzKCkge1xuICAgICAgICBjb25zdCBmZWF0dXJlcyA9IGF3YWl0IHRoaXMuZmVhdHVyZXMoKTtcbiAgICAgICAgLy8gVXNlIE1MU0QgZGlyZWN0b3J5IGxpc3RpbmcgaWYgcG9zc2libGUuIFNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzY1OSNzZWN0aW9uLTcuODpcbiAgICAgICAgLy8gXCJUaGUgcHJlc2VuY2Ugb2YgdGhlIE1MU1QgZmVhdHVyZSBpbmRpY2F0ZXMgdGhhdCBib3RoIE1MU1QgYW5kIE1MU0QgYXJlIHN1cHBvcnRlZC5cIlxuICAgICAgICBjb25zdCBzdXBwb3J0c01MU0QgPSBmZWF0dXJlcy5oYXMoXCJNTFNUXCIpO1xuICAgICAgICB0aGlzLmF2YWlsYWJsZUxpc3RDb21tYW5kcyA9IHN1cHBvcnRzTUxTRCA/IExJU1RfQ09NTUFORFNfTUxTRCgpIDogTElTVF9DT01NQU5EU19ERUZBVUxUKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZChcIlRZUEUgSVwiKTsgLy8gQmluYXJ5IG1vZGVcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kSWdub3JpbmdFcnJvcihcIlNUUlUgRlwiKTsgLy8gVXNlIGZpbGUgc3RydWN0dXJlXG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZElnbm9yaW5nRXJyb3IoXCJPUFRTIFVURjggT05cIik7IC8vIFNvbWUgc2VydmVycyBleHBlY3QgVVRGLTggdG8gYmUgZW5hYmxlZCBleHBsaWNpdGx5IGFuZCBzZXR0aW5nIGJlZm9yZSBsb2dpbiBtaWdodCBub3QgaGF2ZSB3b3JrZWQuXG4gICAgICAgIGlmIChzdXBwb3J0c01MU0QpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZElnbm9yaW5nRXJyb3IoXCJPUFRTIE1MU1QgdHlwZTtzaXplO21vZGlmeTt1bmlxdWU7dW5peC5tb2RlO3VuaXgub3duZXI7dW5peC5ncm91cDt1bml4Lm93bmVybmFtZTt1bml4Lmdyb3VwbmFtZTtcIik7IC8vIE1ha2Ugc3VyZSBNTFNEIGxpc3RpbmdzIGluY2x1ZGUgYWxsIHdlIGNhbiBwYXJzZVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZ0cC5oYXNUTFMpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZElnbm9yaW5nRXJyb3IoXCJQQlNaIDBcIik7IC8vIFNldCB0byAwIGZvciBUTFNcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZElnbm9yaW5nRXJyb3IoXCJQUk9UIFBcIik7IC8vIFByb3RlY3QgY2hhbm5lbCAoYWxzbyBmb3IgZGF0YSBjb25uZWN0aW9ucylcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBjYWxscyBgY29ubmVjdGAsIGB1c2VUTFNgLCBgbG9naW5gIGFuZCBgdXNlRGVmYXVsdFNldHRpbmdzYC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gaW5zdGFuY2UgbWV0aG9kIGFuZCB0aHVzIGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIHRoZSBsaWZlY3ljbGUgb2YgYSBgQ2xpZW50YFxuICAgICAqIGluc3RhbmNlLiBXaGVuZXZlciB5b3UgZG8sIHRoZSBjbGllbnQgaXMgcmVzZXQgd2l0aCBhIG5ldyBjb250cm9sIGNvbm5lY3Rpb24uIFRoaXMgYWxzbyBpbXBsaWVzIHRoYXRcbiAgICAgKiB5b3UgY2FuIHJlb3BlbiBhIGBDbGllbnRgIGluc3RhbmNlIHRoYXQgaGFzIGJlZW4gY2xvc2VkIGR1ZSB0byBhbiBlcnJvciB3aGVuIHJlY29ubmVjdGluZyB3aXRoIHRoaXNcbiAgICAgKiBtZXRob2QuIEluIGZhY3QsIHJlY29ubmVjdGluZyBpcyB0aGUgb25seSB3YXkgdG8gY29udGludWUgdXNpbmcgYSBjbG9zZWQgYENsaWVudGAuXG4gICAgICovXG4gICAgYXN5bmMgYWNjZXNzKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB1c2VFeHBsaWNpdFRMUyA9IG9wdGlvbnMuc2VjdXJlID09PSB0cnVlO1xuICAgICAgICBjb25zdCB1c2VJbXBsaWNpdFRMUyA9IG9wdGlvbnMuc2VjdXJlID09PSBcImltcGxpY2l0XCI7XG4gICAgICAgIGxldCB3ZWxjb21lO1xuICAgICAgICBpZiAodXNlSW1wbGljaXRUTFMpIHtcbiAgICAgICAgICAgIHdlbGNvbWUgPSBhd2FpdCB0aGlzLmNvbm5lY3RJbXBsaWNpdFRMUyhvcHRpb25zLmhvc3QsIG9wdGlvbnMucG9ydCwgb3B0aW9ucy5zZWN1cmVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdlbGNvbWUgPSBhd2FpdCB0aGlzLmNvbm5lY3Qob3B0aW9ucy5ob3N0LCBvcHRpb25zLnBvcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VFeHBsaWNpdFRMUykge1xuICAgICAgICAgICAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3BhdHJpY2tqdWNobGkvYmFzaWMtZnRwL2lzc3Vlcy8xNjYgYnkgbWFraW5nIHN1cmVcbiAgICAgICAgICAgIC8vIGhvc3QgaXMgc2V0IGZvciBhbnkgZnV0dXJlIGRhdGEgY29ubmVjdGlvbiBhcyB3ZWxsLlxuICAgICAgICAgICAgY29uc3Qgc2VjdXJlT3B0aW9ucyA9IChfYSA9IG9wdGlvbnMuc2VjdXJlT3B0aW9ucykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgICAgICAgICBzZWN1cmVPcHRpb25zLmhvc3QgPSAoX2IgPSBzZWN1cmVPcHRpb25zLmhvc3QpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG9wdGlvbnMuaG9zdDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudXNlVExTKHNlY3VyZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBVVEYtOCBvbiBiZWZvcmUgbG9naW4gaW4gY2FzZSB0aGVyZSBhcmUgbm9uLWFzY2lpIGNoYXJhY3RlcnMgaW4gdXNlciBvciBwYXNzd29yZC5cbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbWlnaHQgbm90IHdvcmsgYmVmb3JlIGxvZ2luIGRlcGVuZGluZyBvbiBzZXJ2ZXIuXG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZElnbm9yaW5nRXJyb3IoXCJPUFRTIFVURjggT05cIik7XG4gICAgICAgIGF3YWl0IHRoaXMubG9naW4ob3B0aW9ucy51c2VyLCBvcHRpb25zLnBhc3N3b3JkKTtcbiAgICAgICAgYXdhaXQgdGhpcy51c2VEZWZhdWx0U2V0dGluZ3MoKTtcbiAgICAgICAgcmV0dXJuIHdlbGNvbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICBhc3luYyBwd2QoKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuc2VuZChcIlBXRFwiKTtcbiAgICAgICAgLy8gVGhlIGRpcmVjdG9yeSBpcyBwYXJ0IG9mIHRoZSByZXR1cm4gbWVzc2FnZSwgZm9yIGV4YW1wbGU6XG4gICAgICAgIC8vIDI1NyBcIi90aGlzL3RoYXRcIiBpcyBjdXJyZW50IGRpcmVjdG9yeS5cbiAgICAgICAgY29uc3QgcGFyc2VkID0gcmVzLm1lc3NhZ2UubWF0Y2goL1wiKC4rKVwiLyk7XG4gICAgICAgIGlmIChwYXJzZWQgPT09IG51bGwgfHwgcGFyc2VkWzFdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgcGFyc2UgcmVzcG9uc2UgdG8gY29tbWFuZCAnUFdEJzogJHtyZXMubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkWzFdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBkZXNjcmlwdGlvbiBvZiBzdXBwb3J0ZWQgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIHNlbmRzIHRoZSBGRUFUIGNvbW1hbmQgYW5kIHBhcnNlcyB0aGUgcmVzdWx0IGludG8gYSBNYXAgd2hlcmUga2V5cyBjb3JyZXNwb25kIHRvIGF2YWlsYWJsZSBjb21tYW5kc1xuICAgICAqIGFuZCB2YWx1ZXMgaG9sZCBmdXJ0aGVyIGluZm9ybWF0aW9uLiBCZSBhd2FyZSB0aGF0IHlvdXIgRlRQIHNlcnZlcnMgbWlnaHQgbm90IHN1cHBvcnQgdGhpc1xuICAgICAqIGNvbW1hbmQgaW4gd2hpY2ggY2FzZSB0aGlzIG1ldGhvZCB3aWxsIG5vdCB0aHJvdyBhbiBleGNlcHRpb24gYnV0IGp1c3QgcmV0dXJuIGFuIGVtcHR5IE1hcC5cbiAgICAgKi9cbiAgICBhc3luYyBmZWF0dXJlcygpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5zZW5kSWdub3JpbmdFcnJvcihcIkZFQVRcIik7XG4gICAgICAgIGNvbnN0IGZlYXR1cmVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBOb3Qgc3VwcG9ydGluZyBhbnkgc3BlY2lhbCBmZWF0dXJlcyB3aWxsIGJlIHJlcG9ydGVkIHdpdGggYSBzaW5nbGUgbGluZS5cbiAgICAgICAgaWYgKHJlcy5jb2RlIDwgNDAwICYmICgwLCBwYXJzZUNvbnRyb2xSZXNwb25zZV8xLmlzTXVsdGlsaW5lKShyZXMubWVzc2FnZSkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBhbmQgbGFzdCBsaW5lIHdyYXAgdGhlIG11bHRpbGluZSByZXNwb25zZSwgaWdub3JlIHRoZW0uXG4gICAgICAgICAgICByZXMubWVzc2FnZS5zcGxpdChcIlxcblwiKS5zbGljZSgxLCAtMSkuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgICAgICAgICAvLyBBIHR5cGljYWwgbGluZXMgbG9va3MgbGlrZTogXCIgUkVTVCBTVFJFQU1cIiBvciBcIiBNRFRNXCIuXG4gICAgICAgICAgICAgICAgLy8gU2VydmVycyBtaWdodCBub3QgdXNlIGFuIGluZGVudGF0aW9uIHRob3VnaC5cbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IGxpbmUudHJpbSgpLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICAgICAgICBmZWF0dXJlcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdIHx8IFwiXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZlYXR1cmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHdvcmtpbmcgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIGFzeW5jIGNkKHBhdGgpIHtcbiAgICAgICAgY29uc3QgdmFsaWRQYXRoID0gYXdhaXQgdGhpcy5wcm90ZWN0V2hpdGVzcGFjZShwYXRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChcIkNXRCBcIiArIHZhbGlkUGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN3aXRjaCB0byB0aGUgcGFyZW50IGRpcmVjdG9yeSBvZiB0aGUgd29ya2luZyBkaXJlY3RvcnkuXG4gICAgICovXG4gICAgYXN5bmMgY2R1cCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChcIkNEVVBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGFzdCBtb2RpZmllZCB0aW1lIG9mIGEgZmlsZS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGV2ZXJ5IEZUUCBzZXJ2ZXIsIGluIHdoaWNoIGNhc2VcbiAgICAgKiBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIGxhc3RNb2QocGF0aCkge1xuICAgICAgICBjb25zdCB2YWxpZFBhdGggPSBhd2FpdCB0aGlzLnByb3RlY3RXaGl0ZXNwYWNlKHBhdGgpO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnNlbmQoYE1EVE0gJHt2YWxpZFBhdGh9YCk7XG4gICAgICAgIGNvbnN0IGRhdGUgPSByZXMubWVzc2FnZS5zbGljZSg0KTtcbiAgICAgICAgcmV0dXJuICgwLCBwYXJzZUxpc3RNTFNEXzEucGFyc2VNTFN4RGF0ZSkoZGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc2l6ZSBvZiBhIGZpbGUuXG4gICAgICovXG4gICAgYXN5bmMgc2l6ZShwYXRoKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkUGF0aCA9IGF3YWl0IHRoaXMucHJvdGVjdFdoaXRlc3BhY2UocGF0aCk7XG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSBgU0laRSAke3ZhbGlkUGF0aH1gO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnNlbmQoY29tbWFuZCk7XG4gICAgICAgIC8vIFRoZSBzaXplIGlzIHBhcnQgb2YgdGhlIHJlc3BvbnNlIG1lc3NhZ2UsIGZvciBleGFtcGxlOiBcIjIxMyA1NTU1NTVcIi4gSXQnc1xuICAgICAgICAvLyBwb3NzaWJsZSB0aGF0IHRoZXJlIGlzIGEgY29tbW1lbnRhcnkgYXBwZW5kZWQgbGlrZSBcIjIxMyA1NTU1LCBzb21lIGNvbW1lbnRhcnlcIi5cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlSW50KHJlcy5tZXNzYWdlLnNsaWNlKDQpLCAxMCk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oc2l6ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgcGFyc2UgcmVzcG9uc2UgdG8gY29tbWFuZCAnJHtjb21tYW5kfScgYXMgYSBudW1lcmljYWwgdmFsdWU6ICR7cmVzLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmFtZSBhIGZpbGUuXG4gICAgICpcbiAgICAgKiBEZXBlbmRpbmcgb24gdGhlIEZUUCBzZXJ2ZXIgdGhpcyBtaWdodCBhbHNvIGJlIHVzZWQgdG8gbW92ZSBhIGZpbGUgZnJvbSBvbmVcbiAgICAgKiBkaXJlY3RvcnkgdG8gYW5vdGhlciBieSBwcm92aWRpbmcgZnVsbCBwYXRocy5cbiAgICAgKi9cbiAgICBhc3luYyByZW5hbWUoc3JjUGF0aCwgZGVzdFBhdGgpIHtcbiAgICAgICAgY29uc3QgdmFsaWRTcmMgPSBhd2FpdCB0aGlzLnByb3RlY3RXaGl0ZXNwYWNlKHNyY1BhdGgpO1xuICAgICAgICBjb25zdCB2YWxpZERlc3QgPSBhd2FpdCB0aGlzLnByb3RlY3RXaGl0ZXNwYWNlKGRlc3RQYXRoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kKFwiUk5GUiBcIiArIHZhbGlkU3JjKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChcIlJOVE8gXCIgKyB2YWxpZERlc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBmaWxlIGZyb20gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGlnbm9yZSBGVFAgZXJyb3IgcmV0dXJuIGNvZGVzIHdoaWNoIHdvbid0IHRocm93IGFuIGV4Y2VwdGlvbiBpZiBlLmcuXG4gICAgICogdGhlIGZpbGUgZG9lc24ndCBleGlzdC5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmUocGF0aCwgaWdub3JlRXJyb3JDb2RlcyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkUGF0aCA9IGF3YWl0IHRoaXMucHJvdGVjdFdoaXRlc3BhY2UocGF0aCk7XG4gICAgICAgIGlmIChpZ25vcmVFcnJvckNvZGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kSWdub3JpbmdFcnJvcihgREVMRSAke3ZhbGlkUGF0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKGBERUxFICR7dmFsaWRQYXRofWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBvcnQgdHJhbnNmZXIgcHJvZ3Jlc3MgZm9yIGFueSB1cGxvYWQgb3IgZG93bmxvYWQgdG8gYSBnaXZlbiBoYW5kbGVyLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGFsc28gcmVzZXQgdGhlIG92ZXJhbGwgdHJhbnNmZXIgY291bnRlciB0aGF0IGNhbiBiZSB1c2VkIGZvciBtdWx0aXBsZSB0cmFuc2ZlcnMuIFlvdSBjYW5cbiAgICAgKiBhbHNvIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGhvdXQgYSBoYW5kbGVyIHRvIHN0b3AgcmVwb3J0aW5nIHRvIGFuIGVhcmxpZXIgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIGhhbmRsZXIgIEhhbmRsZXIgZnVuY3Rpb24gdG8gY2FsbCBvbiB0cmFuc2ZlciBwcm9ncmVzcy5cbiAgICAgKi9cbiAgICB0cmFja1Byb2dyZXNzKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NUcmFja2VyLmJ5dGVzT3ZlcmFsbCA9IDA7XG4gICAgICAgIHRoaXMuX3Byb2dyZXNzVHJhY2tlci5yZXBvcnRUbyhoYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkIGRhdGEgZnJvbSBhIHJlYWRhYmxlIHN0cmVhbSBvciBhIGxvY2FsIGZpbGUgdG8gYSByZW1vdGUgZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzb3VyY2UgIFJlYWRhYmxlIHN0cmVhbSBvciBwYXRoIHRvIGEgbG9jYWwgZmlsZS5cbiAgICAgKiBAcGFyYW0gdG9SZW1vdGVQYXRoICBQYXRoIHRvIGEgcmVtb3RlIGZpbGUgdG8gd3JpdGUgdG8uXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkRnJvbShzb3VyY2UsIHRvUmVtb3RlUGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGxvYWRXaXRoQ29tbWFuZChzb3VyY2UsIHRvUmVtb3RlUGF0aCwgXCJTVE9SXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgZGF0YSBmcm9tIGEgcmVhZGFibGUgc3RyZWFtIG9yIGEgbG9jYWwgZmlsZSBieSBhcHBlbmRpbmcgaXQgdG8gYW4gZXhpc3RpbmcgZmlsZS4gSWYgdGhlIGZpbGUgZG9lc24ndFxuICAgICAqIGV4aXN0IHRoZSBGVFAgc2VydmVyIHNob3VsZCBjcmVhdGUgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc291cmNlICBSZWFkYWJsZSBzdHJlYW0gb3IgcGF0aCB0byBhIGxvY2FsIGZpbGUuXG4gICAgICogQHBhcmFtIHRvUmVtb3RlUGF0aCAgUGF0aCB0byBhIHJlbW90ZSBmaWxlIHRvIHdyaXRlIHRvLlxuICAgICAqL1xuICAgIGFzeW5jIGFwcGVuZEZyb20oc291cmNlLCB0b1JlbW90ZVBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXBsb2FkV2l0aENvbW1hbmQoc291cmNlLCB0b1JlbW90ZVBhdGgsIFwiQVBQRVwiLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIF91cGxvYWRXaXRoQ29tbWFuZChzb3VyY2UsIHJlbW90ZVBhdGgsIGNvbW1hbmQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91cGxvYWRMb2NhbEZpbGUoc291cmNlLCByZW1vdGVQYXRoLCBjb21tYW5kLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdXBsb2FkRnJvbVN0cmVhbShzb3VyY2UsIHJlbW90ZVBhdGgsIGNvbW1hbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgX3VwbG9hZExvY2FsRmlsZShsb2NhbFBhdGgsIHJlbW90ZVBhdGgsIGNvbW1hbmQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZmQgPSBhd2FpdCBmc09wZW4obG9jYWxQYXRoLCBcInJcIik7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9ICgwLCBmc18xLmNyZWF0ZVJlYWRTdHJlYW0pKFwiXCIsIHtcbiAgICAgICAgICAgIGZkLFxuICAgICAgICAgICAgc3RhcnQ6IG9wdGlvbnMubG9jYWxTdGFydCxcbiAgICAgICAgICAgIGVuZDogb3B0aW9ucy5sb2NhbEVuZEluY2x1c2l2ZSxcbiAgICAgICAgICAgIGF1dG9DbG9zZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXBsb2FkRnJvbVN0cmVhbShzb3VyY2UsIHJlbW90ZVBhdGgsIGNvbW1hbmQpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgYXdhaXQgaWdub3JlRXJyb3IoKCkgPT4gZnNDbG9zZShmZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBfdXBsb2FkRnJvbVN0cmVhbShzb3VyY2UsIHJlbW90ZVBhdGgsIGNvbW1hbmQpIHtcbiAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHRoaXMuZnRwLmNsb3NlV2l0aEVycm9yKGVycik7XG4gICAgICAgIHNvdXJjZS5vbmNlKFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2YWxpZFBhdGggPSBhd2FpdCB0aGlzLnByb3RlY3RXaGl0ZXNwYWNlKHJlbW90ZVBhdGgpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wcmVwYXJlVHJhbnNmZXIodGhpcy5mdHApO1xuICAgICAgICAgICAgLy8gS2VlcCB0aGUga2V5d29yZCBgYXdhaXRgIG9yIHRoZSBgZmluYWxseWAgY2xhdXNlIGJlbG93IHJ1bnMgdG9vIGVhcmx5XG4gICAgICAgICAgICAvLyBhbmQgcmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBzb3VyY2Ugc3RyZWFtIHRvbyBlYXJseS5cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCAoMCwgdHJhbnNmZXJfMS51cGxvYWRGcm9tKShzb3VyY2UsIHtcbiAgICAgICAgICAgICAgICBmdHA6IHRoaXMuZnRwLFxuICAgICAgICAgICAgICAgIHRyYWNrZXI6IHRoaXMuX3Byb2dyZXNzVHJhY2tlcixcbiAgICAgICAgICAgICAgICBjb21tYW5kLFxuICAgICAgICAgICAgICAgIHJlbW90ZVBhdGg6IHZhbGlkUGF0aCxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVwbG9hZFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvd25sb2FkIGEgcmVtb3RlIGZpbGUgYW5kIHBpcGUgaXRzIGRhdGEgdG8gYSB3cml0YWJsZSBzdHJlYW0gb3IgdG8gYSBsb2NhbCBmaWxlLlxuICAgICAqXG4gICAgICogWW91IGNhbiBvcHRpb25hbGx5IGRlZmluZSBhdCB3aGljaCBwb3NpdGlvbiBvZiB0aGUgcmVtb3RlIGZpbGUgeW91J2QgbGlrZSB0byBzdGFydFxuICAgICAqIGRvd25sb2FkaW5nLiBJZiB0aGUgZGVzdGluYXRpb24geW91IHByb3ZpZGUgaXMgYSBmaWxlLCB0aGUgb2Zmc2V0IHdpbGwgYmUgYXBwbGllZFxuICAgICAqIHRvIGl0IGFzIHdlbGwuIEZvciBleGFtcGxlOiBUbyByZXN1bWUgYSBmYWlsZWQgZG93bmxvYWQsIHlvdSdkIHJlcXVlc3QgdGhlIHNpemUgb2ZcbiAgICAgKiB0aGUgbG9jYWwsIHBhcnRpYWxseSBkb3dubG9hZGVkIGZpbGUgYW5kIHVzZSB0aGF0IGFzIHRoZSBvZmZzZXQuIEFzc3VtaW5nIHRoZSBzaXplXG4gICAgICogaXMgMjMsIHlvdSdkIGRvd25sb2FkIHRoZSByZXN0IHVzaW5nIGBkb3dubG9hZFRvKFwibG9jYWwudHh0XCIsIFwicmVtb3RlLnR4dFwiLCAyMylgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRlc3RpbmF0aW9uICBTdHJlYW0gb3IgcGF0aCBmb3IgYSBsb2NhbCBmaWxlIHRvIHdyaXRlIHRvLlxuICAgICAqIEBwYXJhbSBmcm9tUmVtb3RlUGF0aCAgUGF0aCBvZiB0aGUgcmVtb3RlIGZpbGUgdG8gcmVhZCBmcm9tLlxuICAgICAqIEBwYXJhbSBzdGFydEF0ICBQb3NpdGlvbiB3aXRoaW4gdGhlIHJlbW90ZSBmaWxlIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGF0LiBJZiB0aGUgZGVzdGluYXRpb24gaXMgYSBmaWxlLCB0aGlzIG9mZnNldCBpcyBhbHNvIGFwcGxpZWQgdG8gaXQuXG4gICAgICovXG4gICAgYXN5bmMgZG93bmxvYWRUbyhkZXN0aW5hdGlvbiwgZnJvbVJlbW90ZVBhdGgsIHN0YXJ0QXQgPSAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kb3dubG9hZFRvRmlsZShkZXN0aW5hdGlvbiwgZnJvbVJlbW90ZVBhdGgsIHN0YXJ0QXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kb3dubG9hZFRvU3RyZWFtKGRlc3RpbmF0aW9uLCBmcm9tUmVtb3RlUGF0aCwgc3RhcnRBdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBfZG93bmxvYWRUb0ZpbGUobG9jYWxQYXRoLCByZW1vdGVQYXRoLCBzdGFydEF0KSB7XG4gICAgICAgIGNvbnN0IGFwcGVuZGluZ1RvTG9jYWxGaWxlID0gc3RhcnRBdCA+IDA7XG4gICAgICAgIGNvbnN0IGZpbGVTeXN0ZW1GbGFncyA9IGFwcGVuZGluZ1RvTG9jYWxGaWxlID8gXCJyK1wiIDogXCJ3XCI7XG4gICAgICAgIGNvbnN0IGZkID0gYXdhaXQgZnNPcGVuKGxvY2FsUGF0aCwgZmlsZVN5c3RlbUZsYWdzKTtcbiAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSAoMCwgZnNfMS5jcmVhdGVXcml0ZVN0cmVhbSkoXCJcIiwge1xuICAgICAgICAgICAgZmQsXG4gICAgICAgICAgICBzdGFydDogc3RhcnRBdCxcbiAgICAgICAgICAgIGF1dG9DbG9zZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fZG93bmxvYWRUb1N0cmVhbShkZXN0aW5hdGlvbiwgcmVtb3RlUGF0aCwgc3RhcnRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxGaWxlU3RhdHMgPSBhd2FpdCBpZ25vcmVFcnJvcigoKSA9PiBmc1N0YXQobG9jYWxQYXRoKSk7XG4gICAgICAgICAgICBjb25zdCBoYXNEb3dubG9hZGVkRGF0YSA9IGxvY2FsRmlsZVN0YXRzICYmIGxvY2FsRmlsZVN0YXRzLnNpemUgPiAwO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmVtb3ZlTG9jYWxGaWxlID0gIWFwcGVuZGluZ1RvTG9jYWxGaWxlICYmICFoYXNEb3dubG9hZGVkRGF0YTtcbiAgICAgICAgICAgIGlmIChzaG91bGRSZW1vdmVMb2NhbEZpbGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBpZ25vcmVFcnJvcigoKSA9PiBmc1VubGluayhsb2NhbFBhdGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0IGlnbm9yZUVycm9yKCgpID0+IGZzQ2xvc2UoZmQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgX2Rvd25sb2FkVG9TdHJlYW0oZGVzdGluYXRpb24sIHJlbW90ZVBhdGgsIHN0YXJ0QXQpIHtcbiAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHRoaXMuZnRwLmNsb3NlV2l0aEVycm9yKGVycik7XG4gICAgICAgIGRlc3RpbmF0aW9uLm9uY2UoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkUGF0aCA9IGF3YWl0IHRoaXMucHJvdGVjdFdoaXRlc3BhY2UocmVtb3RlUGF0aCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnByZXBhcmVUcmFuc2Zlcih0aGlzLmZ0cCk7XG4gICAgICAgICAgICAvLyBLZWVwIHRoZSBrZXl3b3JkIGBhd2FpdGAgb3IgdGhlIGBmaW5hbGx5YCBjbGF1c2UgYmVsb3cgcnVucyB0b28gZWFybHlcbiAgICAgICAgICAgIC8vIGFuZCByZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lciBmb3IgdGhlIHNvdXJjZSBzdHJlYW0gdG9vIGVhcmx5LlxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0ICgwLCB0cmFuc2Zlcl8xLmRvd25sb2FkVG8pKGRlc3RpbmF0aW9uLCB7XG4gICAgICAgICAgICAgICAgZnRwOiB0aGlzLmZ0cCxcbiAgICAgICAgICAgICAgICB0cmFja2VyOiB0aGlzLl9wcm9ncmVzc1RyYWNrZXIsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogc3RhcnRBdCA+IDAgPyBgUkVTVCAke3N0YXJ0QXR9YCA6IGBSRVRSICR7dmFsaWRQYXRofWAsXG4gICAgICAgICAgICAgICAgcmVtb3RlUGF0aDogdmFsaWRQYXRoLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZG93bmxvYWRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBmaWxlcyBhbmQgZGlyZWN0b3JpZXMgaW4gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnksIG9yIGZyb20gYHBhdGhgIGlmIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBbcGF0aF0gIFBhdGggdG8gcmVtb3RlIGZpbGUgb3IgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3QocGF0aCA9IFwiXCIpIHtcbiAgICAgICAgY29uc3QgdmFsaWRQYXRoID0gYXdhaXQgdGhpcy5wcm90ZWN0V2hpdGVzcGFjZShwYXRoKTtcbiAgICAgICAgbGV0IGxhc3RFcnJvcjtcbiAgICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgdGhpcy5hdmFpbGFibGVMaXN0Q29tbWFuZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1hbmQgPSB2YWxpZFBhdGggPT09IFwiXCIgPyBjYW5kaWRhdGUgOiBgJHtjYW5kaWRhdGV9ICR7dmFsaWRQYXRofWA7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnByZXBhcmVUcmFuc2Zlcih0aGlzLmZ0cCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZExpc3QgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0TGlzdFdpdGhDb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgIC8vIFVzZSBzdWNjZXNzZnVsIGNhbmRpZGF0ZSBmb3IgYWxsIHN1YnNlcXVlbnQgcmVxdWVzdHMuXG4gICAgICAgICAgICAgICAgdGhpcy5hdmFpbGFibGVMaXN0Q29tbWFuZHMgPSBbY2FuZGlkYXRlXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkTGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRUcnlOZXh0ID0gZXJyIGluc3RhbmNlb2YgRnRwQ29udGV4dF8xLkZUUEVycm9yO1xuICAgICAgICAgICAgICAgIGlmICghc2hvdWxkVHJ5TmV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RFcnJvciA9IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBsYXN0RXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBfcmVxdWVzdExpc3RXaXRoQ29tbWFuZChjb21tYW5kKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBTdHJpbmdXcml0ZXJfMS5TdHJpbmdXcml0ZXIoKTtcbiAgICAgICAgYXdhaXQgKDAsIHRyYW5zZmVyXzEuZG93bmxvYWRUbykoYnVmZmVyLCB7XG4gICAgICAgICAgICBmdHA6IHRoaXMuZnRwLFxuICAgICAgICAgICAgdHJhY2tlcjogdGhpcy5fcHJvZ3Jlc3NUcmFja2VyLFxuICAgICAgICAgICAgY29tbWFuZCxcbiAgICAgICAgICAgIHJlbW90ZVBhdGg6IFwiXCIsXG4gICAgICAgICAgICB0eXBlOiBcImxpc3RcIlxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdGV4dCA9IGJ1ZmZlci5nZXRUZXh0KHRoaXMuZnRwLmVuY29kaW5nKTtcbiAgICAgICAgdGhpcy5mdHAubG9nKHRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpc3QodGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGRpcmVjdG9yeSBhbmQgYWxsIG9mIGl0cyBjb250ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbW90ZURpclBhdGggIFRoZSBwYXRoIG9mIHRoZSByZW1vdGUgZGlyZWN0b3J5IHRvIGRlbGV0ZS5cbiAgICAgKiBAZXhhbXBsZSBjbGllbnQucmVtb3ZlRGlyKFwiZm9vXCIpIC8vIFJlbW92ZSBkaXJlY3RvcnkgJ2ZvbycgdXNpbmcgYSByZWxhdGl2ZSBwYXRoLlxuICAgICAqIEBleGFtcGxlIGNsaWVudC5yZW1vdmVEaXIoXCJmb28vYmFyXCIpIC8vIFJlbW92ZSBkaXJlY3RvcnkgJ2JhcicgdXNpbmcgYSByZWxhdGl2ZSBwYXRoLlxuICAgICAqIEBleGFtcGxlIGNsaWVudC5yZW1vdmVEaXIoXCIvZm9vL2JhclwiKSAvLyBSZW1vdmUgZGlyZWN0b3J5ICdiYXInIHVzaW5nIGFuIGFic29sdXRlIHBhdGguXG4gICAgICogQGV4YW1wbGUgY2xpZW50LnJlbW92ZURpcihcIi9cIikgLy8gUmVtb3ZlIGV2ZXJ5dGhpbmcuXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlRGlyKHJlbW90ZURpclBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4aXRBdEN1cnJlbnREaXJlY3RvcnkoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jZChyZW1vdGVEaXJQYXRoKTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgYWJzb2x1dGUgcGF0aCBvZiB0aGUgdGFyZ2V0IGJlY2F1c2UgcmVtb3RlRGlyUGF0aCBtaWdodCBiZSBhIHJlbGF0aXZlIHBhdGgsIGV2ZW4gYC4uL2AgaXMgcG9zc2libGUuXG4gICAgICAgICAgICBjb25zdCBhYnNvbHV0ZURpclBhdGggPSBhd2FpdCB0aGlzLnB3ZCgpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGVhcldvcmtpbmdEaXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGRpcklzUm9vdCA9IGFic29sdXRlRGlyUGF0aCA9PT0gXCIvXCI7XG4gICAgICAgICAgICBpZiAoIWRpcklzUm9vdCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY2R1cCgpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVtb3ZlRW1wdHlEaXIoYWJzb2x1dGVEaXJQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgZmlsZXMgYW5kIGRpcmVjdG9yaWVzIGluIHRoZSB3b3JraW5nIGRpcmVjdG9yeSB3aXRob3V0IHJlbW92aW5nXG4gICAgICogdGhlIHdvcmtpbmcgZGlyZWN0b3J5IGl0c2VsZi5cbiAgICAgKi9cbiAgICBhc3luYyBjbGVhcldvcmtpbmdEaXIoKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBhd2FpdCB0aGlzLmxpc3QoKSkge1xuICAgICAgICAgICAgaWYgKGZpbGUuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNkKGZpbGUubmFtZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGVhcldvcmtpbmdEaXIoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNkdXAoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZUVtcHR5RGlyKGZpbGUubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZShmaWxlLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZCB0aGUgY29udGVudHMgb2YgYSBsb2NhbCBkaXJlY3RvcnkgdG8gdGhlIHJlbW90ZSB3b3JraW5nIGRpcmVjdG9yeS5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBvdmVyd3JpdGUgZXhpc3RpbmcgZmlsZXMgd2l0aCB0aGUgc2FtZSBuYW1lcyBhbmQgcmV1c2UgZXhpc3RpbmcgZGlyZWN0b3JpZXMuXG4gICAgICogVW5yZWxhdGVkIGZpbGVzIGFuZCBkaXJlY3RvcmllcyB3aWxsIHJlbWFpbiB1bnRvdWNoZWQuIFlvdSBjYW4gb3B0aW9uYWxseSBwcm92aWRlIGEgYHJlbW90ZURpclBhdGhgXG4gICAgICogdG8gcHV0IHRoZSBjb250ZW50cyBpbnNpZGUgYSBkaXJlY3Rvcnkgd2hpY2ggd2lsbCBiZSBjcmVhdGVkIGlmIG5lY2Vzc2FyeSBpbmNsdWRpbmcgYWxsXG4gICAgICogaW50ZXJtZWRpYXRlIGRpcmVjdG9yaWVzLiBJZiB5b3UgZGlkIHByb3ZpZGUgYSByZW1vdGVEaXJQYXRoIHRoZSB3b3JraW5nIGRpcmVjdG9yeSB3aWxsIHN0YXlcbiAgICAgKiB0aGUgc2FtZSBhcyBiZWZvcmUgY2FsbGluZyB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbERpclBhdGggIExvY2FsIHBhdGgsIGUuZy4gXCJmb28vYmFyXCIgb3IgXCIuLi90ZXN0XCJcbiAgICAgKiBAcGFyYW0gW3JlbW90ZURpclBhdGhdICBSZW1vdGUgcGF0aCBvZiBhIGRpcmVjdG9yeSB0byB1cGxvYWQgdG8uIFdvcmtpbmcgZGlyZWN0b3J5IGlmIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWRGcm9tRGlyKGxvY2FsRGlyUGF0aCwgcmVtb3RlRGlyUGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhpdEF0Q3VycmVudERpcmVjdG9yeShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVtb3RlRGlyUGF0aCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlRGlyKHJlbW90ZURpclBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VwbG9hZFRvV29ya2luZ0Rpcihsb2NhbERpclBhdGgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIF91cGxvYWRUb1dvcmtpbmdEaXIobG9jYWxEaXJQYXRoKSB7XG4gICAgICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgZnNSZWFkRGlyKGxvY2FsRGlyUGF0aCk7XG4gICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICAgICAgY29uc3QgZnVsbFBhdGggPSAoMCwgcGF0aF8xLmpvaW4pKGxvY2FsRGlyUGF0aCwgZmlsZSk7XG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGZzU3RhdChmdWxsUGF0aCk7XG4gICAgICAgICAgICBpZiAoc3RhdHMuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnVwbG9hZEZyb20oZnVsbFBhdGgsIGZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX29wZW5EaXIoZmlsZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBsb2FkVG9Xb3JraW5nRGlyKGZ1bGxQYXRoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNkdXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCBhbGwgZmlsZXMgYW5kIGRpcmVjdG9yaWVzIG9mIHRoZSB3b3JraW5nIGRpcmVjdG9yeSB0byBhIGxvY2FsIGRpcmVjdG9yeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbERpclBhdGggIFRoZSBsb2NhbCBkaXJlY3RvcnkgdG8gZG93bmxvYWQgdG8uXG4gICAgICogQHBhcmFtIHJlbW90ZURpclBhdGggIFJlbW90ZSBkaXJlY3RvcnkgdG8gZG93bmxvYWQuIEN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkgaWYgbm90IHNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyBkb3dubG9hZFRvRGlyKGxvY2FsRGlyUGF0aCwgcmVtb3RlRGlyUGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhpdEF0Q3VycmVudERpcmVjdG9yeShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVtb3RlRGlyUGF0aCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY2QocmVtb3RlRGlyUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fZG93bmxvYWRGcm9tV29ya2luZ0Rpcihsb2NhbERpclBhdGgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIF9kb3dubG9hZEZyb21Xb3JraW5nRGlyKGxvY2FsRGlyUGF0aCkge1xuICAgICAgICBhd2FpdCBlbnN1cmVMb2NhbERpcmVjdG9yeShsb2NhbERpclBhdGgpO1xuICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgYXdhaXQgdGhpcy5saXN0KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsUGF0aCA9ICgwLCBwYXRoXzEuam9pbikobG9jYWxEaXJQYXRoLCBmaWxlLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGZpbGUuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNkKGZpbGUubmFtZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fZG93bmxvYWRGcm9tV29ya2luZ0Rpcihsb2NhbFBhdGgpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY2R1cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmlsZS5pc0ZpbGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRvd25sb2FkVG8obG9jYWxQYXRoLCBmaWxlLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2Ugc3VyZSBhIGdpdmVuIHJlbW90ZSBwYXRoIGV4aXN0cywgY3JlYXRpbmcgYWxsIGRpcmVjdG9yaWVzIGFzIG5lY2Vzc2FyeS5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFsc28gY2hhbmdlcyB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSB0byB0aGUgZ2l2ZW4gcGF0aC5cbiAgICAgKi9cbiAgICBhc3luYyBlbnN1cmVEaXIocmVtb3RlRGlyUGF0aCkge1xuICAgICAgICAvLyBJZiB0aGUgcmVtb3RlRGlyUGF0aCB3YXMgYWJzb2x1dGUgZ28gdG8gcm9vdCBkaXJlY3RvcnkuXG4gICAgICAgIGlmIChyZW1vdGVEaXJQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNkKFwiL1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lcyA9IHJlbW90ZURpclBhdGguc3BsaXQoXCIvXCIpLmZpbHRlcihuYW1lID0+IG5hbWUgIT09IFwiXCIpO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX29wZW5EaXIobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ5IHRvIGNyZWF0ZSBhIGRpcmVjdG9yeSBhbmQgZW50ZXIgaXQuIFRoaXMgd2lsbCBub3QgcmFpc2UgYW4gZXhjZXB0aW9uIGlmIHRoZSBkaXJlY3RvcnlcbiAgICAgKiBjb3VsZG4ndCBiZSBjcmVhdGVkIGlmIGZvciBleGFtcGxlIGl0IGFscmVhZHkgZXhpc3RzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBfb3BlbkRpcihkaXJOYW1lKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZElnbm9yaW5nRXJyb3IoXCJNS0QgXCIgKyBkaXJOYW1lKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jZChkaXJOYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGVtcHR5IGRpcmVjdG9yeSwgd2lsbCBmYWlsIGlmIG5vdCBlbXB0eS5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVFbXB0eURpcihwYXRoKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkUGF0aCA9IGF3YWl0IHRoaXMucHJvdGVjdFdoaXRlc3BhY2UocGF0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQoYFJNRCAke3ZhbGlkUGF0aH1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRlRQIHNlcnZlcnMgY2FuJ3QgaGFuZGxlIGZpbGVuYW1lcyB0aGF0IGhhdmUgbGVhZGluZyB3aGl0ZXNwYWNlLiBUaGlzIG1ldGhvZCB0cmFuc2Zvcm1zXG4gICAgICogYSBnaXZlbiBwYXRoIHRvIGZpeCB0aGF0IGlzc3VlIGZvciBtb3N0IGNhc2VzLlxuICAgICAqL1xuICAgIGFzeW5jIHByb3RlY3RXaGl0ZXNwYWNlKHBhdGgpIHtcbiAgICAgICAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoXCIgXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgbGVhZGluZyB3aGl0ZXNwYWNlIGJ5IHByZXBlbmRpbmcgdGhlIGFic29sdXRlIHBhdGg6XG4gICAgICAgIC8vIFwiIHRlc3QudHh0XCIgd2hpbGUgYmVpbmcgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IGJlY29tZXMgXCIvIHRlc3QudHh0XCIuXG4gICAgICAgIGNvbnN0IHB3ZCA9IGF3YWl0IHRoaXMucHdkKCk7XG4gICAgICAgIGNvbnN0IGFic29sdXRlUGF0aFByZWZpeCA9IHB3ZC5lbmRzV2l0aChcIi9cIikgPyBwd2QgOiBwd2QgKyBcIi9cIjtcbiAgICAgICAgcmV0dXJuIGFic29sdXRlUGF0aFByZWZpeCArIHBhdGg7XG4gICAgfVxuICAgIGFzeW5jIF9leGl0QXRDdXJyZW50RGlyZWN0b3J5KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdXNlckRpciA9IGF3YWl0IHRoaXMucHdkKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZnVuYygpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGlnbm9yZUVycm9yKCgpID0+IHRoaXMuY2QodXNlckRpcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyeSBhbGwgYXZhaWxhYmxlIHRyYW5zZmVyIHN0cmF0ZWdpZXMgYW5kIHBpY2sgdGhlIGZpcnN0IG9uZSB0aGF0IHdvcmtzLiBVcGRhdGUgYGNsaWVudGAgdG9cbiAgICAgKiB1c2UgdGhlIHdvcmtpbmcgc3RyYXRlZ3kgZm9yIGFsbCBzdWNjZXNzaXZlIHRyYW5zZmVyIHJlcXVlc3RzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgdHJ5IHRoZSBwcm92aWRlZCBzdHJhdGVnaWVzLlxuICAgICAqL1xuICAgIF9lbnRlckZpcnN0Q29tcGF0aWJsZU1vZGUoc3RyYXRlZ2llcykge1xuICAgICAgICByZXR1cm4gYXN5bmMgKGZ0cCkgPT4ge1xuICAgICAgICAgICAgZnRwLmxvZyhcIlRyeWluZyB0byBmaW5kIG9wdGltYWwgdHJhbnNmZXIgc3RyYXRlZ3kuLi5cIik7XG4gICAgICAgICAgICBsZXQgbGFzdEVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzdHJhdGVneSBvZiBzdHJhdGVnaWVzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgc3RyYXRlZ3koZnRwKTtcbiAgICAgICAgICAgICAgICAgICAgZnRwLmxvZyhcIk9wdGltYWwgdHJhbnNmZXIgc3RyYXRlZ3kgZm91bmQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXBhcmVUcmFuc2ZlciA9IHN0cmF0ZWd5O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0aGUgbmV4dCBjYW5kaWRhdGUgbm8gbWF0dGVyIHRoZSBleGFjdCBlcnJvci4gSXQncyBwb3NzaWJsZSB0aGF0IGEgc2VydmVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuc3dlcmVkIGluY29ycmVjdGx5IHRvIGEgc3RyYXRlZ3ksIGZvciBleGFtcGxlIGEgUEFTViBhbnN3ZXIgdG8gYW4gRVBTVi5cbiAgICAgICAgICAgICAgICAgICAgbGFzdEVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9uZSBvZiB0aGUgYXZhaWxhYmxlIHRyYW5zZmVyIHN0cmF0ZWdpZXMgd29yay4gTGFzdCBlcnJvciByZXNwb25zZSB3YXMgJyR7bGFzdEVycm9yfScuYCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERFUFJFQ0FURUQsIHVzZSBgdXBsb2FkRnJvbWAuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWQoc291cmNlLCB0b1JlbW90ZVBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLmZ0cC5sb2coXCJXYXJuaW5nOiB1cGxvYWQoKSBoYXMgYmVlbiBkZXByZWNhdGVkLCB1c2UgdXBsb2FkRnJvbSgpLlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBsb2FkRnJvbShzb3VyY2UsIHRvUmVtb3RlUGF0aCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERFUFJFQ0FURUQsIHVzZSBgYXBwZW5kRnJvbWAuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBhcHBlbmQoc291cmNlLCB0b1JlbW90ZVBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLmZ0cC5sb2coXCJXYXJuaW5nOiBhcHBlbmQoKSBoYXMgYmVlbiBkZXByZWNhdGVkLCB1c2UgYXBwZW5kRnJvbSgpLlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kRnJvbShzb3VyY2UsIHRvUmVtb3RlUGF0aCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERFUFJFQ0FURUQsIHVzZSBgZG93bmxvYWRUb2AuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBkb3dubG9hZChkZXN0aW5hdGlvbiwgZnJvbVJlbW90ZVBhdGgsIHN0YXJ0QXQgPSAwKSB7XG4gICAgICAgIHRoaXMuZnRwLmxvZyhcIldhcm5pbmc6IGRvd25sb2FkKCkgaGFzIGJlZW4gZGVwcmVjYXRlZCwgdXNlIGRvd25sb2FkVG8oKS5cIik7XG4gICAgICAgIHJldHVybiB0aGlzLmRvd25sb2FkVG8oZGVzdGluYXRpb24sIGZyb21SZW1vdGVQYXRoLCBzdGFydEF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogREVQUkVDQVRFRCwgdXNlIGB1cGxvYWRGcm9tRGlyYC5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGFzeW5jIHVwbG9hZERpcihsb2NhbERpclBhdGgsIHJlbW90ZURpclBhdGgpIHtcbiAgICAgICAgdGhpcy5mdHAubG9nKFwiV2FybmluZzogdXBsb2FkRGlyKCkgaGFzIGJlZW4gZGVwcmVjYXRlZCwgdXNlIHVwbG9hZEZyb21EaXIoKS5cIik7XG4gICAgICAgIHJldHVybiB0aGlzLnVwbG9hZEZyb21EaXIobG9jYWxEaXJQYXRoLCByZW1vdGVEaXJQYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogREVQUkVDQVRFRCwgdXNlIGBkb3dubG9hZFRvRGlyYC5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGFzeW5jIGRvd25sb2FkRGlyKGxvY2FsRGlyUGF0aCkge1xuICAgICAgICB0aGlzLmZ0cC5sb2coXCJXYXJuaW5nOiBkb3dubG9hZERpcigpIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHVzZSBkb3dubG9hZFRvRGlyKCkuXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5kb3dubG9hZFRvRGlyKGxvY2FsRGlyUGF0aCk7XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnQgPSBDbGllbnQ7XG5hc3luYyBmdW5jdGlvbiBlbnN1cmVMb2NhbERpcmVjdG9yeShwYXRoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZnNTdGF0KHBhdGgpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgYXdhaXQgZnNNa0RpcihwYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBpZ25vcmVFcnJvcihmdW5jKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGZ1bmMoKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIC8vIElnbm9yZVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNsaWVudCIsImZzXzEiLCJyZXF1aXJlIiwicGF0aF8xIiwidGxzXzEiLCJ1dGlsXzEiLCJGdHBDb250ZXh0XzEiLCJwYXJzZUxpc3RfMSIsIlByb2dyZXNzVHJhY2tlcl8xIiwiU3RyaW5nV3JpdGVyXzEiLCJwYXJzZUxpc3RNTFNEXzEiLCJuZXRVdGlsc18xIiwidHJhbnNmZXJfMSIsInBhcnNlQ29udHJvbFJlc3BvbnNlXzEiLCJmc1JlYWREaXIiLCJwcm9taXNpZnkiLCJyZWFkZGlyIiwiZnNNa0RpciIsIm1rZGlyIiwiZnNTdGF0Iiwic3RhdCIsImZzT3BlbiIsIm9wZW4iLCJmc0Nsb3NlIiwiY2xvc2UiLCJmc1VubGluayIsInVubGluayIsImRlZmF1bHRDbGllbnRPcHRpb25zIiwiYWxsb3dTZXBhcmF0ZVRyYW5zZmVySG9zdCIsIkxJU1RfQ09NTUFORFNfREVGQVVMVCIsIkxJU1RfQ09NTUFORFNfTUxTRCIsImNvbnN0cnVjdG9yIiwidGltZW91dCIsIm9wdGlvbnMiLCJhdmFpbGFibGVMaXN0Q29tbWFuZHMiLCJmdHAiLCJGVFBDb250ZXh0IiwicHJlcGFyZVRyYW5zZmVyIiwiX2VudGVyRmlyc3RDb21wYXRpYmxlTW9kZSIsImVudGVyUGFzc2l2ZU1vZGVJUHY2IiwiZW50ZXJQYXNzaXZlTW9kZUlQdjQiLCJlbnRlclBhc3NpdmVNb2RlSVB2NF9mb3JjZUNvbnRyb2xIb3N0SVAiLCJwYXJzZUxpc3QiLCJfcHJvZ3Jlc3NUcmFja2VyIiwiUHJvZ3Jlc3NUcmFja2VyIiwic3RvcCIsImNsb3NlZCIsImNvbm5lY3QiLCJob3N0IiwicG9ydCIsInJlc2V0Iiwic29ja2V0IiwiZmFtaWx5IiwiaXBGYW1pbHkiLCJsb2ciLCJkZXNjcmliZUFkZHJlc3MiLCJkZXNjcmliZVRMUyIsIl9oYW5kbGVDb25uZWN0UmVzcG9uc2UiLCJjb25uZWN0SW1wbGljaXRUTFMiLCJ0bHNPcHRpb25zIiwiaGFuZGxlIiwidW5kZWZpbmVkIiwicmVzIiwidGFzayIsIkVycm9yIiwicmVqZWN0IiwicG9zaXRpdmVDb21wbGV0aW9uIiwiY29kZSIsInJlc29sdmUiLCJGVFBFcnJvciIsInNlbmQiLCJjb21tYW5kIiwiaWdub3JlRXJyb3JDb2Rlc0RFUFJFQ0FURUQiLCJzZW5kSWdub3JpbmdFcnJvciIsInJlcXVlc3QiLCJtZXNzYWdlIiwidXNlVExTIiwicmV0IiwidXBncmFkZVNvY2tldCIsImxvZ2luIiwidXNlciIsInBhc3N3b3JkIiwidXNlRGVmYXVsdFNldHRpbmdzIiwiZmVhdHVyZXMiLCJzdXBwb3J0c01MU0QiLCJoYXMiLCJoYXNUTFMiLCJhY2Nlc3MiLCJfYSIsIl9iIiwidXNlRXhwbGljaXRUTFMiLCJzZWN1cmUiLCJ1c2VJbXBsaWNpdFRMUyIsIndlbGNvbWUiLCJzZWN1cmVPcHRpb25zIiwicHdkIiwicGFyc2VkIiwibWF0Y2giLCJNYXAiLCJpc011bHRpbGluZSIsInNwbGl0Iiwic2xpY2UiLCJmb3JFYWNoIiwibGluZSIsImVudHJ5IiwidHJpbSIsInNldCIsImNkIiwicGF0aCIsInZhbGlkUGF0aCIsInByb3RlY3RXaGl0ZXNwYWNlIiwiY2R1cCIsImxhc3RNb2QiLCJkYXRlIiwicGFyc2VNTFN4RGF0ZSIsInNpemUiLCJwYXJzZUludCIsIk51bWJlciIsImlzTmFOIiwicmVuYW1lIiwic3JjUGF0aCIsImRlc3RQYXRoIiwidmFsaWRTcmMiLCJ2YWxpZERlc3QiLCJyZW1vdmUiLCJpZ25vcmVFcnJvckNvZGVzIiwidHJhY2tQcm9ncmVzcyIsImhhbmRsZXIiLCJieXRlc092ZXJhbGwiLCJyZXBvcnRUbyIsInVwbG9hZEZyb20iLCJzb3VyY2UiLCJ0b1JlbW90ZVBhdGgiLCJfdXBsb2FkV2l0aENvbW1hbmQiLCJhcHBlbmRGcm9tIiwicmVtb3RlUGF0aCIsIl91cGxvYWRMb2NhbEZpbGUiLCJfdXBsb2FkRnJvbVN0cmVhbSIsImxvY2FsUGF0aCIsImZkIiwiY3JlYXRlUmVhZFN0cmVhbSIsInN0YXJ0IiwibG9jYWxTdGFydCIsImVuZCIsImxvY2FsRW5kSW5jbHVzaXZlIiwiYXV0b0Nsb3NlIiwiaWdub3JlRXJyb3IiLCJvbkVycm9yIiwiZXJyIiwiY2xvc2VXaXRoRXJyb3IiLCJvbmNlIiwidHJhY2tlciIsInR5cGUiLCJyZW1vdmVMaXN0ZW5lciIsImRvd25sb2FkVG8iLCJkZXN0aW5hdGlvbiIsImZyb21SZW1vdGVQYXRoIiwic3RhcnRBdCIsIl9kb3dubG9hZFRvRmlsZSIsIl9kb3dubG9hZFRvU3RyZWFtIiwiYXBwZW5kaW5nVG9Mb2NhbEZpbGUiLCJmaWxlU3lzdGVtRmxhZ3MiLCJjcmVhdGVXcml0ZVN0cmVhbSIsImxvY2FsRmlsZVN0YXRzIiwiaGFzRG93bmxvYWRlZERhdGEiLCJzaG91bGRSZW1vdmVMb2NhbEZpbGUiLCJsaXN0IiwibGFzdEVycm9yIiwiY2FuZGlkYXRlIiwicGFyc2VkTGlzdCIsIl9yZXF1ZXN0TGlzdFdpdGhDb21tYW5kIiwic2hvdWxkVHJ5TmV4dCIsImJ1ZmZlciIsIlN0cmluZ1dyaXRlciIsInRleHQiLCJnZXRUZXh0IiwiZW5jb2RpbmciLCJyZW1vdmVEaXIiLCJyZW1vdGVEaXJQYXRoIiwiX2V4aXRBdEN1cnJlbnREaXJlY3RvcnkiLCJhYnNvbHV0ZURpclBhdGgiLCJjbGVhcldvcmtpbmdEaXIiLCJkaXJJc1Jvb3QiLCJyZW1vdmVFbXB0eURpciIsImZpbGUiLCJpc0RpcmVjdG9yeSIsIm5hbWUiLCJ1cGxvYWRGcm9tRGlyIiwibG9jYWxEaXJQYXRoIiwiZW5zdXJlRGlyIiwiX3VwbG9hZFRvV29ya2luZ0RpciIsImZpbGVzIiwiZnVsbFBhdGgiLCJqb2luIiwic3RhdHMiLCJpc0ZpbGUiLCJfb3BlbkRpciIsImRvd25sb2FkVG9EaXIiLCJfZG93bmxvYWRGcm9tV29ya2luZ0RpciIsImVuc3VyZUxvY2FsRGlyZWN0b3J5Iiwic3RhcnRzV2l0aCIsIm5hbWVzIiwiZmlsdGVyIiwiZGlyTmFtZSIsImFic29sdXRlUGF0aFByZWZpeCIsImVuZHNXaXRoIiwiZnVuYyIsInVzZXJEaXIiLCJzdHJhdGVnaWVzIiwic3RyYXRlZ3kiLCJ1cGxvYWQiLCJhcHBlbmQiLCJkb3dubG9hZCIsInVwbG9hZERpciIsImRvd25sb2FkRGlyIiwicmVjdXJzaXZlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/basic-ftp/dist/Client.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/basic-ftp/dist/FileInfo.js":
/*!*****************************************************!*\
  !*** ../../node_modules/basic-ftp/dist/FileInfo.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FileInfo = exports.FileType = void 0;\nvar FileType;\n(function(FileType) {\n    FileType[FileType[\"Unknown\"] = 0] = \"Unknown\";\n    FileType[FileType[\"File\"] = 1] = \"File\";\n    FileType[FileType[\"Directory\"] = 2] = \"Directory\";\n    FileType[FileType[\"SymbolicLink\"] = 3] = \"SymbolicLink\";\n})(FileType || (exports.FileType = FileType = {}));\n/**\n * Describes a file, directory or symbolic link.\n */ class FileInfo {\n    constructor(name){\n        this.name = name;\n        this.type = FileType.Unknown;\n        this.size = 0;\n        /**\n         * Unparsed, raw modification date as a string.\n         *\n         * If `modifiedAt` is undefined, the FTP server you're connected to doesn't support the more modern\n         * MLSD command for machine-readable directory listings. The older command LIST is then used returning\n         * results that vary a lot between servers as the format hasn't been standardized. Here, directory listings\n         * and especially modification dates were meant to be human-readable first.\n         *\n         * Be careful when still trying to parse this by yourself. Parsing dates from listings using LIST is\n         * unreliable. This library decides to offer parsed dates only when they're absolutely reliable and safe to\n         * use e.g. for comparisons.\n         */ this.rawModifiedAt = \"\";\n        /**\n         * Parsed modification date.\n         *\n         * Available if the FTP server supports the MLSD command. Only MLSD guarantees dates than can be reliably\n         * parsed with the correct timezone and a resolution down to seconds. See `rawModifiedAt` property for the unparsed\n         * date that is always available.\n         */ this.modifiedAt = undefined;\n        /**\n         * Unix permissions if present. If the underlying FTP server is not running on Unix this will be undefined.\n         * If set, you might be able to edit permissions with the FTP command `SITE CHMOD`.\n         */ this.permissions = undefined;\n        /**\n         * Hard link count if available.\n         */ this.hardLinkCount = undefined;\n        /**\n         * Link name for symbolic links if available.\n         */ this.link = undefined;\n        /**\n         * Unix group if available.\n         */ this.group = undefined;\n        /**\n         * Unix user if available.\n         */ this.user = undefined;\n        /**\n         * Unique ID if available.\n         */ this.uniqueID = undefined;\n        this.name = name;\n    }\n    get isDirectory() {\n        return this.type === FileType.Directory;\n    }\n    get isSymbolicLink() {\n        return this.type === FileType.SymbolicLink;\n    }\n    get isFile() {\n        return this.type === FileType.File;\n    }\n    /**\n     * Deprecated, legacy API. Use `rawModifiedAt` instead.\n     * @deprecated\n     */ get date() {\n        return this.rawModifiedAt;\n    }\n    set date(rawModifiedAt) {\n        this.rawModifiedAt = rawModifiedAt;\n    }\n}\nexports.FileInfo = FileInfo;\nFileInfo.UnixPermission = {\n    Read: 4,\n    Write: 2,\n    Execute: 1\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2ljLWZ0cC9kaXN0L0ZpbGVJbmZvLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUcsS0FBSztBQUMzQyxJQUFJRztBQUNILFVBQVVBLFFBQVE7SUFDZkEsUUFBUSxDQUFDQSxRQUFRLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUNwQ0EsUUFBUSxDQUFDQSxRQUFRLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUNqQ0EsUUFBUSxDQUFDQSxRQUFRLENBQUMsWUFBWSxHQUFHLEVBQUUsR0FBRztJQUN0Q0EsUUFBUSxDQUFDQSxRQUFRLENBQUMsZUFBZSxHQUFHLEVBQUUsR0FBRztBQUM3QyxHQUFHQSxZQUFhSCxDQUFBQSxnQkFBZ0IsR0FBR0csV0FBVyxDQUFDO0FBQy9DOztDQUVDLEdBQ0QsTUFBTUQ7SUFDRkUsWUFBWUMsSUFBSSxDQUFFO1FBQ2QsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxJQUFJLEdBQUdILFNBQVNJLE9BQU87UUFDNUIsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWjs7Ozs7Ozs7Ozs7U0FXQyxHQUNELElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCOzs7Ozs7U0FNQyxHQUNELElBQUksQ0FBQ0MsVUFBVSxHQUFHQztRQUNsQjs7O1NBR0MsR0FDRCxJQUFJLENBQUNDLFdBQVcsR0FBR0Q7UUFDbkI7O1NBRUMsR0FDRCxJQUFJLENBQUNFLGFBQWEsR0FBR0Y7UUFDckI7O1NBRUMsR0FDRCxJQUFJLENBQUNHLElBQUksR0FBR0g7UUFDWjs7U0FFQyxHQUNELElBQUksQ0FBQ0ksS0FBSyxHQUFHSjtRQUNiOztTQUVDLEdBQ0QsSUFBSSxDQUFDSyxJQUFJLEdBQUdMO1FBQ1o7O1NBRUMsR0FDRCxJQUFJLENBQUNNLFFBQVEsR0FBR047UUFDaEIsSUFBSSxDQUFDTixJQUFJLEdBQUdBO0lBQ2hCO0lBQ0EsSUFBSWEsY0FBYztRQUNkLE9BQU8sSUFBSSxDQUFDWixJQUFJLEtBQUtILFNBQVNnQixTQUFTO0lBQzNDO0lBQ0EsSUFBSUMsaUJBQWlCO1FBQ2pCLE9BQU8sSUFBSSxDQUFDZCxJQUFJLEtBQUtILFNBQVNrQixZQUFZO0lBQzlDO0lBQ0EsSUFBSUMsU0FBUztRQUNULE9BQU8sSUFBSSxDQUFDaEIsSUFBSSxLQUFLSCxTQUFTb0IsSUFBSTtJQUN0QztJQUNBOzs7S0FHQyxHQUNELElBQUlDLE9BQU87UUFDUCxPQUFPLElBQUksQ0FBQ2YsYUFBYTtJQUM3QjtJQUNBLElBQUllLEtBQUtmLGFBQWEsRUFBRTtRQUNwQixJQUFJLENBQUNBLGFBQWEsR0FBR0E7SUFDekI7QUFDSjtBQUNBVCxnQkFBZ0IsR0FBR0U7QUFDbkJBLFNBQVN1QixjQUFjLEdBQUc7SUFDdEJDLE1BQU07SUFDTkMsT0FBTztJQUNQQyxTQUFTO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2ljLWZ0cC9kaXN0L0ZpbGVJbmZvLmpzP2ZlYzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZpbGVJbmZvID0gZXhwb3J0cy5GaWxlVHlwZSA9IHZvaWQgMDtcbnZhciBGaWxlVHlwZTtcbihmdW5jdGlvbiAoRmlsZVR5cGUpIHtcbiAgICBGaWxlVHlwZVtGaWxlVHlwZVtcIlVua25vd25cIl0gPSAwXSA9IFwiVW5rbm93blwiO1xuICAgIEZpbGVUeXBlW0ZpbGVUeXBlW1wiRmlsZVwiXSA9IDFdID0gXCJGaWxlXCI7XG4gICAgRmlsZVR5cGVbRmlsZVR5cGVbXCJEaXJlY3RvcnlcIl0gPSAyXSA9IFwiRGlyZWN0b3J5XCI7XG4gICAgRmlsZVR5cGVbRmlsZVR5cGVbXCJTeW1ib2xpY0xpbmtcIl0gPSAzXSA9IFwiU3ltYm9saWNMaW5rXCI7XG59KShGaWxlVHlwZSB8fCAoZXhwb3J0cy5GaWxlVHlwZSA9IEZpbGVUeXBlID0ge30pKTtcbi8qKlxuICogRGVzY3JpYmVzIGEgZmlsZSwgZGlyZWN0b3J5IG9yIHN5bWJvbGljIGxpbmsuXG4gKi9cbmNsYXNzIEZpbGVJbmZvIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudHlwZSA9IEZpbGVUeXBlLlVua25vd247XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnBhcnNlZCwgcmF3IG1vZGlmaWNhdGlvbiBkYXRlIGFzIGEgc3RyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgbW9kaWZpZWRBdGAgaXMgdW5kZWZpbmVkLCB0aGUgRlRQIHNlcnZlciB5b3UncmUgY29ubmVjdGVkIHRvIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgbW9yZSBtb2Rlcm5cbiAgICAgICAgICogTUxTRCBjb21tYW5kIGZvciBtYWNoaW5lLXJlYWRhYmxlIGRpcmVjdG9yeSBsaXN0aW5ncy4gVGhlIG9sZGVyIGNvbW1hbmQgTElTVCBpcyB0aGVuIHVzZWQgcmV0dXJuaW5nXG4gICAgICAgICAqIHJlc3VsdHMgdGhhdCB2YXJ5IGEgbG90IGJldHdlZW4gc2VydmVycyBhcyB0aGUgZm9ybWF0IGhhc24ndCBiZWVuIHN0YW5kYXJkaXplZC4gSGVyZSwgZGlyZWN0b3J5IGxpc3RpbmdzXG4gICAgICAgICAqIGFuZCBlc3BlY2lhbGx5IG1vZGlmaWNhdGlvbiBkYXRlcyB3ZXJlIG1lYW50IHRvIGJlIGh1bWFuLXJlYWRhYmxlIGZpcnN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBCZSBjYXJlZnVsIHdoZW4gc3RpbGwgdHJ5aW5nIHRvIHBhcnNlIHRoaXMgYnkgeW91cnNlbGYuIFBhcnNpbmcgZGF0ZXMgZnJvbSBsaXN0aW5ncyB1c2luZyBMSVNUIGlzXG4gICAgICAgICAqIHVucmVsaWFibGUuIFRoaXMgbGlicmFyeSBkZWNpZGVzIHRvIG9mZmVyIHBhcnNlZCBkYXRlcyBvbmx5IHdoZW4gdGhleSdyZSBhYnNvbHV0ZWx5IHJlbGlhYmxlIGFuZCBzYWZlIHRvXG4gICAgICAgICAqIHVzZSBlLmcuIGZvciBjb21wYXJpc29ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmF3TW9kaWZpZWRBdCA9IFwiXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZWQgbW9kaWZpY2F0aW9uIGRhdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEF2YWlsYWJsZSBpZiB0aGUgRlRQIHNlcnZlciBzdXBwb3J0cyB0aGUgTUxTRCBjb21tYW5kLiBPbmx5IE1MU0QgZ3VhcmFudGVlcyBkYXRlcyB0aGFuIGNhbiBiZSByZWxpYWJseVxuICAgICAgICAgKiBwYXJzZWQgd2l0aCB0aGUgY29ycmVjdCB0aW1lem9uZSBhbmQgYSByZXNvbHV0aW9uIGRvd24gdG8gc2Vjb25kcy4gU2VlIGByYXdNb2RpZmllZEF0YCBwcm9wZXJ0eSBmb3IgdGhlIHVucGFyc2VkXG4gICAgICAgICAqIGRhdGUgdGhhdCBpcyBhbHdheXMgYXZhaWxhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb2RpZmllZEF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5peCBwZXJtaXNzaW9ucyBpZiBwcmVzZW50LiBJZiB0aGUgdW5kZXJseWluZyBGVFAgc2VydmVyIGlzIG5vdCBydW5uaW5nIG9uIFVuaXggdGhpcyB3aWxsIGJlIHVuZGVmaW5lZC5cbiAgICAgICAgICogSWYgc2V0LCB5b3UgbWlnaHQgYmUgYWJsZSB0byBlZGl0IHBlcm1pc3Npb25zIHdpdGggdGhlIEZUUCBjb21tYW5kIGBTSVRFIENITU9EYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVybWlzc2lvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYXJkIGxpbmsgY291bnQgaWYgYXZhaWxhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXJkTGlua0NvdW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGluayBuYW1lIGZvciBzeW1ib2xpYyBsaW5rcyBpZiBhdmFpbGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmsgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbml4IGdyb3VwIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JvdXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbml4IHVzZXIgaWYgYXZhaWxhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51c2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5pcXVlIElEIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5pcXVlSUQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIGdldCBpc0RpcmVjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gRmlsZVR5cGUuRGlyZWN0b3J5O1xuICAgIH1cbiAgICBnZXQgaXNTeW1ib2xpY0xpbmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IEZpbGVUeXBlLlN5bWJvbGljTGluaztcbiAgICB9XG4gICAgZ2V0IGlzRmlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gRmlsZVR5cGUuRmlsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwcmVjYXRlZCwgbGVnYWN5IEFQSS4gVXNlIGByYXdNb2RpZmllZEF0YCBpbnN0ZWFkLlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgZ2V0IGRhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhd01vZGlmaWVkQXQ7XG4gICAgfVxuICAgIHNldCBkYXRlKHJhd01vZGlmaWVkQXQpIHtcbiAgICAgICAgdGhpcy5yYXdNb2RpZmllZEF0ID0gcmF3TW9kaWZpZWRBdDtcbiAgICB9XG59XG5leHBvcnRzLkZpbGVJbmZvID0gRmlsZUluZm87XG5GaWxlSW5mby5Vbml4UGVybWlzc2lvbiA9IHtcbiAgICBSZWFkOiA0LFxuICAgIFdyaXRlOiAyLFxuICAgIEV4ZWN1dGU6IDFcbn07XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJGaWxlSW5mbyIsIkZpbGVUeXBlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwidHlwZSIsIlVua25vd24iLCJzaXplIiwicmF3TW9kaWZpZWRBdCIsIm1vZGlmaWVkQXQiLCJ1bmRlZmluZWQiLCJwZXJtaXNzaW9ucyIsImhhcmRMaW5rQ291bnQiLCJsaW5rIiwiZ3JvdXAiLCJ1c2VyIiwidW5pcXVlSUQiLCJpc0RpcmVjdG9yeSIsIkRpcmVjdG9yeSIsImlzU3ltYm9saWNMaW5rIiwiU3ltYm9saWNMaW5rIiwiaXNGaWxlIiwiRmlsZSIsImRhdGUiLCJVbml4UGVybWlzc2lvbiIsIlJlYWQiLCJXcml0ZSIsIkV4ZWN1dGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/basic-ftp/dist/FileInfo.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/basic-ftp/dist/FtpContext.js":
/*!*******************************************************!*\
  !*** ../../node_modules/basic-ftp/dist/FtpContext.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FTPContext = exports.FTPError = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst parseControlResponse_1 = __webpack_require__(/*! ./parseControlResponse */ \"(rsc)/../../node_modules/basic-ftp/dist/parseControlResponse.js\");\n/**\n * Describes an FTP server error response including the FTP response code.\n */ class FTPError extends Error {\n    constructor(res){\n        super(res.message);\n        this.name = this.constructor.name;\n        this.code = res.code;\n    }\n}\nexports.FTPError = FTPError;\nfunction doNothing() {\n/** Do nothing */ }\n/**\n * FTPContext holds the control and data sockets of an FTP connection and provides a\n * simplified way to interact with an FTP server, handle responses, errors and timeouts.\n *\n * It doesn't implement or use any FTP commands. It's only a foundation to make writing an FTP\n * client as easy as possible. You won't usually instantiate this, but use `Client`.\n */ class FTPContext {\n    /**\n     * Instantiate an FTP context.\n     *\n     * @param timeout - Timeout in milliseconds to apply to control and data connections. Use 0 for no timeout.\n     * @param encoding - Encoding to use for control connection. UTF-8 by default. Use \"latin1\" for older servers.\n     */ constructor(timeout = 0, encoding = \"utf8\"){\n        this.timeout = timeout;\n        /** Debug-level logging of all socket communication. */ this.verbose = false;\n        /** IP version to prefer (4: IPv4, 6: IPv6, undefined: automatic). */ this.ipFamily = undefined;\n        /** Options for TLS connections. */ this.tlsOptions = {};\n        /** A multiline response might be received as multiple chunks. */ this._partialResponse = \"\";\n        this._encoding = encoding;\n        // Help Typescript understand that we do indeed set _socket in the constructor but use the setter method to do so.\n        this._socket = this.socket = this._newSocket();\n        this._dataSocket = undefined;\n    }\n    /**\n     * Close the context.\n     */ close() {\n        // Internally, closing a context is always described with an error. If there is still a task running, it will\n        // abort with an exception that the user closed the client during a task. If no task is running, no exception is\n        // thrown but all newly submitted tasks after that will abort the exception that the client has been closed.\n        // In addition the user will get a stack trace pointing to where exactly the client has been closed. So in any\n        // case use _closingError to determine whether a context is closed. This also allows us to have a single code-path\n        // for closing a context making the implementation easier.\n        const message = this._task ? \"User closed client during task\" : \"User closed client\";\n        const err = new Error(message);\n        this.closeWithError(err);\n    }\n    /**\n     * Close the context with an error.\n     */ closeWithError(err) {\n        // If this context already has been closed, don't overwrite the reason.\n        if (this._closingError) {\n            return;\n        }\n        this._closingError = err;\n        // Close the sockets but don't fully reset this context to preserve `this._closingError`.\n        this._closeControlSocket();\n        this._closeSocket(this._dataSocket);\n        // Give the user's task a chance to react, maybe cleanup resources.\n        this._passToHandler(err);\n        // The task might not have been rejected by the user after receiving the error.\n        this._stopTrackingTask();\n    }\n    /**\n     * Returns true if this context has been closed or hasn't been connected yet. You can reopen it with `access`.\n     */ get closed() {\n        return this.socket.remoteAddress === undefined || this._closingError !== undefined;\n    }\n    /**\n     * Reset this contex and all of its state.\n     */ reset() {\n        this.socket = this._newSocket();\n    }\n    /**\n     * Get the FTP control socket.\n     */ get socket() {\n        return this._socket;\n    }\n    /**\n     * Set the socket for the control connection. This will only close the current control socket\n     * if the new one is not an upgrade to the current one.\n     */ set socket(socket) {\n        // No data socket should be open in any case where the control socket is set or upgraded.\n        this.dataSocket = undefined;\n        // This being a reset, reset any other state apart from the socket.\n        this.tlsOptions = {};\n        this._partialResponse = \"\";\n        if (this._socket) {\n            const newSocketUpgradesExisting = socket.localPort === this._socket.localPort;\n            if (newSocketUpgradesExisting) {\n                this._removeSocketListeners(this.socket);\n            } else {\n                this._closeControlSocket();\n            }\n        }\n        if (socket) {\n            // Setting a completely new control socket is in essence something like a reset. That's\n            // why we also close any open data connection above. We can go one step further and reset\n            // a possible closing error. That means that a closed FTPContext can be \"reopened\" by\n            // setting a new control socket.\n            this._closingError = undefined;\n            // Don't set a timeout yet. Timeout for control sockets is only active during a task, see handle() below.\n            socket.setTimeout(0);\n            socket.setEncoding(this._encoding);\n            socket.setKeepAlive(true);\n            socket.on(\"data\", (data)=>this._onControlSocketData(data));\n            // Server sending a FIN packet is treated as an error.\n            socket.on(\"end\", ()=>this.closeWithError(new Error(\"Server sent FIN packet unexpectedly, closing connection.\")));\n            // Control being closed without error by server is treated as an error.\n            socket.on(\"close\", (hadError)=>{\n                if (!hadError) this.closeWithError(new Error(\"Server closed connection unexpectedly.\"));\n            });\n            this._setupDefaultErrorHandlers(socket, \"control socket\");\n        }\n        this._socket = socket;\n    }\n    /**\n     * Get the current FTP data connection if present.\n     */ get dataSocket() {\n        return this._dataSocket;\n    }\n    /**\n     * Set the socket for the data connection. This will automatically close the former data socket.\n     */ set dataSocket(socket) {\n        this._closeSocket(this._dataSocket);\n        if (socket) {\n            // Don't set a timeout yet. Timeout data socket should be activated when data transmission starts\n            // and timeout on control socket is deactivated.\n            socket.setTimeout(0);\n            this._setupDefaultErrorHandlers(socket, \"data socket\");\n        }\n        this._dataSocket = socket;\n    }\n    /**\n     * Get the currently used encoding.\n     */ get encoding() {\n        return this._encoding;\n    }\n    /**\n     * Set the encoding used for the control socket.\n     *\n     * See https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings for what encodings\n     * are supported by Node.\n     */ set encoding(encoding) {\n        this._encoding = encoding;\n        if (this.socket) {\n            this.socket.setEncoding(encoding);\n        }\n    }\n    /**\n     * Send an FTP command without waiting for or handling the result.\n     */ send(command) {\n        const containsPassword = command.startsWith(\"PASS\");\n        const message = containsPassword ? \"> PASS ###\" : `> ${command}`;\n        this.log(message);\n        this._socket.write(command + \"\\r\\n\", this.encoding);\n    }\n    /**\n     * Send an FTP command and handle the first response. Use this if you have a simple\n     * request-response situation.\n     */ request(command) {\n        return this.handle(command, (res, task)=>{\n            if (res instanceof Error) {\n                task.reject(res);\n            } else {\n                task.resolve(res);\n            }\n        });\n    }\n    /**\n     * Send an FTP command and handle any response until you resolve/reject. Use this if you expect multiple responses\n     * to a request. This returns a Promise that will hold whatever the response handler passed on when resolving/rejecting its task.\n     */ handle(command, responseHandler) {\n        if (this._task) {\n            const err = new Error(\"User launched a task while another one is still running. Forgot to use 'await' or '.then()'?\");\n            err.stack += `\\nRunning task launched at: ${this._task.stack}`;\n            this.closeWithError(err);\n        // Don't return here, continue with returning the Promise that will then be rejected\n        // because the context closed already. That way, users will receive an exception where\n        // they called this method by mistake.\n        }\n        return new Promise((resolveTask, rejectTask)=>{\n            this._task = {\n                stack: new Error().stack || \"Unknown call stack\",\n                responseHandler,\n                resolver: {\n                    resolve: (arg)=>{\n                        this._stopTrackingTask();\n                        resolveTask(arg);\n                    },\n                    reject: (err)=>{\n                        this._stopTrackingTask();\n                        rejectTask(err);\n                    }\n                }\n            };\n            if (this._closingError) {\n                // This client has been closed. Provide an error that describes this one as being caused\n                // by `_closingError`, include stack traces for both.\n                const err = new Error(`Client is closed because ${this._closingError.message}`); // Type 'Error' is not correctly defined, doesn't have 'code'.\n                err.stack += `\\nClosing reason: ${this._closingError.stack}`;\n                err.code = this._closingError.code !== undefined ? this._closingError.code : \"0\";\n                this._passToHandler(err);\n                return;\n            }\n            // Only track control socket timeout during the lifecycle of a task. This avoids timeouts on idle sockets,\n            // the default socket behaviour which is not expected by most users.\n            this.socket.setTimeout(this.timeout);\n            if (command) {\n                this.send(command);\n            }\n        });\n    }\n    /**\n     * Log message if set to be verbose.\n     */ log(message) {\n        if (this.verbose) {\n            // tslint:disable-next-line no-console\n            console.log(message);\n        }\n    }\n    /**\n     * Return true if the control socket is using TLS. This does not mean that a session\n     * has already been negotiated.\n     */ get hasTLS() {\n        return \"encrypted\" in this._socket;\n    }\n    /**\n     * Removes reference to current task and handler. This won't resolve or reject the task.\n     * @protected\n     */ _stopTrackingTask() {\n        // Disable timeout on control socket if there is no task active.\n        this.socket.setTimeout(0);\n        this._task = undefined;\n    }\n    /**\n     * Handle incoming data on the control socket. The chunk is going to be of type `string`\n     * because we let `socket` handle encoding with `setEncoding`.\n     * @protected\n     */ _onControlSocketData(chunk) {\n        this.log(`< ${chunk}`);\n        // This chunk might complete an earlier partial response.\n        const completeResponse = this._partialResponse + chunk;\n        const parsed = (0, parseControlResponse_1.parseControlResponse)(completeResponse);\n        // Remember any incomplete remainder.\n        this._partialResponse = parsed.rest;\n        // Each response group is passed along individually.\n        for (const message of parsed.messages){\n            const code = parseInt(message.substr(0, 3), 10);\n            const response = {\n                code,\n                message\n            };\n            const err = code >= 400 ? new FTPError(response) : undefined;\n            this._passToHandler(err ? err : response);\n        }\n    }\n    /**\n     * Send the current handler a response. This is usually a control socket response\n     * or a socket event, like an error or timeout.\n     * @protected\n     */ _passToHandler(response) {\n        if (this._task) {\n            this._task.responseHandler(response, this._task.resolver);\n        }\n    // Errors other than FTPError always close the client. If there isn't an active task to handle the error,\n    // the next one submitted will receive it using `_closingError`.\n    // There is only one edge-case: If there is an FTPError while no task is active, the error will be dropped.\n    // But that means that the user sent an FTP command with no intention of handling the result. So why should the\n    // error be handled? Maybe log it at least? Debug logging will already do that and the client stays useable after\n    // FTPError. So maybe no need to do anything here.\n    }\n    /**\n     * Setup all error handlers for a socket.\n     * @protected\n     */ _setupDefaultErrorHandlers(socket, identifier) {\n        socket.once(\"error\", (error)=>{\n            error.message += ` (${identifier})`;\n            this.closeWithError(error);\n        });\n        socket.once(\"close\", (hadError)=>{\n            if (hadError) {\n                this.closeWithError(new Error(`Socket closed due to transmission error (${identifier})`));\n            }\n        });\n        socket.once(\"timeout\", ()=>{\n            socket.destroy();\n            this.closeWithError(new Error(`Timeout (${identifier})`));\n        });\n    }\n    /**\n     * Close the control socket. Sends QUIT, then FIN, and ignores any response or error.\n     */ _closeControlSocket() {\n        this._removeSocketListeners(this._socket);\n        this._socket.on(\"error\", doNothing);\n        this.send(\"QUIT\");\n        this._closeSocket(this._socket);\n    }\n    /**\n     * Close a socket, ignores any error.\n     * @protected\n     */ _closeSocket(socket) {\n        if (socket) {\n            this._removeSocketListeners(socket);\n            socket.on(\"error\", doNothing);\n            socket.destroy();\n        }\n    }\n    /**\n     * Remove all default listeners for socket.\n     * @protected\n     */ _removeSocketListeners(socket) {\n        socket.removeAllListeners();\n        // Before Node.js 10.3.0, using `socket.removeAllListeners()` without any name did not work: https://github.com/nodejs/node/issues/20923.\n        socket.removeAllListeners(\"timeout\");\n        socket.removeAllListeners(\"data\");\n        socket.removeAllListeners(\"end\");\n        socket.removeAllListeners(\"error\");\n        socket.removeAllListeners(\"close\");\n        socket.removeAllListeners(\"connect\");\n    }\n    /**\n     * Provide a new socket instance.\n     *\n     * Internal use only, replaced for unit tests.\n     */ _newSocket() {\n        return new net_1.Socket();\n    }\n}\nexports.FTPContext = FTPContext;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2ljLWZ0cC9kaXN0L0Z0cENvbnRleHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFrQixHQUFHQSxnQkFBZ0IsR0FBRyxLQUFLO0FBQzdDLE1BQU1JLFFBQVFDLG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLE1BQU1DLHlCQUF5QkQsbUJBQU9BLENBQUMsK0ZBQXdCO0FBQy9EOztDQUVDLEdBQ0QsTUFBTUYsaUJBQWlCSTtJQUNuQkMsWUFBWUMsR0FBRyxDQUFFO1FBQ2IsS0FBSyxDQUFDQSxJQUFJQyxPQUFPO1FBQ2pCLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUksQ0FBQ0gsV0FBVyxDQUFDRyxJQUFJO1FBQ2pDLElBQUksQ0FBQ0MsSUFBSSxHQUFHSCxJQUFJRyxJQUFJO0lBQ3hCO0FBQ0o7QUFDQVosZ0JBQWdCLEdBQUdHO0FBQ25CLFNBQVNVO0FBQ0wsZUFBZSxHQUNuQjtBQUNBOzs7Ozs7Q0FNQyxHQUNELE1BQU1YO0lBQ0Y7Ozs7O0tBS0MsR0FDRE0sWUFBWU0sVUFBVSxDQUFDLEVBQUVDLFdBQVcsTUFBTSxDQUFFO1FBQ3hDLElBQUksQ0FBQ0QsT0FBTyxHQUFHQTtRQUNmLHFEQUFxRCxHQUNyRCxJQUFJLENBQUNFLE9BQU8sR0FBRztRQUNmLG1FQUFtRSxHQUNuRSxJQUFJLENBQUNDLFFBQVEsR0FBR0M7UUFDaEIsaUNBQWlDLEdBQ2pDLElBQUksQ0FBQ0MsVUFBVSxHQUFHLENBQUM7UUFDbkIsK0RBQStELEdBQy9ELElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdOO1FBQ2pCLGtIQUFrSDtRQUNsSCxJQUFJLENBQUNPLE9BQU8sR0FBRyxJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNDLFVBQVU7UUFDNUMsSUFBSSxDQUFDQyxXQUFXLEdBQUdQO0lBQ3ZCO0lBQ0E7O0tB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QyxHQUNEekMsdUJBQXVCbEIsTUFBTSxFQUFFO1FBQzNCQSxPQUFPNEQsa0JBQWtCO1FBQ3pCLHlJQUF5STtRQUN6STVELE9BQU80RCxrQkFBa0IsQ0FBQztRQUMxQjVELE9BQU80RCxrQkFBa0IsQ0FBQztRQUMxQjVELE9BQU80RCxrQkFBa0IsQ0FBQztRQUMxQjVELE9BQU80RCxrQkFBa0IsQ0FBQztRQUMxQjVELE9BQU80RCxrQkFBa0IsQ0FBQztRQUMxQjVELE9BQU80RCxrQkFBa0IsQ0FBQztJQUM5QjtJQUNBOzs7O0tBSUMsR0FDRDNELGFBQWE7UUFDVCxPQUFPLElBQUlwQixNQUFNZ0YsTUFBTTtJQUMzQjtBQUNKO0FBQ0FwRixrQkFBa0IsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2ljLWZ0cC9kaXN0L0Z0cENvbnRleHQuanM/ZGE0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRlRQQ29udGV4dCA9IGV4cG9ydHMuRlRQRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XG5jb25zdCBwYXJzZUNvbnRyb2xSZXNwb25zZV8xID0gcmVxdWlyZShcIi4vcGFyc2VDb250cm9sUmVzcG9uc2VcIik7XG4vKipcbiAqIERlc2NyaWJlcyBhbiBGVFAgc2VydmVyIGVycm9yIHJlc3BvbnNlIGluY2x1ZGluZyB0aGUgRlRQIHJlc3BvbnNlIGNvZGUuXG4gKi9cbmNsYXNzIEZUUEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlcykge1xuICAgICAgICBzdXBlcihyZXMubWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdGhpcy5jb2RlID0gcmVzLmNvZGU7XG4gICAgfVxufVxuZXhwb3J0cy5GVFBFcnJvciA9IEZUUEVycm9yO1xuZnVuY3Rpb24gZG9Ob3RoaW5nKCkge1xuICAgIC8qKiBEbyBub3RoaW5nICovXG59XG4vKipcbiAqIEZUUENvbnRleHQgaG9sZHMgdGhlIGNvbnRyb2wgYW5kIGRhdGEgc29ja2V0cyBvZiBhbiBGVFAgY29ubmVjdGlvbiBhbmQgcHJvdmlkZXMgYVxuICogc2ltcGxpZmllZCB3YXkgdG8gaW50ZXJhY3Qgd2l0aCBhbiBGVFAgc2VydmVyLCBoYW5kbGUgcmVzcG9uc2VzLCBlcnJvcnMgYW5kIHRpbWVvdXRzLlxuICpcbiAqIEl0IGRvZXNuJ3QgaW1wbGVtZW50IG9yIHVzZSBhbnkgRlRQIGNvbW1hbmRzLiBJdCdzIG9ubHkgYSBmb3VuZGF0aW9uIHRvIG1ha2Ugd3JpdGluZyBhbiBGVFBcbiAqIGNsaWVudCBhcyBlYXN5IGFzIHBvc3NpYmxlLiBZb3Ugd29uJ3QgdXN1YWxseSBpbnN0YW50aWF0ZSB0aGlzLCBidXQgdXNlIGBDbGllbnRgLlxuICovXG5jbGFzcyBGVFBDb250ZXh0IHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhbiBGVFAgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lb3V0IC0gVGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYXBwbHkgdG8gY29udHJvbCBhbmQgZGF0YSBjb25uZWN0aW9ucy4gVXNlIDAgZm9yIG5vIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIGVuY29kaW5nIC0gRW5jb2RpbmcgdG8gdXNlIGZvciBjb250cm9sIGNvbm5lY3Rpb24uIFVURi04IGJ5IGRlZmF1bHQuIFVzZSBcImxhdGluMVwiIGZvciBvbGRlciBzZXJ2ZXJzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRpbWVvdXQgPSAwLCBlbmNvZGluZyA9IFwidXRmOFwiKSB7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIC8qKiBEZWJ1Zy1sZXZlbCBsb2dnaW5nIG9mIGFsbCBzb2NrZXQgY29tbXVuaWNhdGlvbi4gKi9cbiAgICAgICAgdGhpcy52ZXJib3NlID0gZmFsc2U7XG4gICAgICAgIC8qKiBJUCB2ZXJzaW9uIHRvIHByZWZlciAoNDogSVB2NCwgNjogSVB2NiwgdW5kZWZpbmVkOiBhdXRvbWF0aWMpLiAqL1xuICAgICAgICB0aGlzLmlwRmFtaWx5ID0gdW5kZWZpbmVkO1xuICAgICAgICAvKiogT3B0aW9ucyBmb3IgVExTIGNvbm5lY3Rpb25zLiAqL1xuICAgICAgICB0aGlzLnRsc09wdGlvbnMgPSB7fTtcbiAgICAgICAgLyoqIEEgbXVsdGlsaW5lIHJlc3BvbnNlIG1pZ2h0IGJlIHJlY2VpdmVkIGFzIG11bHRpcGxlIGNodW5rcy4gKi9cbiAgICAgICAgdGhpcy5fcGFydGlhbFJlc3BvbnNlID0gXCJcIjtcbiAgICAgICAgdGhpcy5fZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICAgICAgLy8gSGVscCBUeXBlc2NyaXB0IHVuZGVyc3RhbmQgdGhhdCB3ZSBkbyBpbmRlZWQgc2V0IF9zb2NrZXQgaW4gdGhlIGNvbnN0cnVjdG9yIGJ1dCB1c2UgdGhlIHNldHRlciBtZXRob2QgdG8gZG8gc28uXG4gICAgICAgIHRoaXMuX3NvY2tldCA9IHRoaXMuc29ja2V0ID0gdGhpcy5fbmV3U29ja2V0KCk7XG4gICAgICAgIHRoaXMuX2RhdGFTb2NrZXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBjb250ZXh0LlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICAvLyBJbnRlcm5hbGx5LCBjbG9zaW5nIGEgY29udGV4dCBpcyBhbHdheXMgZGVzY3JpYmVkIHdpdGggYW4gZXJyb3IuIElmIHRoZXJlIGlzIHN0aWxsIGEgdGFzayBydW5uaW5nLCBpdCB3aWxsXG4gICAgICAgIC8vIGFib3J0IHdpdGggYW4gZXhjZXB0aW9uIHRoYXQgdGhlIHVzZXIgY2xvc2VkIHRoZSBjbGllbnQgZHVyaW5nIGEgdGFzay4gSWYgbm8gdGFzayBpcyBydW5uaW5nLCBubyBleGNlcHRpb24gaXNcbiAgICAgICAgLy8gdGhyb3duIGJ1dCBhbGwgbmV3bHkgc3VibWl0dGVkIHRhc2tzIGFmdGVyIHRoYXQgd2lsbCBhYm9ydCB0aGUgZXhjZXB0aW9uIHRoYXQgdGhlIGNsaWVudCBoYXMgYmVlbiBjbG9zZWQuXG4gICAgICAgIC8vIEluIGFkZGl0aW9uIHRoZSB1c2VyIHdpbGwgZ2V0IGEgc3RhY2sgdHJhY2UgcG9pbnRpbmcgdG8gd2hlcmUgZXhhY3RseSB0aGUgY2xpZW50IGhhcyBiZWVuIGNsb3NlZC4gU28gaW4gYW55XG4gICAgICAgIC8vIGNhc2UgdXNlIF9jbG9zaW5nRXJyb3IgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBjb250ZXh0IGlzIGNsb3NlZC4gVGhpcyBhbHNvIGFsbG93cyB1cyB0byBoYXZlIGEgc2luZ2xlIGNvZGUtcGF0aFxuICAgICAgICAvLyBmb3IgY2xvc2luZyBhIGNvbnRleHQgbWFraW5nIHRoZSBpbXBsZW1lbnRhdGlvbiBlYXNpZXIuXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLl90YXNrID8gXCJVc2VyIGNsb3NlZCBjbGllbnQgZHVyaW5nIHRhc2tcIiA6IFwiVXNlciBjbG9zZWQgY2xpZW50XCI7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jbG9zZVdpdGhFcnJvcihlcnIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgY29udGV4dCB3aXRoIGFuIGVycm9yLlxuICAgICAqL1xuICAgIGNsb3NlV2l0aEVycm9yKGVycikge1xuICAgICAgICAvLyBJZiB0aGlzIGNvbnRleHQgYWxyZWFkeSBoYXMgYmVlbiBjbG9zZWQsIGRvbid0IG92ZXJ3cml0ZSB0aGUgcmVhc29uLlxuICAgICAgICBpZiAodGhpcy5fY2xvc2luZ0Vycm9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xvc2luZ0Vycm9yID0gZXJyO1xuICAgICAgICAvLyBDbG9zZSB0aGUgc29ja2V0cyBidXQgZG9uJ3QgZnVsbHkgcmVzZXQgdGhpcyBjb250ZXh0IHRvIHByZXNlcnZlIGB0aGlzLl9jbG9zaW5nRXJyb3JgLlxuICAgICAgICB0aGlzLl9jbG9zZUNvbnRyb2xTb2NrZXQoKTtcbiAgICAgICAgdGhpcy5fY2xvc2VTb2NrZXQodGhpcy5fZGF0YVNvY2tldCk7XG4gICAgICAgIC8vIEdpdmUgdGhlIHVzZXIncyB0YXNrIGEgY2hhbmNlIHRvIHJlYWN0LCBtYXliZSBjbGVhbnVwIHJlc291cmNlcy5cbiAgICAgICAgdGhpcy5fcGFzc1RvSGFuZGxlcihlcnIpO1xuICAgICAgICAvLyBUaGUgdGFzayBtaWdodCBub3QgaGF2ZSBiZWVuIHJlamVjdGVkIGJ5IHRoZSB1c2VyIGFmdGVyIHJlY2VpdmluZyB0aGUgZXJyb3IuXG4gICAgICAgIHRoaXMuX3N0b3BUcmFja2luZ1Rhc2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY29udGV4dCBoYXMgYmVlbiBjbG9zZWQgb3IgaGFzbid0IGJlZW4gY29ubmVjdGVkIHlldC4gWW91IGNhbiByZW9wZW4gaXQgd2l0aCBgYWNjZXNzYC5cbiAgICAgKi9cbiAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXQucmVtb3RlQWRkcmVzcyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX2Nsb3NpbmdFcnJvciAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGlzIGNvbnRleCBhbmQgYWxsIG9mIGl0cyBzdGF0ZS5cbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQgPSB0aGlzLl9uZXdTb2NrZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBGVFAgY29udHJvbCBzb2NrZXQuXG4gICAgICovXG4gICAgZ2V0IHNvY2tldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvY2tldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzb2NrZXQgZm9yIHRoZSBjb250cm9sIGNvbm5lY3Rpb24uIFRoaXMgd2lsbCBvbmx5IGNsb3NlIHRoZSBjdXJyZW50IGNvbnRyb2wgc29ja2V0XG4gICAgICogaWYgdGhlIG5ldyBvbmUgaXMgbm90IGFuIHVwZ3JhZGUgdG8gdGhlIGN1cnJlbnQgb25lLlxuICAgICAqL1xuICAgIHNldCBzb2NrZXQoc29ja2V0KSB7XG4gICAgICAgIC8vIE5vIGRhdGEgc29ja2V0IHNob3VsZCBiZSBvcGVuIGluIGFueSBjYXNlIHdoZXJlIHRoZSBjb250cm9sIHNvY2tldCBpcyBzZXQgb3IgdXBncmFkZWQuXG4gICAgICAgIHRoaXMuZGF0YVNvY2tldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gVGhpcyBiZWluZyBhIHJlc2V0LCByZXNldCBhbnkgb3RoZXIgc3RhdGUgYXBhcnQgZnJvbSB0aGUgc29ja2V0LlxuICAgICAgICB0aGlzLnRsc09wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5fcGFydGlhbFJlc3BvbnNlID0gXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuX3NvY2tldCkge1xuICAgICAgICAgICAgY29uc3QgbmV3U29ja2V0VXBncmFkZXNFeGlzdGluZyA9IHNvY2tldC5sb2NhbFBvcnQgPT09IHRoaXMuX3NvY2tldC5sb2NhbFBvcnQ7XG4gICAgICAgICAgICBpZiAobmV3U29ja2V0VXBncmFkZXNFeGlzdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVNvY2tldExpc3RlbmVycyh0aGlzLnNvY2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZUNvbnRyb2xTb2NrZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc29ja2V0KSB7XG4gICAgICAgICAgICAvLyBTZXR0aW5nIGEgY29tcGxldGVseSBuZXcgY29udHJvbCBzb2NrZXQgaXMgaW4gZXNzZW5jZSBzb21ldGhpbmcgbGlrZSBhIHJlc2V0LiBUaGF0J3NcbiAgICAgICAgICAgIC8vIHdoeSB3ZSBhbHNvIGNsb3NlIGFueSBvcGVuIGRhdGEgY29ubmVjdGlvbiBhYm92ZS4gV2UgY2FuIGdvIG9uZSBzdGVwIGZ1cnRoZXIgYW5kIHJlc2V0XG4gICAgICAgICAgICAvLyBhIHBvc3NpYmxlIGNsb3NpbmcgZXJyb3IuIFRoYXQgbWVhbnMgdGhhdCBhIGNsb3NlZCBGVFBDb250ZXh0IGNhbiBiZSBcInJlb3BlbmVkXCIgYnlcbiAgICAgICAgICAgIC8vIHNldHRpbmcgYSBuZXcgY29udHJvbCBzb2NrZXQuXG4gICAgICAgICAgICB0aGlzLl9jbG9zaW5nRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvLyBEb24ndCBzZXQgYSB0aW1lb3V0IHlldC4gVGltZW91dCBmb3IgY29udHJvbCBzb2NrZXRzIGlzIG9ubHkgYWN0aXZlIGR1cmluZyBhIHRhc2ssIHNlZSBoYW5kbGUoKSBiZWxvdy5cbiAgICAgICAgICAgIHNvY2tldC5zZXRUaW1lb3V0KDApO1xuICAgICAgICAgICAgc29ja2V0LnNldEVuY29kaW5nKHRoaXMuX2VuY29kaW5nKTtcbiAgICAgICAgICAgIHNvY2tldC5zZXRLZWVwQWxpdmUodHJ1ZSk7XG4gICAgICAgICAgICBzb2NrZXQub24oXCJkYXRhXCIsIGRhdGEgPT4gdGhpcy5fb25Db250cm9sU29ja2V0RGF0YShkYXRhKSk7XG4gICAgICAgICAgICAvLyBTZXJ2ZXIgc2VuZGluZyBhIEZJTiBwYWNrZXQgaXMgdHJlYXRlZCBhcyBhbiBlcnJvci5cbiAgICAgICAgICAgIHNvY2tldC5vbihcImVuZFwiLCAoKSA9PiB0aGlzLmNsb3NlV2l0aEVycm9yKG5ldyBFcnJvcihcIlNlcnZlciBzZW50IEZJTiBwYWNrZXQgdW5leHBlY3RlZGx5LCBjbG9zaW5nIGNvbm5lY3Rpb24uXCIpKSk7XG4gICAgICAgICAgICAvLyBDb250cm9sIGJlaW5nIGNsb3NlZCB3aXRob3V0IGVycm9yIGJ5IHNlcnZlciBpcyB0cmVhdGVkIGFzIGFuIGVycm9yLlxuICAgICAgICAgICAgc29ja2V0Lm9uKFwiY2xvc2VcIiwgaGFkRXJyb3IgPT4geyBpZiAoIWhhZEVycm9yKVxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VXaXRoRXJyb3IobmV3IEVycm9yKFwiU2VydmVyIGNsb3NlZCBjb25uZWN0aW9uIHVuZXhwZWN0ZWRseS5cIikpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwRGVmYXVsdEVycm9ySGFuZGxlcnMoc29ja2V0LCBcImNvbnRyb2wgc29ja2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IEZUUCBkYXRhIGNvbm5lY3Rpb24gaWYgcHJlc2VudC5cbiAgICAgKi9cbiAgICBnZXQgZGF0YVNvY2tldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFTb2NrZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc29ja2V0IGZvciB0aGUgZGF0YSBjb25uZWN0aW9uLiBUaGlzIHdpbGwgYXV0b21hdGljYWxseSBjbG9zZSB0aGUgZm9ybWVyIGRhdGEgc29ja2V0LlxuICAgICAqL1xuICAgIHNldCBkYXRhU29ja2V0KHNvY2tldCkge1xuICAgICAgICB0aGlzLl9jbG9zZVNvY2tldCh0aGlzLl9kYXRhU29ja2V0KTtcbiAgICAgICAgaWYgKHNvY2tldCkge1xuICAgICAgICAgICAgLy8gRG9uJ3Qgc2V0IGEgdGltZW91dCB5ZXQuIFRpbWVvdXQgZGF0YSBzb2NrZXQgc2hvdWxkIGJlIGFjdGl2YXRlZCB3aGVuIGRhdGEgdHJhbnNtaXNzaW9uIHN0YXJ0c1xuICAgICAgICAgICAgLy8gYW5kIHRpbWVvdXQgb24gY29udHJvbCBzb2NrZXQgaXMgZGVhY3RpdmF0ZWQuXG4gICAgICAgICAgICBzb2NrZXQuc2V0VGltZW91dCgwKTtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwRGVmYXVsdEVycm9ySGFuZGxlcnMoc29ja2V0LCBcImRhdGEgc29ja2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGFTb2NrZXQgPSBzb2NrZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudGx5IHVzZWQgZW5jb2RpbmcuXG4gICAgICovXG4gICAgZ2V0IGVuY29kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2Rpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZW5jb2RpbmcgdXNlZCBmb3IgdGhlIGNvbnRyb2wgc29ja2V0LlxuICAgICAqXG4gICAgICogU2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvYnVmZmVyLmh0bWwjYnVmZmVyX2J1ZmZlcnNfYW5kX2NoYXJhY3Rlcl9lbmNvZGluZ3MgZm9yIHdoYXQgZW5jb2RpbmdzXG4gICAgICogYXJlIHN1cHBvcnRlZCBieSBOb2RlLlxuICAgICAqL1xuICAgIHNldCBlbmNvZGluZyhlbmNvZGluZykge1xuICAgICAgICB0aGlzLl9lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNldEVuY29kaW5nKGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGFuIEZUUCBjb21tYW5kIHdpdGhvdXQgd2FpdGluZyBmb3Igb3IgaGFuZGxpbmcgdGhlIHJlc3VsdC5cbiAgICAgKi9cbiAgICBzZW5kKGNvbW1hbmQpIHtcbiAgICAgICAgY29uc3QgY29udGFpbnNQYXNzd29yZCA9IGNvbW1hbmQuc3RhcnRzV2l0aChcIlBBU1NcIik7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjb250YWluc1Bhc3N3b3JkID8gXCI+IFBBU1MgIyMjXCIgOiBgPiAke2NvbW1hbmR9YDtcbiAgICAgICAgdGhpcy5sb2cobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuX3NvY2tldC53cml0ZShjb21tYW5kICsgXCJcXHJcXG5cIiwgdGhpcy5lbmNvZGluZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYW4gRlRQIGNvbW1hbmQgYW5kIGhhbmRsZSB0aGUgZmlyc3QgcmVzcG9uc2UuIFVzZSB0aGlzIGlmIHlvdSBoYXZlIGEgc2ltcGxlXG4gICAgICogcmVxdWVzdC1yZXNwb25zZSBzaXR1YXRpb24uXG4gICAgICovXG4gICAgcmVxdWVzdChjb21tYW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZShjb21tYW5kLCAocmVzLCB0YXNrKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0YXNrLnJlamVjdChyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFzay5yZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGFuIEZUUCBjb21tYW5kIGFuZCBoYW5kbGUgYW55IHJlc3BvbnNlIHVudGlsIHlvdSByZXNvbHZlL3JlamVjdC4gVXNlIHRoaXMgaWYgeW91IGV4cGVjdCBtdWx0aXBsZSByZXNwb25zZXNcbiAgICAgKiB0byBhIHJlcXVlc3QuIFRoaXMgcmV0dXJucyBhIFByb21pc2UgdGhhdCB3aWxsIGhvbGQgd2hhdGV2ZXIgdGhlIHJlc3BvbnNlIGhhbmRsZXIgcGFzc2VkIG9uIHdoZW4gcmVzb2x2aW5nL3JlamVjdGluZyBpdHMgdGFzay5cbiAgICAgKi9cbiAgICBoYW5kbGUoY29tbWFuZCwgcmVzcG9uc2VIYW5kbGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl90YXNrKSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXCJVc2VyIGxhdW5jaGVkIGEgdGFzayB3aGlsZSBhbm90aGVyIG9uZSBpcyBzdGlsbCBydW5uaW5nLiBGb3Jnb3QgdG8gdXNlICdhd2FpdCcgb3IgJy50aGVuKCknP1wiKTtcbiAgICAgICAgICAgIGVyci5zdGFjayArPSBgXFxuUnVubmluZyB0YXNrIGxhdW5jaGVkIGF0OiAke3RoaXMuX3Rhc2suc3RhY2t9YDtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VXaXRoRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIC8vIERvbid0IHJldHVybiBoZXJlLCBjb250aW51ZSB3aXRoIHJldHVybmluZyB0aGUgUHJvbWlzZSB0aGF0IHdpbGwgdGhlbiBiZSByZWplY3RlZFxuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgY29udGV4dCBjbG9zZWQgYWxyZWFkeS4gVGhhdCB3YXksIHVzZXJzIHdpbGwgcmVjZWl2ZSBhbiBleGNlcHRpb24gd2hlcmVcbiAgICAgICAgICAgIC8vIHRoZXkgY2FsbGVkIHRoaXMgbWV0aG9kIGJ5IG1pc3Rha2UuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlVGFzaywgcmVqZWN0VGFzaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fdGFzayA9IHtcbiAgICAgICAgICAgICAgICBzdGFjazogbmV3IEVycm9yKCkuc3RhY2sgfHwgXCJVbmtub3duIGNhbGwgc3RhY2tcIixcbiAgICAgICAgICAgICAgICByZXNwb25zZUhhbmRsZXIsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZTogYXJnID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BUcmFja2luZ1Rhc2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVUYXNrKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdDogZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BUcmFja2luZ1Rhc2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdFRhc2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5fY2xvc2luZ0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjbGllbnQgaGFzIGJlZW4gY2xvc2VkLiBQcm92aWRlIGFuIGVycm9yIHRoYXQgZGVzY3JpYmVzIHRoaXMgb25lIGFzIGJlaW5nIGNhdXNlZFxuICAgICAgICAgICAgICAgIC8vIGJ5IGBfY2xvc2luZ0Vycm9yYCwgaW5jbHVkZSBzdGFjayB0cmFjZXMgZm9yIGJvdGguXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBDbGllbnQgaXMgY2xvc2VkIGJlY2F1c2UgJHt0aGlzLl9jbG9zaW5nRXJyb3IubWVzc2FnZX1gKTsgLy8gVHlwZSAnRXJyb3InIGlzIG5vdCBjb3JyZWN0bHkgZGVmaW5lZCwgZG9lc24ndCBoYXZlICdjb2RlJy5cbiAgICAgICAgICAgICAgICBlcnIuc3RhY2sgKz0gYFxcbkNsb3NpbmcgcmVhc29uOiAke3RoaXMuX2Nsb3NpbmdFcnJvci5zdGFja31gO1xuICAgICAgICAgICAgICAgIGVyci5jb2RlID0gdGhpcy5fY2xvc2luZ0Vycm9yLmNvZGUgIT09IHVuZGVmaW5lZCA/IHRoaXMuX2Nsb3NpbmdFcnJvci5jb2RlIDogXCIwXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFzc1RvSGFuZGxlcihlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9ubHkgdHJhY2sgY29udHJvbCBzb2NrZXQgdGltZW91dCBkdXJpbmcgdGhlIGxpZmVjeWNsZSBvZiBhIHRhc2suIFRoaXMgYXZvaWRzIHRpbWVvdXRzIG9uIGlkbGUgc29ja2V0cyxcbiAgICAgICAgICAgIC8vIHRoZSBkZWZhdWx0IHNvY2tldCBiZWhhdmlvdXIgd2hpY2ggaXMgbm90IGV4cGVjdGVkIGJ5IG1vc3QgdXNlcnMuXG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZXRUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgICAgICBpZiAoY29tbWFuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZChjb21tYW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBtZXNzYWdlIGlmIHNldCB0byBiZSB2ZXJib3NlLlxuICAgICAqL1xuICAgIGxvZyhtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgY29udHJvbCBzb2NrZXQgaXMgdXNpbmcgVExTLiBUaGlzIGRvZXMgbm90IG1lYW4gdGhhdCBhIHNlc3Npb25cbiAgICAgKiBoYXMgYWxyZWFkeSBiZWVuIG5lZ290aWF0ZWQuXG4gICAgICovXG4gICAgZ2V0IGhhc1RMUygpIHtcbiAgICAgICAgcmV0dXJuIFwiZW5jcnlwdGVkXCIgaW4gdGhpcy5fc29ja2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHJlZmVyZW5jZSB0byBjdXJyZW50IHRhc2sgYW5kIGhhbmRsZXIuIFRoaXMgd29uJ3QgcmVzb2x2ZSBvciByZWplY3QgdGhlIHRhc2suXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zdG9wVHJhY2tpbmdUYXNrKCkge1xuICAgICAgICAvLyBEaXNhYmxlIHRpbWVvdXQgb24gY29udHJvbCBzb2NrZXQgaWYgdGhlcmUgaXMgbm8gdGFzayBhY3RpdmUuXG4gICAgICAgIHRoaXMuc29ja2V0LnNldFRpbWVvdXQoMCk7XG4gICAgICAgIHRoaXMuX3Rhc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBpbmNvbWluZyBkYXRhIG9uIHRoZSBjb250cm9sIHNvY2tldC4gVGhlIGNodW5rIGlzIGdvaW5nIHRvIGJlIG9mIHR5cGUgYHN0cmluZ2BcbiAgICAgKiBiZWNhdXNlIHdlIGxldCBgc29ja2V0YCBoYW5kbGUgZW5jb2Rpbmcgd2l0aCBgc2V0RW5jb2RpbmdgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfb25Db250cm9sU29ja2V0RGF0YShjaHVuaykge1xuICAgICAgICB0aGlzLmxvZyhgPCAke2NodW5rfWApO1xuICAgICAgICAvLyBUaGlzIGNodW5rIG1pZ2h0IGNvbXBsZXRlIGFuIGVhcmxpZXIgcGFydGlhbCByZXNwb25zZS5cbiAgICAgICAgY29uc3QgY29tcGxldGVSZXNwb25zZSA9IHRoaXMuX3BhcnRpYWxSZXNwb25zZSArIGNodW5rO1xuICAgICAgICBjb25zdCBwYXJzZWQgPSAoMCwgcGFyc2VDb250cm9sUmVzcG9uc2VfMS5wYXJzZUNvbnRyb2xSZXNwb25zZSkoY29tcGxldGVSZXNwb25zZSk7XG4gICAgICAgIC8vIFJlbWVtYmVyIGFueSBpbmNvbXBsZXRlIHJlbWFpbmRlci5cbiAgICAgICAgdGhpcy5fcGFydGlhbFJlc3BvbnNlID0gcGFyc2VkLnJlc3Q7XG4gICAgICAgIC8vIEVhY2ggcmVzcG9uc2UgZ3JvdXAgaXMgcGFzc2VkIGFsb25nIGluZGl2aWR1YWxseS5cbiAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHBhcnNlZC5tZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhcnNlSW50KG1lc3NhZ2Uuc3Vic3RyKDAsIDMpLCAxMCk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHsgY29kZSwgbWVzc2FnZSB9O1xuICAgICAgICAgICAgY29uc3QgZXJyID0gY29kZSA+PSA0MDAgPyBuZXcgRlRQRXJyb3IocmVzcG9uc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fcGFzc1RvSGFuZGxlcihlcnIgPyBlcnIgOiByZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCB0aGUgY3VycmVudCBoYW5kbGVyIGEgcmVzcG9uc2UuIFRoaXMgaXMgdXN1YWxseSBhIGNvbnRyb2wgc29ja2V0IHJlc3BvbnNlXG4gICAgICogb3IgYSBzb2NrZXQgZXZlbnQsIGxpa2UgYW4gZXJyb3Igb3IgdGltZW91dC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Bhc3NUb0hhbmRsZXIocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Rhc2spIHtcbiAgICAgICAgICAgIHRoaXMuX3Rhc2sucmVzcG9uc2VIYW5kbGVyKHJlc3BvbnNlLCB0aGlzLl90YXNrLnJlc29sdmVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFcnJvcnMgb3RoZXIgdGhhbiBGVFBFcnJvciBhbHdheXMgY2xvc2UgdGhlIGNsaWVudC4gSWYgdGhlcmUgaXNuJ3QgYW4gYWN0aXZlIHRhc2sgdG8gaGFuZGxlIHRoZSBlcnJvcixcbiAgICAgICAgLy8gdGhlIG5leHQgb25lIHN1Ym1pdHRlZCB3aWxsIHJlY2VpdmUgaXQgdXNpbmcgYF9jbG9zaW5nRXJyb3JgLlxuICAgICAgICAvLyBUaGVyZSBpcyBvbmx5IG9uZSBlZGdlLWNhc2U6IElmIHRoZXJlIGlzIGFuIEZUUEVycm9yIHdoaWxlIG5vIHRhc2sgaXMgYWN0aXZlLCB0aGUgZXJyb3Igd2lsbCBiZSBkcm9wcGVkLlxuICAgICAgICAvLyBCdXQgdGhhdCBtZWFucyB0aGF0IHRoZSB1c2VyIHNlbnQgYW4gRlRQIGNvbW1hbmQgd2l0aCBubyBpbnRlbnRpb24gb2YgaGFuZGxpbmcgdGhlIHJlc3VsdC4gU28gd2h5IHNob3VsZCB0aGVcbiAgICAgICAgLy8gZXJyb3IgYmUgaGFuZGxlZD8gTWF5YmUgbG9nIGl0IGF0IGxlYXN0PyBEZWJ1ZyBsb2dnaW5nIHdpbGwgYWxyZWFkeSBkbyB0aGF0IGFuZCB0aGUgY2xpZW50IHN0YXlzIHVzZWFibGUgYWZ0ZXJcbiAgICAgICAgLy8gRlRQRXJyb3IuIFNvIG1heWJlIG5vIG5lZWQgdG8gZG8gYW55dGhpbmcgaGVyZS5cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0dXAgYWxsIGVycm9yIGhhbmRsZXJzIGZvciBhIHNvY2tldC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3NldHVwRGVmYXVsdEVycm9ySGFuZGxlcnMoc29ja2V0LCBpZGVudGlmaWVyKSB7XG4gICAgICAgIHNvY2tldC5vbmNlKFwiZXJyb3JcIiwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSArPSBgICgke2lkZW50aWZpZXJ9KWA7XG4gICAgICAgICAgICB0aGlzLmNsb3NlV2l0aEVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNvY2tldC5vbmNlKFwiY2xvc2VcIiwgaGFkRXJyb3IgPT4ge1xuICAgICAgICAgICAgaWYgKGhhZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVdpdGhFcnJvcihuZXcgRXJyb3IoYFNvY2tldCBjbG9zZWQgZHVlIHRvIHRyYW5zbWlzc2lvbiBlcnJvciAoJHtpZGVudGlmaWVyfSlgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzb2NrZXQub25jZShcInRpbWVvdXRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VXaXRoRXJyb3IobmV3IEVycm9yKGBUaW1lb3V0ICgke2lkZW50aWZpZXJ9KWApKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBjb250cm9sIHNvY2tldC4gU2VuZHMgUVVJVCwgdGhlbiBGSU4sIGFuZCBpZ25vcmVzIGFueSByZXNwb25zZSBvciBlcnJvci5cbiAgICAgKi9cbiAgICBfY2xvc2VDb250cm9sU29ja2V0KCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVTb2NrZXRMaXN0ZW5lcnModGhpcy5fc29ja2V0KTtcbiAgICAgICAgdGhpcy5fc29ja2V0Lm9uKFwiZXJyb3JcIiwgZG9Ob3RoaW5nKTtcbiAgICAgICAgdGhpcy5zZW5kKFwiUVVJVFwiKTtcbiAgICAgICAgdGhpcy5fY2xvc2VTb2NrZXQodGhpcy5fc29ja2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2UgYSBzb2NrZXQsIGlnbm9yZXMgYW55IGVycm9yLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY2xvc2VTb2NrZXQoc29ja2V0KSB7XG4gICAgICAgIGlmIChzb2NrZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVNvY2tldExpc3RlbmVycyhzb2NrZXQpO1xuICAgICAgICAgICAgc29ja2V0Lm9uKFwiZXJyb3JcIiwgZG9Ob3RoaW5nKTtcbiAgICAgICAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBkZWZhdWx0IGxpc3RlbmVycyBmb3Igc29ja2V0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVtb3ZlU29ja2V0TGlzdGVuZXJzKHNvY2tldCkge1xuICAgICAgICBzb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIC8vIEJlZm9yZSBOb2RlLmpzIDEwLjMuMCwgdXNpbmcgYHNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKWAgd2l0aG91dCBhbnkgbmFtZSBkaWQgbm90IHdvcms6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMjA5MjMuXG4gICAgICAgIHNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJ0aW1lb3V0XCIpO1xuICAgICAgICBzb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKFwiZGF0YVwiKTtcbiAgICAgICAgc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycyhcImVuZFwiKTtcbiAgICAgICAgc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycyhcImVycm9yXCIpO1xuICAgICAgICBzb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKFwiY2xvc2VcIik7XG4gICAgICAgIHNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJjb25uZWN0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm92aWRlIGEgbmV3IHNvY2tldCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEludGVybmFsIHVzZSBvbmx5LCByZXBsYWNlZCBmb3IgdW5pdCB0ZXN0cy5cbiAgICAgKi9cbiAgICBfbmV3U29ja2V0KCkge1xuICAgICAgICByZXR1cm4gbmV3IG5ldF8xLlNvY2tldCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuRlRQQ29udGV4dCA9IEZUUENvbnRleHQ7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJGVFBDb250ZXh0IiwiRlRQRXJyb3IiLCJuZXRfMSIsInJlcXVpcmUiLCJwYXJzZUNvbnRyb2xSZXNwb25zZV8xIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsInJlcyIsIm1lc3NhZ2UiLCJuYW1lIiwiY29kZSIsImRvTm90aGluZyIsInRpbWVvdXQiLCJlbmNvZGluZyIsInZlcmJvc2UiLCJpcEZhbWlseSIsInVuZGVmaW5lZCIsInRsc09wdGlvbnMiLCJfcGFydGlhbFJlc3BvbnNlIiwiX2VuY29kaW5nIiwiX3NvY2tldCIsInNvY2tldCIsIl9uZXdTb2NrZXQiLCJfZGF0YVNvY2tldCIsImNsb3NlIiwiX3Rhc2siLCJlcnIiLCJjbG9zZVdpdGhFcnJvciIsIl9jbG9zaW5nRXJyb3IiLCJfY2xvc2VDb250cm9sU29ja2V0IiwiX2Nsb3NlU29ja2V0IiwiX3Bhc3NUb0hhbmRsZXIiLCJfc3RvcFRyYWNraW5nVGFzayIsImNsb3NlZCIsInJlbW90ZUFkZHJlc3MiLCJyZXNldCIsImRhdGFTb2NrZXQiLCJuZXdTb2NrZXRVcGdyYWRlc0V4aXN0aW5nIiwibG9jYWxQb3J0IiwiX3JlbW92ZVNvY2tldExpc3RlbmVycyIsInNldFRpbWVvdXQiLCJzZXRFbmNvZGluZyIsInNldEtlZXBBbGl2ZSIsIm9uIiwiZGF0YSIsIl9vbkNvbnRyb2xTb2NrZXREYXRhIiwiaGFkRXJyb3IiLCJfc2V0dXBEZWZhdWx0RXJyb3JIYW5kbGVycyIsInNlbmQiLCJjb21tYW5kIiwiY29udGFpbnNQYXNzd29yZCIsInN0YXJ0c1dpdGgiLCJsb2ciLCJ3cml0ZSIsInJlcXVlc3QiLCJoYW5kbGUiLCJ0YXNrIiwicmVqZWN0IiwicmVzb2x2ZSIsInJlc3BvbnNlSGFuZGxlciIsInN0YWNrIiwiUHJvbWlzZSIsInJlc29sdmVUYXNrIiwicmVqZWN0VGFzayIsInJlc29sdmVyIiwiYXJnIiwiY29uc29sZSIsImhhc1RMUyIsImNodW5rIiwiY29tcGxldGVSZXNwb25zZSIsInBhcnNlZCIsInBhcnNlQ29udHJvbFJlc3BvbnNlIiwicmVzdCIsIm1lc3NhZ2VzIiwicGFyc2VJbnQiLCJzdWJzdHIiLCJyZXNwb25zZSIsImlkZW50aWZpZXIiLCJvbmNlIiwiZXJyb3IiLCJkZXN0cm95IiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiU29ja2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/basic-ftp/dist/FtpContext.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/basic-ftp/dist/ProgressTracker.js":
/*!************************************************************!*\
  !*** ../../node_modules/basic-ftp/dist/ProgressTracker.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ProgressTracker = void 0;\n/**\n * Tracks progress of one socket data transfer at a time.\n */ class ProgressTracker {\n    constructor(){\n        this.bytesOverall = 0;\n        this.intervalMs = 500;\n        this.onStop = noop;\n        this.onHandle = noop;\n    }\n    /**\n     * Register a new handler for progress info. Use `undefined` to disable reporting.\n     */ reportTo(onHandle = noop) {\n        this.onHandle = onHandle;\n    }\n    /**\n     * Start tracking transfer progress of a socket.\n     *\n     * @param socket  The socket to observe.\n     * @param name  A name associated with this progress tracking, e.g. a filename.\n     * @param type  The type of the transfer, typically \"upload\" or \"download\".\n     */ start(socket, name, type) {\n        let lastBytes = 0;\n        this.onStop = poll(this.intervalMs, ()=>{\n            const bytes = socket.bytesRead + socket.bytesWritten;\n            this.bytesOverall += bytes - lastBytes;\n            lastBytes = bytes;\n            this.onHandle({\n                name,\n                type,\n                bytes,\n                bytesOverall: this.bytesOverall\n            });\n        });\n    }\n    /**\n     * Stop tracking transfer progress.\n     */ stop() {\n        this.onStop(false);\n    }\n    /**\n     * Call the progress handler one more time, then stop tracking.\n     */ updateAndStop() {\n        this.onStop(true);\n    }\n}\nexports.ProgressTracker = ProgressTracker;\n/**\n * Starts calling a callback function at a regular interval. The first call will go out\n * immediately. The function returns a function to stop the polling.\n */ function poll(intervalMs, updateFunc) {\n    const id = setInterval(updateFunc, intervalMs);\n    const stopFunc = (stopWithUpdate)=>{\n        clearInterval(id);\n        if (stopWithUpdate) {\n            updateFunc();\n        }\n        // Prevent repeated calls to stop calling handler.\n        updateFunc = noop;\n    };\n    updateFunc();\n    return stopFunc;\n}\nfunction noop() {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2ljLWZ0cC9kaXN0L1Byb2dyZXNzVHJhY2tlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUJBQXVCLEdBQUcsS0FBSztBQUMvQjs7Q0FFQyxHQUNELE1BQU1FO0lBQ0ZDLGFBQWM7UUFDVixJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLE1BQU0sR0FBR0M7UUFDZCxJQUFJLENBQUNDLFFBQVEsR0FBR0Q7SUFDcEI7SUFDQTs7S0FFQyxHQUNERSxTQUFTRCxXQUFXRCxJQUFJLEVBQUU7UUFDdEIsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO0lBQ3BCO0lBQ0E7Ozs7OztLQU1DLEdBQ0RFLE1BQU1DLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUU7UUFDdEIsSUFBSUMsWUFBWTtRQUNoQixJQUFJLENBQUNSLE1BQU0sR0FBR1MsS0FBSyxJQUFJLENBQUNWLFVBQVUsRUFBRTtZQUNoQyxNQUFNVyxRQUFRTCxPQUFPTSxTQUFTLEdBQUdOLE9BQU9PLFlBQVk7WUFDcEQsSUFBSSxDQUFDZCxZQUFZLElBQUlZLFFBQVFGO1lBQzdCQSxZQUFZRTtZQUNaLElBQUksQ0FBQ1IsUUFBUSxDQUFDO2dCQUNWSTtnQkFDQUM7Z0JBQ0FHO2dCQUNBWixjQUFjLElBQUksQ0FBQ0EsWUFBWTtZQUNuQztRQUNKO0lBQ0o7SUFDQTs7S0FFQyxHQUNEZSxPQUFPO1FBQ0gsSUFBSSxDQUFDYixNQUFNLENBQUM7SUFDaEI7SUFDQTs7S0FFQyxHQUNEYyxnQkFBZ0I7UUFDWixJQUFJLENBQUNkLE1BQU0sQ0FBQztJQUNoQjtBQUNKO0FBQ0FOLHVCQUF1QixHQUFHRTtBQUMxQjs7O0NBR0MsR0FDRCxTQUFTYSxLQUFLVixVQUFVLEVBQUVnQixVQUFVO0lBQ2hDLE1BQU1DLEtBQUtDLFlBQVlGLFlBQVloQjtJQUNuQyxNQUFNbUIsV0FBVyxDQUFDQztRQUNkQyxjQUFjSjtRQUNkLElBQUlHLGdCQUFnQjtZQUNoQko7UUFDSjtRQUNBLGtEQUFrRDtRQUNsREEsYUFBYWQ7SUFDakI7SUFDQWM7SUFDQSxPQUFPRztBQUNYO0FBQ0EsU0FBU2pCLFFBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2ljLWZ0cC9kaXN0L1Byb2dyZXNzVHJhY2tlci5qcz9hMTFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcm9ncmVzc1RyYWNrZXIgPSB2b2lkIDA7XG4vKipcbiAqIFRyYWNrcyBwcm9ncmVzcyBvZiBvbmUgc29ja2V0IGRhdGEgdHJhbnNmZXIgYXQgYSB0aW1lLlxuICovXG5jbGFzcyBQcm9ncmVzc1RyYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJ5dGVzT3ZlcmFsbCA9IDA7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxNcyA9IDUwMDtcbiAgICAgICAgdGhpcy5vblN0b3AgPSBub29wO1xuICAgICAgICB0aGlzLm9uSGFuZGxlID0gbm9vcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBuZXcgaGFuZGxlciBmb3IgcHJvZ3Jlc3MgaW5mby4gVXNlIGB1bmRlZmluZWRgIHRvIGRpc2FibGUgcmVwb3J0aW5nLlxuICAgICAqL1xuICAgIHJlcG9ydFRvKG9uSGFuZGxlID0gbm9vcCkge1xuICAgICAgICB0aGlzLm9uSGFuZGxlID0gb25IYW5kbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRyYWNraW5nIHRyYW5zZmVyIHByb2dyZXNzIG9mIGEgc29ja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNvY2tldCAgVGhlIHNvY2tldCB0byBvYnNlcnZlLlxuICAgICAqIEBwYXJhbSBuYW1lICBBIG5hbWUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHJvZ3Jlc3MgdHJhY2tpbmcsIGUuZy4gYSBmaWxlbmFtZS5cbiAgICAgKiBAcGFyYW0gdHlwZSAgVGhlIHR5cGUgb2YgdGhlIHRyYW5zZmVyLCB0eXBpY2FsbHkgXCJ1cGxvYWRcIiBvciBcImRvd25sb2FkXCIuXG4gICAgICovXG4gICAgc3RhcnQoc29ja2V0LCBuYW1lLCB0eXBlKSB7XG4gICAgICAgIGxldCBsYXN0Qnl0ZXMgPSAwO1xuICAgICAgICB0aGlzLm9uU3RvcCA9IHBvbGwodGhpcy5pbnRlcnZhbE1zLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IHNvY2tldC5ieXRlc1JlYWQgKyBzb2NrZXQuYnl0ZXNXcml0dGVuO1xuICAgICAgICAgICAgdGhpcy5ieXRlc092ZXJhbGwgKz0gYnl0ZXMgLSBsYXN0Qnl0ZXM7XG4gICAgICAgICAgICBsYXN0Qnl0ZXMgPSBieXRlcztcbiAgICAgICAgICAgIHRoaXMub25IYW5kbGUoe1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBieXRlcyxcbiAgICAgICAgICAgICAgICBieXRlc092ZXJhbGw6IHRoaXMuYnl0ZXNPdmVyYWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgdHJhY2tpbmcgdHJhbnNmZXIgcHJvZ3Jlc3MuXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5vblN0b3AoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoZSBwcm9ncmVzcyBoYW5kbGVyIG9uZSBtb3JlIHRpbWUsIHRoZW4gc3RvcCB0cmFja2luZy5cbiAgICAgKi9cbiAgICB1cGRhdGVBbmRTdG9wKCkge1xuICAgICAgICB0aGlzLm9uU3RvcCh0cnVlKTtcbiAgICB9XG59XG5leHBvcnRzLlByb2dyZXNzVHJhY2tlciA9IFByb2dyZXNzVHJhY2tlcjtcbi8qKlxuICogU3RhcnRzIGNhbGxpbmcgYSBjYWxsYmFjayBmdW5jdGlvbiBhdCBhIHJlZ3VsYXIgaW50ZXJ2YWwuIFRoZSBmaXJzdCBjYWxsIHdpbGwgZ28gb3V0XG4gKiBpbW1lZGlhdGVseS4gVGhlIGZ1bmN0aW9uIHJldHVybnMgYSBmdW5jdGlvbiB0byBzdG9wIHRoZSBwb2xsaW5nLlxuICovXG5mdW5jdGlvbiBwb2xsKGludGVydmFsTXMsIHVwZGF0ZUZ1bmMpIHtcbiAgICBjb25zdCBpZCA9IHNldEludGVydmFsKHVwZGF0ZUZ1bmMsIGludGVydmFsTXMpO1xuICAgIGNvbnN0IHN0b3BGdW5jID0gKHN0b3BXaXRoVXBkYXRlKSA9PiB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaWQpO1xuICAgICAgICBpZiAoc3RvcFdpdGhVcGRhdGUpIHtcbiAgICAgICAgICAgIHVwZGF0ZUZ1bmMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50IHJlcGVhdGVkIGNhbGxzIHRvIHN0b3AgY2FsbGluZyBoYW5kbGVyLlxuICAgICAgICB1cGRhdGVGdW5jID0gbm9vcDtcbiAgICB9O1xuICAgIHVwZGF0ZUZ1bmMoKTtcbiAgICByZXR1cm4gc3RvcEZ1bmM7XG59XG5mdW5jdGlvbiBub29wKCkgeyB9XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJQcm9ncmVzc1RyYWNrZXIiLCJjb25zdHJ1Y3RvciIsImJ5dGVzT3ZlcmFsbCIsImludGVydmFsTXMiLCJvblN0b3AiLCJub29wIiwib25IYW5kbGUiLCJyZXBvcnRUbyIsInN0YXJ0Iiwic29ja2V0IiwibmFtZSIsInR5cGUiLCJsYXN0Qnl0ZXMiLCJwb2xsIiwiYnl0ZXMiLCJieXRlc1JlYWQiLCJieXRlc1dyaXR0ZW4iLCJzdG9wIiwidXBkYXRlQW5kU3RvcCIsInVwZGF0ZUZ1bmMiLCJpZCIsInNldEludGVydmFsIiwic3RvcEZ1bmMiLCJzdG9wV2l0aFVwZGF0ZSIsImNsZWFySW50ZXJ2YWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/basic-ftp/dist/ProgressTracker.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/basic-ftp/dist/StringEncoding.js":
/*!***********************************************************!*\
  !*** ../../node_modules/basic-ftp/dist/StringEncoding.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2ljLWZ0cC9kaXN0L1N0cmluZ0VuY29kaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9iYXNpYy1mdHAvZGlzdC9TdHJpbmdFbmNvZGluZy5qcz83M2MzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/basic-ftp/dist/StringEncoding.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/basic-ftp/dist/StringWriter.js":
/*!*********************************************************!*\
  !*** ../../node_modules/basic-ftp/dist/StringWriter.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.StringWriter = void 0;\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nclass StringWriter extends stream_1.Writable {\n    constructor(){\n        super(...arguments);\n        this.buf = Buffer.alloc(0);\n    }\n    _write(chunk, _, callback) {\n        if (chunk instanceof Buffer) {\n            this.buf = Buffer.concat([\n                this.buf,\n                chunk\n            ]);\n            callback(null);\n        } else {\n            callback(new Error(\"StringWriter expects chunks of type 'Buffer'.\"));\n        }\n    }\n    getText(encoding) {\n        return this.buf.toString(encoding);\n    }\n}\nexports.StringWriter = StringWriter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2ljLWZ0cC9kaXN0L1N0cmluZ1dyaXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsb0JBQW9CLEdBQUcsS0FBSztBQUM1QixNQUFNRyxXQUFXQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNRixxQkFBcUJDLFNBQVNFLFFBQVE7SUFDeENDLGFBQWM7UUFDVixLQUFLLElBQUlDO1FBQ1QsSUFBSSxDQUFDQyxHQUFHLEdBQUdDLE9BQU9DLEtBQUssQ0FBQztJQUM1QjtJQUNBQyxPQUFPQyxLQUFLLEVBQUVDLENBQUMsRUFBRUMsUUFBUSxFQUFFO1FBQ3ZCLElBQUlGLGlCQUFpQkgsUUFBUTtZQUN6QixJQUFJLENBQUNELEdBQUcsR0FBR0MsT0FBT00sTUFBTSxDQUFDO2dCQUFDLElBQUksQ0FBQ1AsR0FBRztnQkFBRUk7YUFBTTtZQUMxQ0UsU0FBUztRQUNiLE9BQ0s7WUFDREEsU0FBUyxJQUFJRSxNQUFNO1FBQ3ZCO0lBQ0o7SUFDQUMsUUFBUUMsUUFBUSxFQUFFO1FBQ2QsT0FBTyxJQUFJLENBQUNWLEdBQUcsQ0FBQ1csUUFBUSxDQUFDRDtJQUM3QjtBQUNKO0FBQ0FsQixvQkFBb0IsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2ljLWZ0cC9kaXN0L1N0cmluZ1dyaXRlci5qcz9kMjIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdHJpbmdXcml0ZXIgPSB2b2lkIDA7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jbGFzcyBTdHJpbmdXcml0ZXIgZXh0ZW5kcyBzdHJlYW1fMS5Xcml0YWJsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYnVmID0gQnVmZmVyLmFsbG9jKDApO1xuICAgIH1cbiAgICBfd3JpdGUoY2h1bmssIF8sIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjaHVuayBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5idWYgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmJ1ZiwgY2h1bmtdKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKFwiU3RyaW5nV3JpdGVyIGV4cGVjdHMgY2h1bmtzIG9mIHR5cGUgJ0J1ZmZlcicuXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRUZXh0KGVuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi50b1N0cmluZyhlbmNvZGluZyk7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJpbmdXcml0ZXIgPSBTdHJpbmdXcml0ZXI7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTdHJpbmdXcml0ZXIiLCJzdHJlYW1fMSIsInJlcXVpcmUiLCJXcml0YWJsZSIsImNvbnN0cnVjdG9yIiwiYXJndW1lbnRzIiwiYnVmIiwiQnVmZmVyIiwiYWxsb2MiLCJfd3JpdGUiLCJjaHVuayIsIl8iLCJjYWxsYmFjayIsImNvbmNhdCIsIkVycm9yIiwiZ2V0VGV4dCIsImVuY29kaW5nIiwidG9TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/basic-ftp/dist/StringWriter.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/basic-ftp/dist/index.js":
/*!**************************************************!*\
  !*** ../../node_modules/basic-ftp/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.enterPassiveModeIPv6 = exports.enterPassiveModeIPv4 = void 0;\n/**\n * Public API\n */ __exportStar(__webpack_require__(/*! ./Client */ \"(rsc)/../../node_modules/basic-ftp/dist/Client.js\"), exports);\n__exportStar(__webpack_require__(/*! ./FtpContext */ \"(rsc)/../../node_modules/basic-ftp/dist/FtpContext.js\"), exports);\n__exportStar(__webpack_require__(/*! ./FileInfo */ \"(rsc)/../../node_modules/basic-ftp/dist/FileInfo.js\"), exports);\n__exportStar(__webpack_require__(/*! ./parseList */ \"(rsc)/../../node_modules/basic-ftp/dist/parseList.js\"), exports);\n__exportStar(__webpack_require__(/*! ./StringEncoding */ \"(rsc)/../../node_modules/basic-ftp/dist/StringEncoding.js\"), exports);\nvar transfer_1 = __webpack_require__(/*! ./transfer */ \"(rsc)/../../node_modules/basic-ftp/dist/transfer.js\");\nObject.defineProperty(exports, \"enterPassiveModeIPv4\", ({\n    enumerable: true,\n    get: function() {\n        return transfer_1.enterPassiveModeIPv4;\n    }\n}));\nObject.defineProperty(exports, \"enterPassiveModeIPv6\", ({\n    enumerable: true,\n    get: function() {\n        return transfer_1.enterPassiveModeIPv6;\n    }\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2ljLWZ0cC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcsZUFBZSxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLFlBQVksSUFBSyxTQUFTWixDQUFDLEVBQUVhLFFBQU87SUFDakUsSUFBSyxJQUFJQyxLQUFLZCxFQUFHLElBQUljLE1BQU0sYUFBYSxDQUFDakIsT0FBT2tCLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFVBQVNDLElBQUlsQixnQkFBZ0JpQixVQUFTYixHQUFHYztBQUMzSDtBQUNBakIsOENBQTZDO0lBQUVxQixPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdETCw0QkFBNEIsR0FBR0EsNEJBQTRCLEdBQUcsS0FBSztBQUNuRTs7Q0FFQyxHQUNERCxhQUFhUyxtQkFBT0EsQ0FBQyxtRUFBVSxHQUFHUjtBQUNsQ0QsYUFBYVMsbUJBQU9BLENBQUMsMkVBQWMsR0FBR1I7QUFDdENELGFBQWFTLG1CQUFPQSxDQUFDLHVFQUFZLEdBQUdSO0FBQ3BDRCxhQUFhUyxtQkFBT0EsQ0FBQyx5RUFBYSxHQUFHUjtBQUNyQ0QsYUFBYVMsbUJBQU9BLENBQUMsbUZBQWtCLEdBQUdSO0FBQzFDLElBQUlTLGFBQWFELG1CQUFPQSxDQUFDLHVFQUFZO0FBQ3JDeEIsd0RBQXVEO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9ZLFdBQVdGLG9CQUFvQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzFJdkIsd0RBQXVEO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9ZLFdBQVdILG9CQUFvQjtJQUFFO0FBQUUsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9iYXNpYy1mdHAvZGlzdC9pbmRleC5qcz9lODJjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVudGVyUGFzc2l2ZU1vZGVJUHY2ID0gZXhwb3J0cy5lbnRlclBhc3NpdmVNb2RlSVB2NCA9IHZvaWQgMDtcbi8qKlxuICogUHVibGljIEFQSVxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ2xpZW50XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9GdHBDb250ZXh0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9GaWxlSW5mb1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcGFyc2VMaXN0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9TdHJpbmdFbmNvZGluZ1wiKSwgZXhwb3J0cyk7XG52YXIgdHJhbnNmZXJfMSA9IHJlcXVpcmUoXCIuL3RyYW5zZmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW50ZXJQYXNzaXZlTW9kZUlQdjRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zZmVyXzEuZW50ZXJQYXNzaXZlTW9kZUlQdjQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbnRlclBhc3NpdmVNb2RlSVB2NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnNmZXJfMS5lbnRlclBhc3NpdmVNb2RlSVB2NjsgfSB9KTtcbiJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2V4cG9ydFN0YXIiLCJleHBvcnRzIiwicCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInZhbHVlIiwiZW50ZXJQYXNzaXZlTW9kZUlQdjYiLCJlbnRlclBhc3NpdmVNb2RlSVB2NCIsInJlcXVpcmUiLCJ0cmFuc2Zlcl8xIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/basic-ftp/dist/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/basic-ftp/dist/netUtils.js":
/*!*****************************************************!*\
  !*** ../../node_modules/basic-ftp/dist/netUtils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.describeTLS = describeTLS;\nexports.describeAddress = describeAddress;\nexports.upgradeSocket = upgradeSocket;\nexports.ipIsPrivateV4Address = ipIsPrivateV4Address;\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\n/**\n * Returns a string describing the encryption on a given socket instance.\n */ function describeTLS(socket) {\n    if (socket instanceof tls_1.TLSSocket) {\n        const protocol = socket.getProtocol();\n        return protocol ? protocol : \"Server socket or disconnected client socket\";\n    }\n    return \"No encryption\";\n}\n/**\n * Returns a string describing the remote address of a socket.\n */ function describeAddress(socket) {\n    if (socket.remoteFamily === \"IPv6\") {\n        return `[${socket.remoteAddress}]:${socket.remotePort}`;\n    }\n    return `${socket.remoteAddress}:${socket.remotePort}`;\n}\n/**\n * Upgrade a socket connection with TLS.\n */ function upgradeSocket(socket, options) {\n    return new Promise((resolve, reject)=>{\n        const tlsOptions = Object.assign({}, options, {\n            socket\n        });\n        const tlsSocket = (0, tls_1.connect)(tlsOptions, ()=>{\n            const expectCertificate = tlsOptions.rejectUnauthorized !== false;\n            if (expectCertificate && !tlsSocket.authorized) {\n                reject(tlsSocket.authorizationError);\n            } else {\n                // Remove error listener added below.\n                tlsSocket.removeAllListeners(\"error\");\n                resolve(tlsSocket);\n            }\n        }).once(\"error\", (error)=>{\n            reject(error);\n        });\n    });\n}\n/**\n * Returns true if an IP is a private address according to https://tools.ietf.org/html/rfc1918#section-3.\n * This will handle IPv4-mapped IPv6 addresses correctly but return false for all other IPv6 addresses.\n *\n * @param ip  The IP as a string, e.g. \"192.168.0.1\"\n */ function ipIsPrivateV4Address(ip = \"\") {\n    // Handle IPv4-mapped IPv6 addresses like ::ffff:192.168.0.1\n    if (ip.startsWith(\"::ffff:\")) {\n        ip = ip.substr(7); // Strip ::ffff: prefix\n    }\n    const octets = ip.split(\".\").map((o)=>parseInt(o, 10));\n    return octets[0] === 10 // 10.0.0.0 - 10.255.255.255\n     || octets[0] === 172 && octets[1] >= 16 && octets[1] <= 31 // 172.16.0.0 - 172.31.255.255\n     || octets[0] === 192 && octets[1] === 168 // 192.168.0.0 - 192.168.255.255\n     || ip === \"127.0.0.1\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2ljLWZ0cC9kaXN0L25ldFV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQkFBbUIsR0FBR0U7QUFDdEJGLHVCQUF1QixHQUFHRztBQUMxQkgscUJBQXFCLEdBQUdJO0FBQ3hCSiw0QkFBNEIsR0FBR0s7QUFDL0IsTUFBTUMsUUFBUUMsbUJBQU9BLENBQUMsZ0JBQUs7QUFDM0I7O0NBRUMsR0FDRCxTQUFTTCxZQUFZTSxNQUFNO0lBQ3ZCLElBQUlBLGtCQUFrQkYsTUFBTUcsU0FBUyxFQUFFO1FBQ25DLE1BQU1DLFdBQVdGLE9BQU9HLFdBQVc7UUFDbkMsT0FBT0QsV0FBV0EsV0FBVztJQUNqQztJQUNBLE9BQU87QUFDWDtBQUNBOztDQUVDLEdBQ0QsU0FBU1AsZ0JBQWdCSyxNQUFNO0lBQzNCLElBQUlBLE9BQU9JLFlBQVksS0FBSyxRQUFRO1FBQ2hDLE9BQU8sQ0FBQyxDQUFDLEVBQUVKLE9BQU9LLGFBQWEsQ0FBQyxFQUFFLEVBQUVMLE9BQU9NLFVBQVUsQ0FBQyxDQUFDO0lBQzNEO0lBQ0EsT0FBTyxDQUFDLEVBQUVOLE9BQU9LLGFBQWEsQ0FBQyxDQUFDLEVBQUVMLE9BQU9NLFVBQVUsQ0FBQyxDQUFDO0FBQ3pEO0FBQ0E7O0NBRUMsR0FDRCxTQUFTVixjQUFjSSxNQUFNLEVBQUVPLE9BQU87SUFDbEMsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1FBQ3pCLE1BQU1DLGFBQWFyQixPQUFPc0IsTUFBTSxDQUFDLENBQUMsR0FBR0wsU0FBUztZQUMxQ1A7UUFDSjtRQUNBLE1BQU1hLFlBQVksQ0FBQyxHQUFHZixNQUFNZ0IsT0FBTyxFQUFFSCxZQUFZO1lBQzdDLE1BQU1JLG9CQUFvQkosV0FBV0ssa0JBQWtCLEtBQUs7WUFDNUQsSUFBSUQscUJBQXFCLENBQUNGLFVBQVVJLFVBQVUsRUFBRTtnQkFDNUNQLE9BQU9HLFVBQVVLLGtCQUFrQjtZQUN2QyxPQUNLO2dCQUNELHFDQUFxQztnQkFDckNMLFVBQVVNLGtCQUFrQixDQUFDO2dCQUM3QlYsUUFBUUk7WUFDWjtRQUNKLEdBQUdPLElBQUksQ0FBQyxTQUFTQyxDQUFBQTtZQUNiWCxPQUFPVztRQUNYO0lBQ0o7QUFDSjtBQUNBOzs7OztDQUtDLEdBQ0QsU0FBU3hCLHFCQUFxQnlCLEtBQUssRUFBRTtJQUNqQyw0REFBNEQ7SUFDNUQsSUFBSUEsR0FBR0MsVUFBVSxDQUFDLFlBQVk7UUFDMUJELEtBQUtBLEdBQUdFLE1BQU0sQ0FBQyxJQUFJLHVCQUF1QjtJQUM5QztJQUNBLE1BQU1DLFNBQVNILEdBQUdJLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUNDLENBQUFBLElBQUtDLFNBQVNELEdBQUc7SUFDbEQsT0FBT0gsTUFBTSxDQUFDLEVBQUUsS0FBSyxHQUFHLDRCQUE0QjtRQUM1Q0EsTUFBTSxDQUFDLEVBQUUsS0FBSyxPQUFPQSxNQUFNLENBQUMsRUFBRSxJQUFJLE1BQU1BLE1BQU0sQ0FBQyxFQUFFLElBQUksR0FBSSw4QkFBOEI7UUFDdkZBLE1BQU0sQ0FBQyxFQUFFLEtBQUssT0FBT0EsTUFBTSxDQUFDLEVBQUUsS0FBSyxJQUFLLGdDQUFnQztRQUN6RUgsT0FBTztBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvYmFzaWMtZnRwL2Rpc3QvbmV0VXRpbHMuanM/ZTJmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVzY3JpYmVUTFMgPSBkZXNjcmliZVRMUztcbmV4cG9ydHMuZGVzY3JpYmVBZGRyZXNzID0gZGVzY3JpYmVBZGRyZXNzO1xuZXhwb3J0cy51cGdyYWRlU29ja2V0ID0gdXBncmFkZVNvY2tldDtcbmV4cG9ydHMuaXBJc1ByaXZhdGVWNEFkZHJlc3MgPSBpcElzUHJpdmF0ZVY0QWRkcmVzcztcbmNvbnN0IHRsc18xID0gcmVxdWlyZShcInRsc1wiKTtcbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyBkZXNjcmliaW5nIHRoZSBlbmNyeXB0aW9uIG9uIGEgZ2l2ZW4gc29ja2V0IGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBkZXNjcmliZVRMUyhzb2NrZXQpIHtcbiAgICBpZiAoc29ja2V0IGluc3RhbmNlb2YgdGxzXzEuVExTU29ja2V0KSB7XG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gc29ja2V0LmdldFByb3RvY29sKCk7XG4gICAgICAgIHJldHVybiBwcm90b2NvbCA/IHByb3RvY29sIDogXCJTZXJ2ZXIgc29ja2V0IG9yIGRpc2Nvbm5lY3RlZCBjbGllbnQgc29ja2V0XCI7XG4gICAgfVxuICAgIHJldHVybiBcIk5vIGVuY3J5cHRpb25cIjtcbn1cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyBkZXNjcmliaW5nIHRoZSByZW1vdGUgYWRkcmVzcyBvZiBhIHNvY2tldC5cbiAqL1xuZnVuY3Rpb24gZGVzY3JpYmVBZGRyZXNzKHNvY2tldCkge1xuICAgIGlmIChzb2NrZXQucmVtb3RlRmFtaWx5ID09PSBcIklQdjZcIikge1xuICAgICAgICByZXR1cm4gYFske3NvY2tldC5yZW1vdGVBZGRyZXNzfV06JHtzb2NrZXQucmVtb3RlUG9ydH1gO1xuICAgIH1cbiAgICByZXR1cm4gYCR7c29ja2V0LnJlbW90ZUFkZHJlc3N9OiR7c29ja2V0LnJlbW90ZVBvcnR9YDtcbn1cbi8qKlxuICogVXBncmFkZSBhIHNvY2tldCBjb25uZWN0aW9uIHdpdGggVExTLlxuICovXG5mdW5jdGlvbiB1cGdyYWRlU29ja2V0KHNvY2tldCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHRsc09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICBzb2NrZXRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRsc1NvY2tldCA9ICgwLCB0bHNfMS5jb25uZWN0KSh0bHNPcHRpb25zLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RDZXJ0aWZpY2F0ZSA9IHRsc09wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkICE9PSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChleHBlY3RDZXJ0aWZpY2F0ZSAmJiAhdGxzU29ja2V0LmF1dGhvcml6ZWQpIHtcbiAgICAgICAgICAgICAgICByZWplY3QodGxzU29ja2V0LmF1dGhvcml6YXRpb25FcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZXJyb3IgbGlzdGVuZXIgYWRkZWQgYmVsb3cuXG4gICAgICAgICAgICAgICAgdGxzU29ja2V0LnJlbW92ZUFsbExpc3RlbmVycyhcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGxzU29ja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkub25jZShcImVycm9yXCIsIGVycm9yID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYW4gSVAgaXMgYSBwcml2YXRlIGFkZHJlc3MgYWNjb3JkaW5nIHRvIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxOTE4I3NlY3Rpb24tMy5cbiAqIFRoaXMgd2lsbCBoYW5kbGUgSVB2NC1tYXBwZWQgSVB2NiBhZGRyZXNzZXMgY29ycmVjdGx5IGJ1dCByZXR1cm4gZmFsc2UgZm9yIGFsbCBvdGhlciBJUHY2IGFkZHJlc3Nlcy5cbiAqXG4gKiBAcGFyYW0gaXAgIFRoZSBJUCBhcyBhIHN0cmluZywgZS5nLiBcIjE5Mi4xNjguMC4xXCJcbiAqL1xuZnVuY3Rpb24gaXBJc1ByaXZhdGVWNEFkZHJlc3MoaXAgPSBcIlwiKSB7XG4gICAgLy8gSGFuZGxlIElQdjQtbWFwcGVkIElQdjYgYWRkcmVzc2VzIGxpa2UgOjpmZmZmOjE5Mi4xNjguMC4xXG4gICAgaWYgKGlwLnN0YXJ0c1dpdGgoXCI6OmZmZmY6XCIpKSB7XG4gICAgICAgIGlwID0gaXAuc3Vic3RyKDcpOyAvLyBTdHJpcCA6OmZmZmY6IHByZWZpeFxuICAgIH1cbiAgICBjb25zdCBvY3RldHMgPSBpcC5zcGxpdChcIi5cIikubWFwKG8gPT4gcGFyc2VJbnQobywgMTApKTtcbiAgICByZXR1cm4gb2N0ZXRzWzBdID09PSAxMCAvLyAxMC4wLjAuMCAtIDEwLjI1NS4yNTUuMjU1XG4gICAgICAgIHx8IChvY3RldHNbMF0gPT09IDE3MiAmJiBvY3RldHNbMV0gPj0gMTYgJiYgb2N0ZXRzWzFdIDw9IDMxKSAvLyAxNzIuMTYuMC4wIC0gMTcyLjMxLjI1NS4yNTVcbiAgICAgICAgfHwgKG9jdGV0c1swXSA9PT0gMTkyICYmIG9jdGV0c1sxXSA9PT0gMTY4KSAvLyAxOTIuMTY4LjAuMCAtIDE5Mi4xNjguMjU1LjI1NVxuICAgICAgICB8fCBpcCA9PT0gXCIxMjcuMC4wLjFcIjtcbn1cbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlc2NyaWJlVExTIiwiZGVzY3JpYmVBZGRyZXNzIiwidXBncmFkZVNvY2tldCIsImlwSXNQcml2YXRlVjRBZGRyZXNzIiwidGxzXzEiLCJyZXF1aXJlIiwic29ja2V0IiwiVExTU29ja2V0IiwicHJvdG9jb2wiLCJnZXRQcm90b2NvbCIsInJlbW90ZUZhbWlseSIsInJlbW90ZUFkZHJlc3MiLCJyZW1vdGVQb3J0Iiwib3B0aW9ucyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwidGxzT3B0aW9ucyIsImFzc2lnbiIsInRsc1NvY2tldCIsImNvbm5lY3QiLCJleHBlY3RDZXJ0aWZpY2F0ZSIsInJlamVjdFVuYXV0aG9yaXplZCIsImF1dGhvcml6ZWQiLCJhdXRob3JpemF0aW9uRXJyb3IiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJvbmNlIiwiZXJyb3IiLCJpcCIsInN0YXJ0c1dpdGgiLCJzdWJzdHIiLCJvY3RldHMiLCJzcGxpdCIsIm1hcCIsIm8iLCJwYXJzZUludCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/basic-ftp/dist/netUtils.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/basic-ftp/dist/parseControlResponse.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/basic-ftp/dist/parseControlResponse.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.parseControlResponse = parseControlResponse;\nexports.isSingleLine = isSingleLine;\nexports.isMultiline = isMultiline;\nexports.positiveCompletion = positiveCompletion;\nexports.positiveIntermediate = positiveIntermediate;\nconst LF = \"\\n\";\n/**\n * Parse an FTP control response as a collection of messages. A message is a complete\n * single- or multiline response. A response can also contain multiple multiline responses\n * that will each be represented by a message. A response can also be incomplete\n * and be completed on the next incoming data chunk for which case this function also\n * describes a `rest`. This function converts all CRLF to LF.\n */ function parseControlResponse(text) {\n    const lines = text.split(/\\r?\\n/).filter(isNotBlank);\n    const messages = [];\n    let startAt = 0;\n    let tokenRegex;\n    for(let i = 0; i < lines.length; i++){\n        const line = lines[i];\n        // No group has been opened.\n        if (!tokenRegex) {\n            if (isMultiline(line)) {\n                // Open a group by setting an expected token.\n                const token = line.substr(0, 3);\n                tokenRegex = new RegExp(`^${token}(?:$| )`);\n                startAt = i;\n            } else if (isSingleLine(line)) {\n                // Single lines can be grouped immediately.\n                messages.push(line);\n            }\n        } else if (tokenRegex.test(line)) {\n            tokenRegex = undefined;\n            messages.push(lines.slice(startAt, i + 1).join(LF));\n        }\n    }\n    // The last group might not have been closed, report it as a rest.\n    const rest = tokenRegex ? lines.slice(startAt).join(LF) + LF : \"\";\n    return {\n        messages,\n        rest\n    };\n}\nfunction isSingleLine(line) {\n    return /^\\d\\d\\d(?:$| )/.test(line);\n}\nfunction isMultiline(line) {\n    return /^\\d\\d\\d-/.test(line);\n}\n/**\n * Return true if an FTP return code describes a positive completion.\n */ function positiveCompletion(code) {\n    return code >= 200 && code < 300;\n}\n/**\n * Return true if an FTP return code describes a positive intermediate response.\n */ function positiveIntermediate(code) {\n    return code >= 300 && code < 400;\n}\nfunction isNotBlank(str) {\n    return str.trim() !== \"\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2ljLWZ0cC9kaXN0L3BhcnNlQ29udHJvbFJlc3BvbnNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw0QkFBNEIsR0FBR0U7QUFDL0JGLG9CQUFvQixHQUFHRztBQUN2QkgsbUJBQW1CLEdBQUdJO0FBQ3RCSiwwQkFBMEIsR0FBR0s7QUFDN0JMLDRCQUE0QixHQUFHTTtBQUMvQixNQUFNQyxLQUFLO0FBQ1g7Ozs7OztDQU1DLEdBQ0QsU0FBU0wscUJBQXFCTSxJQUFJO0lBQzlCLE1BQU1DLFFBQVFELEtBQUtFLEtBQUssQ0FBQyxTQUFTQyxNQUFNLENBQUNDO0lBQ3pDLE1BQU1DLFdBQVcsRUFBRTtJQUNuQixJQUFJQyxVQUFVO0lBQ2QsSUFBSUM7SUFDSixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVAsTUFBTVEsTUFBTSxFQUFFRCxJQUFLO1FBQ25DLE1BQU1FLE9BQU9ULEtBQUssQ0FBQ08sRUFBRTtRQUNyQiw0QkFBNEI7UUFDNUIsSUFBSSxDQUFDRCxZQUFZO1lBQ2IsSUFBSVgsWUFBWWMsT0FBTztnQkFDbkIsNkNBQTZDO2dCQUM3QyxNQUFNQyxRQUFRRCxLQUFLRSxNQUFNLENBQUMsR0FBRztnQkFDN0JMLGFBQWEsSUFBSU0sT0FBTyxDQUFDLENBQUMsRUFBRUYsTUFBTSxPQUFPLENBQUM7Z0JBQzFDTCxVQUFVRTtZQUNkLE9BQ0ssSUFBSWIsYUFBYWUsT0FBTztnQkFDekIsMkNBQTJDO2dCQUMzQ0wsU0FBU1MsSUFBSSxDQUFDSjtZQUNsQjtRQUNKLE9BRUssSUFBSUgsV0FBV1EsSUFBSSxDQUFDTCxPQUFPO1lBQzVCSCxhQUFhUztZQUNiWCxTQUFTUyxJQUFJLENBQUNiLE1BQU1nQixLQUFLLENBQUNYLFNBQVNFLElBQUksR0FBR1UsSUFBSSxDQUFDbkI7UUFDbkQ7SUFDSjtJQUNBLGtFQUFrRTtJQUNsRSxNQUFNb0IsT0FBT1osYUFBYU4sTUFBTWdCLEtBQUssQ0FBQ1gsU0FBU1ksSUFBSSxDQUFDbkIsTUFBTUEsS0FBSztJQUMvRCxPQUFPO1FBQUVNO1FBQVVjO0lBQUs7QUFDNUI7QUFDQSxTQUFTeEIsYUFBYWUsSUFBSTtJQUN0QixPQUFPLGlCQUFpQkssSUFBSSxDQUFDTDtBQUNqQztBQUNBLFNBQVNkLFlBQVljLElBQUk7SUFDckIsT0FBTyxXQUFXSyxJQUFJLENBQUNMO0FBQzNCO0FBQ0E7O0NBRUMsR0FDRCxTQUFTYixtQkFBbUJ1QixJQUFJO0lBQzVCLE9BQU9BLFFBQVEsT0FBT0EsT0FBTztBQUNqQztBQUNBOztDQUVDLEdBQ0QsU0FBU3RCLHFCQUFxQnNCLElBQUk7SUFDOUIsT0FBT0EsUUFBUSxPQUFPQSxPQUFPO0FBQ2pDO0FBQ0EsU0FBU2hCLFdBQVdpQixHQUFHO0lBQ25CLE9BQU9BLElBQUlDLElBQUksT0FBTztBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvYmFzaWMtZnRwL2Rpc3QvcGFyc2VDb250cm9sUmVzcG9uc2UuanM/NjY4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VDb250cm9sUmVzcG9uc2UgPSBwYXJzZUNvbnRyb2xSZXNwb25zZTtcbmV4cG9ydHMuaXNTaW5nbGVMaW5lID0gaXNTaW5nbGVMaW5lO1xuZXhwb3J0cy5pc011bHRpbGluZSA9IGlzTXVsdGlsaW5lO1xuZXhwb3J0cy5wb3NpdGl2ZUNvbXBsZXRpb24gPSBwb3NpdGl2ZUNvbXBsZXRpb247XG5leHBvcnRzLnBvc2l0aXZlSW50ZXJtZWRpYXRlID0gcG9zaXRpdmVJbnRlcm1lZGlhdGU7XG5jb25zdCBMRiA9IFwiXFxuXCI7XG4vKipcbiAqIFBhcnNlIGFuIEZUUCBjb250cm9sIHJlc3BvbnNlIGFzIGEgY29sbGVjdGlvbiBvZiBtZXNzYWdlcy4gQSBtZXNzYWdlIGlzIGEgY29tcGxldGVcbiAqIHNpbmdsZS0gb3IgbXVsdGlsaW5lIHJlc3BvbnNlLiBBIHJlc3BvbnNlIGNhbiBhbHNvIGNvbnRhaW4gbXVsdGlwbGUgbXVsdGlsaW5lIHJlc3BvbnNlc1xuICogdGhhdCB3aWxsIGVhY2ggYmUgcmVwcmVzZW50ZWQgYnkgYSBtZXNzYWdlLiBBIHJlc3BvbnNlIGNhbiBhbHNvIGJlIGluY29tcGxldGVcbiAqIGFuZCBiZSBjb21wbGV0ZWQgb24gdGhlIG5leHQgaW5jb21pbmcgZGF0YSBjaHVuayBmb3Igd2hpY2ggY2FzZSB0aGlzIGZ1bmN0aW9uIGFsc29cbiAqIGRlc2NyaWJlcyBhIGByZXN0YC4gVGhpcyBmdW5jdGlvbiBjb252ZXJ0cyBhbGwgQ1JMRiB0byBMRi5cbiAqL1xuZnVuY3Rpb24gcGFyc2VDb250cm9sUmVzcG9uc2UodGV4dCkge1xuICAgIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdCgvXFxyP1xcbi8pLmZpbHRlcihpc05vdEJsYW5rKTtcbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGxldCBzdGFydEF0ID0gMDtcbiAgICBsZXQgdG9rZW5SZWdleDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgLy8gTm8gZ3JvdXAgaGFzIGJlZW4gb3BlbmVkLlxuICAgICAgICBpZiAoIXRva2VuUmVnZXgpIHtcbiAgICAgICAgICAgIGlmIChpc011bHRpbGluZShsaW5lKSkge1xuICAgICAgICAgICAgICAgIC8vIE9wZW4gYSBncm91cCBieSBzZXR0aW5nIGFuIGV4cGVjdGVkIHRva2VuLlxuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuID0gbGluZS5zdWJzdHIoMCwgMyk7XG4gICAgICAgICAgICAgICAgdG9rZW5SZWdleCA9IG5ldyBSZWdFeHAoYF4ke3Rva2VufSg/OiR8IClgKTtcbiAgICAgICAgICAgICAgICBzdGFydEF0ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU2luZ2xlTGluZShsaW5lKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpbmdsZSBsaW5lcyBjYW4gYmUgZ3JvdXBlZCBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgICAgICBtZXNzYWdlcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEdyb3VwIGhhcyBiZWVuIG9wZW5lZCwgZXhwZWN0IGNsb3NpbmcgdG9rZW4uXG4gICAgICAgIGVsc2UgaWYgKHRva2VuUmVnZXgudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgdG9rZW5SZWdleCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2gobGluZXMuc2xpY2Uoc3RhcnRBdCwgaSArIDEpLmpvaW4oTEYpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGUgbGFzdCBncm91cCBtaWdodCBub3QgaGF2ZSBiZWVuIGNsb3NlZCwgcmVwb3J0IGl0IGFzIGEgcmVzdC5cbiAgICBjb25zdCByZXN0ID0gdG9rZW5SZWdleCA/IGxpbmVzLnNsaWNlKHN0YXJ0QXQpLmpvaW4oTEYpICsgTEYgOiBcIlwiO1xuICAgIHJldHVybiB7IG1lc3NhZ2VzLCByZXN0IH07XG59XG5mdW5jdGlvbiBpc1NpbmdsZUxpbmUobGluZSkge1xuICAgIHJldHVybiAvXlxcZFxcZFxcZCg/OiR8ICkvLnRlc3QobGluZSk7XG59XG5mdW5jdGlvbiBpc011bHRpbGluZShsaW5lKSB7XG4gICAgcmV0dXJuIC9eXFxkXFxkXFxkLS8udGVzdChsaW5lKTtcbn1cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgYW4gRlRQIHJldHVybiBjb2RlIGRlc2NyaWJlcyBhIHBvc2l0aXZlIGNvbXBsZXRpb24uXG4gKi9cbmZ1bmN0aW9uIHBvc2l0aXZlQ29tcGxldGlvbihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gMjAwICYmIGNvZGUgPCAzMDA7XG59XG4vKipcbiAqIFJldHVybiB0cnVlIGlmIGFuIEZUUCByZXR1cm4gY29kZSBkZXNjcmliZXMgYSBwb3NpdGl2ZSBpbnRlcm1lZGlhdGUgcmVzcG9uc2UuXG4gKi9cbmZ1bmN0aW9uIHBvc2l0aXZlSW50ZXJtZWRpYXRlKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSAzMDAgJiYgY29kZSA8IDQwMDtcbn1cbmZ1bmN0aW9uIGlzTm90Qmxhbmsoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCkgIT09IFwiXCI7XG59XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwYXJzZUNvbnRyb2xSZXNwb25zZSIsImlzU2luZ2xlTGluZSIsImlzTXVsdGlsaW5lIiwicG9zaXRpdmVDb21wbGV0aW9uIiwicG9zaXRpdmVJbnRlcm1lZGlhdGUiLCJMRiIsInRleHQiLCJsaW5lcyIsInNwbGl0IiwiZmlsdGVyIiwiaXNOb3RCbGFuayIsIm1lc3NhZ2VzIiwic3RhcnRBdCIsInRva2VuUmVnZXgiLCJpIiwibGVuZ3RoIiwibGluZSIsInRva2VuIiwic3Vic3RyIiwiUmVnRXhwIiwicHVzaCIsInRlc3QiLCJ1bmRlZmluZWQiLCJzbGljZSIsImpvaW4iLCJyZXN0IiwiY29kZSIsInN0ciIsInRyaW0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/basic-ftp/dist/parseControlResponse.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/basic-ftp/dist/parseList.js":
/*!******************************************************!*\
  !*** ../../node_modules/basic-ftp/dist/parseList.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function() {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function(o) {\n            var ar = [];\n            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function(mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) {\n            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        }\n        __setModuleDefault(result, mod);\n        return result;\n    };\n}();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.parseList = parseList;\nconst dosParser = __importStar(__webpack_require__(/*! ./parseListDOS */ \"(rsc)/../../node_modules/basic-ftp/dist/parseListDOS.js\"));\nconst unixParser = __importStar(__webpack_require__(/*! ./parseListUnix */ \"(rsc)/../../node_modules/basic-ftp/dist/parseListUnix.js\"));\nconst mlsdParser = __importStar(__webpack_require__(/*! ./parseListMLSD */ \"(rsc)/../../node_modules/basic-ftp/dist/parseListMLSD.js\"));\n/**\n * Available directory listing parsers. These are candidates that will be tested\n * in the order presented. The first candidate will be used to parse the whole list.\n */ const availableParsers = [\n    dosParser,\n    unixParser,\n    mlsdParser // Keep MLSD last, may accept filename only\n];\nfunction firstCompatibleParser(line, parsers) {\n    return parsers.find((parser)=>parser.testLine(line) === true);\n}\nfunction isNotBlank(str) {\n    return str.trim() !== \"\";\n}\nfunction isNotMeta(str) {\n    return !str.startsWith(\"total\");\n}\nconst REGEX_NEWLINE = /\\r?\\n/;\n/**\n * Parse raw directory listing.\n */ function parseList(rawList) {\n    const lines = rawList.split(REGEX_NEWLINE).filter(isNotBlank).filter(isNotMeta);\n    if (lines.length === 0) {\n        return [];\n    }\n    const testLine = lines[lines.length - 1];\n    const parser = firstCompatibleParser(testLine, availableParsers);\n    if (!parser) {\n        throw new Error(\"This library only supports MLSD, Unix- or DOS-style directory listing. Your FTP server seems to be using another format. You can see the transmitted listing when setting `client.ftp.verbose = true`. You can then provide a custom parser to `client.parseList`, see the documentation for details.\");\n    }\n    const files = lines.map(parser.parseLine).filter((info)=>info !== undefined);\n    return parser.transformList(files);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2ljLWZ0cC9kaXN0L3BhcnNlTGlzdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLHFCQUFxQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGtCQUFrQixJQUFNZixDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFYyxDQUFDO0lBQ3pGaEIsT0FBT2MsY0FBYyxDQUFDWixHQUFHLFdBQVc7UUFBRVUsWUFBWTtRQUFNSyxPQUFPRDtJQUFFO0FBQ3JFLElBQUssU0FBU2QsQ0FBQyxFQUFFYyxDQUFDO0lBQ2RkLENBQUMsQ0FBQyxVQUFVLEdBQUdjO0FBQ25CO0FBQ0EsSUFBSUUsZUFBZSxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLFlBQVksSUFBSztJQUM5QyxJQUFJQyxVQUFVLFNBQVNqQixDQUFDO1FBQ3BCaUIsVUFBVW5CLE9BQU9vQixtQkFBbUIsSUFBSSxTQUFVbEIsQ0FBQztZQUMvQyxJQUFJbUIsS0FBSyxFQUFFO1lBQ1gsSUFBSyxJQUFJakIsS0FBS0YsRUFBRyxJQUFJRixPQUFPc0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ3RCLEdBQUdFLElBQUlpQixFQUFFLENBQUNBLEdBQUdJLE1BQU0sQ0FBQyxHQUFHckI7WUFDakYsT0FBT2lCO1FBQ1g7UUFDQSxPQUFPRixRQUFRakI7SUFDbkI7SUFDQSxPQUFPLFNBQVV3QixHQUFHO1FBQ2hCLElBQUlBLE9BQU9BLElBQUlqQixVQUFVLEVBQUUsT0FBT2lCO1FBQ2xDLElBQUlDLFNBQVMsQ0FBQztRQUNkLElBQUlELE9BQU8sTUFBTTtZQUFBLElBQUssSUFBSXRCLElBQUllLFFBQVFPLE1BQU1FLElBQUksR0FBR0EsSUFBSXhCLEVBQUVxQixNQUFNLEVBQUVHLElBQUssSUFBSXhCLENBQUMsQ0FBQ3dCLEVBQUUsS0FBSyxXQUFXN0IsZ0JBQWdCNEIsUUFBUUQsS0FBS3RCLENBQUMsQ0FBQ3dCLEVBQUU7UUFBQztRQUNoSWIsbUJBQW1CWSxRQUFRRDtRQUMzQixPQUFPQztJQUNYO0FBQ0o7QUFDQTNCLDhDQUE2QztJQUFFaUIsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RFksaUJBQWlCLEdBQUdDO0FBQ3BCLE1BQU1DLFlBQVliLGFBQWFjLG1CQUFPQSxDQUFDLCtFQUFnQjtBQUN2RCxNQUFNQyxhQUFhZixhQUFhYyxtQkFBT0EsQ0FBQyxpRkFBaUI7QUFDekQsTUFBTUUsYUFBYWhCLGFBQWFjLG1CQUFPQSxDQUFDLGlGQUFpQjtBQUN6RDs7O0NBR0MsR0FDRCxNQUFNRyxtQkFBbUI7SUFDckJKO0lBQ0FFO0lBQ0FDLFdBQVcsMkNBQTJDO0NBQ3pEO0FBQ0QsU0FBU0Usc0JBQXNCQyxJQUFJLEVBQUVDLE9BQU87SUFDeEMsT0FBT0EsUUFBUUMsSUFBSSxDQUFDQyxDQUFBQSxTQUFVQSxPQUFPQyxRQUFRLENBQUNKLFVBQVU7QUFDNUQ7QUFDQSxTQUFTSyxXQUFXQyxHQUFHO0lBQ25CLE9BQU9BLElBQUlDLElBQUksT0FBTztBQUMxQjtBQUNBLFNBQVNDLFVBQVVGLEdBQUc7SUFDbEIsT0FBTyxDQUFDQSxJQUFJRyxVQUFVLENBQUM7QUFDM0I7QUFDQSxNQUFNQyxnQkFBZ0I7QUFDdEI7O0NBRUMsR0FDRCxTQUFTakIsVUFBVWtCLE9BQU87SUFDdEIsTUFBTUMsUUFBUUQsUUFDVEUsS0FBSyxDQUFDSCxlQUNOSSxNQUFNLENBQUNULFlBQ1BTLE1BQU0sQ0FBQ047SUFDWixJQUFJSSxNQUFNeEIsTUFBTSxLQUFLLEdBQUc7UUFDcEIsT0FBTyxFQUFFO0lBQ2I7SUFDQSxNQUFNZ0IsV0FBV1EsS0FBSyxDQUFDQSxNQUFNeEIsTUFBTSxHQUFHLEVBQUU7SUFDeEMsTUFBTWUsU0FBU0osc0JBQXNCSyxVQUFVTjtJQUMvQyxJQUFJLENBQUNLLFFBQVE7UUFDVCxNQUFNLElBQUlZLE1BQU07SUFDcEI7SUFDQSxNQUFNQyxRQUFRSixNQUNUSyxHQUFHLENBQUNkLE9BQU9lLFNBQVMsRUFDcEJKLE1BQU0sQ0FBQyxDQUFDSyxPQUFTQSxTQUFTbEQ7SUFDL0IsT0FBT2tDLE9BQU9pQixhQUFhLENBQUNKO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9iYXNpYy1mdHAvZGlzdC9wYXJzZUxpc3QuanM/NzFlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZUxpc3QgPSBwYXJzZUxpc3Q7XG5jb25zdCBkb3NQYXJzZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vcGFyc2VMaXN0RE9TXCIpKTtcbmNvbnN0IHVuaXhQYXJzZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vcGFyc2VMaXN0VW5peFwiKSk7XG5jb25zdCBtbHNkUGFyc2VyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3BhcnNlTGlzdE1MU0RcIikpO1xuLyoqXG4gKiBBdmFpbGFibGUgZGlyZWN0b3J5IGxpc3RpbmcgcGFyc2Vycy4gVGhlc2UgYXJlIGNhbmRpZGF0ZXMgdGhhdCB3aWxsIGJlIHRlc3RlZFxuICogaW4gdGhlIG9yZGVyIHByZXNlbnRlZC4gVGhlIGZpcnN0IGNhbmRpZGF0ZSB3aWxsIGJlIHVzZWQgdG8gcGFyc2UgdGhlIHdob2xlIGxpc3QuXG4gKi9cbmNvbnN0IGF2YWlsYWJsZVBhcnNlcnMgPSBbXG4gICAgZG9zUGFyc2VyLFxuICAgIHVuaXhQYXJzZXIsXG4gICAgbWxzZFBhcnNlciAvLyBLZWVwIE1MU0QgbGFzdCwgbWF5IGFjY2VwdCBmaWxlbmFtZSBvbmx5XG5dO1xuZnVuY3Rpb24gZmlyc3RDb21wYXRpYmxlUGFyc2VyKGxpbmUsIHBhcnNlcnMpIHtcbiAgICByZXR1cm4gcGFyc2Vycy5maW5kKHBhcnNlciA9PiBwYXJzZXIudGVzdExpbmUobGluZSkgPT09IHRydWUpO1xufVxuZnVuY3Rpb24gaXNOb3RCbGFuayhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRyaW0oKSAhPT0gXCJcIjtcbn1cbmZ1bmN0aW9uIGlzTm90TWV0YShzdHIpIHtcbiAgICByZXR1cm4gIXN0ci5zdGFydHNXaXRoKFwidG90YWxcIik7XG59XG5jb25zdCBSRUdFWF9ORVdMSU5FID0gL1xccj9cXG4vO1xuLyoqXG4gKiBQYXJzZSByYXcgZGlyZWN0b3J5IGxpc3RpbmcuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTGlzdChyYXdMaXN0KSB7XG4gICAgY29uc3QgbGluZXMgPSByYXdMaXN0XG4gICAgICAgIC5zcGxpdChSRUdFWF9ORVdMSU5FKVxuICAgICAgICAuZmlsdGVyKGlzTm90QmxhbmspXG4gICAgICAgIC5maWx0ZXIoaXNOb3RNZXRhKTtcbiAgICBpZiAobGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgdGVzdExpbmUgPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBwYXJzZXIgPSBmaXJzdENvbXBhdGlibGVQYXJzZXIodGVzdExpbmUsIGF2YWlsYWJsZVBhcnNlcnMpO1xuICAgIGlmICghcGFyc2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbGlicmFyeSBvbmx5IHN1cHBvcnRzIE1MU0QsIFVuaXgtIG9yIERPUy1zdHlsZSBkaXJlY3RvcnkgbGlzdGluZy4gWW91ciBGVFAgc2VydmVyIHNlZW1zIHRvIGJlIHVzaW5nIGFub3RoZXIgZm9ybWF0LiBZb3UgY2FuIHNlZSB0aGUgdHJhbnNtaXR0ZWQgbGlzdGluZyB3aGVuIHNldHRpbmcgYGNsaWVudC5mdHAudmVyYm9zZSA9IHRydWVgLiBZb3UgY2FuIHRoZW4gcHJvdmlkZSBhIGN1c3RvbSBwYXJzZXIgdG8gYGNsaWVudC5wYXJzZUxpc3RgLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuXCIpO1xuICAgIH1cbiAgICBjb25zdCBmaWxlcyA9IGxpbmVzXG4gICAgICAgIC5tYXAocGFyc2VyLnBhcnNlTGluZSlcbiAgICAgICAgLmZpbHRlcigoaW5mbykgPT4gaW5mbyAhPT0gdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gcGFyc2VyLnRyYW5zZm9ybUxpc3QoZmlsZXMpO1xufVxuIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsInYiLCJ2YWx1ZSIsIl9faW1wb3J0U3RhciIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiYXIiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJsZW5ndGgiLCJtb2QiLCJyZXN1bHQiLCJpIiwiZXhwb3J0cyIsInBhcnNlTGlzdCIsImRvc1BhcnNlciIsInJlcXVpcmUiLCJ1bml4UGFyc2VyIiwibWxzZFBhcnNlciIsImF2YWlsYWJsZVBhcnNlcnMiLCJmaXJzdENvbXBhdGlibGVQYXJzZXIiLCJsaW5lIiwicGFyc2VycyIsImZpbmQiLCJwYXJzZXIiLCJ0ZXN0TGluZSIsImlzTm90QmxhbmsiLCJzdHIiLCJ0cmltIiwiaXNOb3RNZXRhIiwic3RhcnRzV2l0aCIsIlJFR0VYX05FV0xJTkUiLCJyYXdMaXN0IiwibGluZXMiLCJzcGxpdCIsImZpbHRlciIsIkVycm9yIiwiZmlsZXMiLCJtYXAiLCJwYXJzZUxpbmUiLCJpbmZvIiwidHJhbnNmb3JtTGlzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/basic-ftp/dist/parseList.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/basic-ftp/dist/parseListDOS.js":
/*!*********************************************************!*\
  !*** ../../node_modules/basic-ftp/dist/parseListDOS.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.testLine = testLine;\nexports.parseLine = parseLine;\nexports.transformList = transformList;\nconst FileInfo_1 = __webpack_require__(/*! ./FileInfo */ \"(rsc)/../../node_modules/basic-ftp/dist/FileInfo.js\");\n/**\n * This parser is based on the FTP client library source code in Apache Commons Net provided\n * under the Apache 2.0 license. It has been simplified and rewritten to better fit the Javascript language.\n *\n * https://github.com/apache/commons-net/blob/master/src/main/java/org/apache/commons/net/ftp/parser/NTFTPEntryParser.java\n */ const RE_LINE = new RegExp(\"(\\\\S+)\\\\s+(\\\\S+)\\\\s+\" // MM-dd-yy whitespace hh:mma|kk:mm swallow trailing spaces\n + \"(?:(<DIR>)|([0-9]+))\\\\s+\" // <DIR> or ddddd swallow trailing spaces\n + \"(\\\\S.*)\" // First non-space followed by rest of line (name)\n);\n/**\n * Returns true if a given line might be a DOS-style listing.\n *\n * - Example: `12-05-96  05:03PM       <DIR>          myDir`\n */ function testLine(line) {\n    return /^\\d{2}/.test(line) && RE_LINE.test(line);\n}\n/**\n * Parse a single line of a DOS-style directory listing.\n */ function parseLine(line) {\n    const groups = line.match(RE_LINE);\n    if (groups === null) {\n        return undefined;\n    }\n    const name = groups[5];\n    if (name === \".\" || name === \"..\") {\n        return undefined;\n    }\n    const file = new FileInfo_1.FileInfo(name);\n    const fileType = groups[3];\n    if (fileType === \"<DIR>\") {\n        file.type = FileInfo_1.FileType.Directory;\n        file.size = 0;\n    } else {\n        file.type = FileInfo_1.FileType.File;\n        file.size = parseInt(groups[4], 10);\n    }\n    file.rawModifiedAt = groups[1] + \" \" + groups[2];\n    return file;\n}\nfunction transformList(files) {\n    return files;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2ljLWZ0cC9kaXN0L3BhcnNlTGlzdERPUy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0JBQWdCLEdBQUdFO0FBQ25CRixpQkFBaUIsR0FBR0c7QUFDcEJILHFCQUFxQixHQUFHSTtBQUN4QixNQUFNQyxhQUFhQyxtQkFBT0EsQ0FBQyx1RUFBWTtBQUN2Qzs7Ozs7Q0FLQyxHQUNELE1BQU1DLFVBQVUsSUFBSUMsT0FBTyx1QkFBdUIsMkRBQTJEO0dBQ3ZHLDJCQUEyQix5Q0FBeUM7R0FDcEUsVUFBVSxrREFBa0Q7O0FBRWxFOzs7O0NBSUMsR0FDRCxTQUFTTixTQUFTTyxJQUFJO0lBQ2xCLE9BQU8sU0FBU0MsSUFBSSxDQUFDRCxTQUFTRixRQUFRRyxJQUFJLENBQUNEO0FBQy9DO0FBQ0E7O0NBRUMsR0FDRCxTQUFTTixVQUFVTSxJQUFJO0lBQ25CLE1BQU1FLFNBQVNGLEtBQUtHLEtBQUssQ0FBQ0w7SUFDMUIsSUFBSUksV0FBVyxNQUFNO1FBQ2pCLE9BQU9FO0lBQ1g7SUFDQSxNQUFNQyxPQUFPSCxNQUFNLENBQUMsRUFBRTtJQUN0QixJQUFJRyxTQUFTLE9BQU9BLFNBQVMsTUFBTTtRQUMvQixPQUFPRDtJQUNYO0lBQ0EsTUFBTUUsT0FBTyxJQUFJVixXQUFXVyxRQUFRLENBQUNGO0lBQ3JDLE1BQU1HLFdBQVdOLE1BQU0sQ0FBQyxFQUFFO0lBQzFCLElBQUlNLGFBQWEsU0FBUztRQUN0QkYsS0FBS0csSUFBSSxHQUFHYixXQUFXYyxRQUFRLENBQUNDLFNBQVM7UUFDekNMLEtBQUtNLElBQUksR0FBRztJQUNoQixPQUNLO1FBQ0ROLEtBQUtHLElBQUksR0FBR2IsV0FBV2MsUUFBUSxDQUFDRyxJQUFJO1FBQ3BDUCxLQUFLTSxJQUFJLEdBQUdFLFNBQVNaLE1BQU0sQ0FBQyxFQUFFLEVBQUU7SUFDcEM7SUFDQUksS0FBS1MsYUFBYSxHQUFHYixNQUFNLENBQUMsRUFBRSxHQUFHLE1BQU1BLE1BQU0sQ0FBQyxFQUFFO0lBQ2hELE9BQU9JO0FBQ1g7QUFDQSxTQUFTWCxjQUFjcUIsS0FBSztJQUN4QixPQUFPQTtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9iYXNpYy1mdHAvZGlzdC9wYXJzZUxpc3RET1MuanM/M2U5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudGVzdExpbmUgPSB0ZXN0TGluZTtcbmV4cG9ydHMucGFyc2VMaW5lID0gcGFyc2VMaW5lO1xuZXhwb3J0cy50cmFuc2Zvcm1MaXN0ID0gdHJhbnNmb3JtTGlzdDtcbmNvbnN0IEZpbGVJbmZvXzEgPSByZXF1aXJlKFwiLi9GaWxlSW5mb1wiKTtcbi8qKlxuICogVGhpcyBwYXJzZXIgaXMgYmFzZWQgb24gdGhlIEZUUCBjbGllbnQgbGlicmFyeSBzb3VyY2UgY29kZSBpbiBBcGFjaGUgQ29tbW9ucyBOZXQgcHJvdmlkZWRcbiAqIHVuZGVyIHRoZSBBcGFjaGUgMi4wIGxpY2Vuc2UuIEl0IGhhcyBiZWVuIHNpbXBsaWZpZWQgYW5kIHJld3JpdHRlbiB0byBiZXR0ZXIgZml0IHRoZSBKYXZhc2NyaXB0IGxhbmd1YWdlLlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcGFjaGUvY29tbW9ucy1uZXQvYmxvYi9tYXN0ZXIvc3JjL21haW4vamF2YS9vcmcvYXBhY2hlL2NvbW1vbnMvbmV0L2Z0cC9wYXJzZXIvTlRGVFBFbnRyeVBhcnNlci5qYXZhXG4gKi9cbmNvbnN0IFJFX0xJTkUgPSBuZXcgUmVnRXhwKFwiKFxcXFxTKylcXFxccysoXFxcXFMrKVxcXFxzK1wiIC8vIE1NLWRkLXl5IHdoaXRlc3BhY2UgaGg6bW1hfGtrOm1tIHN3YWxsb3cgdHJhaWxpbmcgc3BhY2VzXG4gICAgKyBcIig/Oig8RElSPil8KFswLTldKykpXFxcXHMrXCIgLy8gPERJUj4gb3IgZGRkZGQgc3dhbGxvdyB0cmFpbGluZyBzcGFjZXNcbiAgICArIFwiKFxcXFxTLiopXCIgLy8gRmlyc3Qgbm9uLXNwYWNlIGZvbGxvd2VkIGJ5IHJlc3Qgb2YgbGluZSAobmFtZSlcbik7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIGdpdmVuIGxpbmUgbWlnaHQgYmUgYSBET1Mtc3R5bGUgbGlzdGluZy5cbiAqXG4gKiAtIEV4YW1wbGU6IGAxMi0wNS05NiAgMDU6MDNQTSAgICAgICA8RElSPiAgICAgICAgICBteURpcmBcbiAqL1xuZnVuY3Rpb24gdGVzdExpbmUobGluZSkge1xuICAgIHJldHVybiAvXlxcZHsyfS8udGVzdChsaW5lKSAmJiBSRV9MSU5FLnRlc3QobGluZSk7XG59XG4vKipcbiAqIFBhcnNlIGEgc2luZ2xlIGxpbmUgb2YgYSBET1Mtc3R5bGUgZGlyZWN0b3J5IGxpc3RpbmcuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTGluZShsaW5lKSB7XG4gICAgY29uc3QgZ3JvdXBzID0gbGluZS5tYXRjaChSRV9MSU5FKTtcbiAgICBpZiAoZ3JvdXBzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSBncm91cHNbNV07XG4gICAgaWYgKG5hbWUgPT09IFwiLlwiIHx8IG5hbWUgPT09IFwiLi5cIikgeyAvLyBJZ25vcmUgcGFyZW50IGRpcmVjdG9yeSBsaW5rc1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBmaWxlID0gbmV3IEZpbGVJbmZvXzEuRmlsZUluZm8obmFtZSk7XG4gICAgY29uc3QgZmlsZVR5cGUgPSBncm91cHNbM107XG4gICAgaWYgKGZpbGVUeXBlID09PSBcIjxESVI+XCIpIHtcbiAgICAgICAgZmlsZS50eXBlID0gRmlsZUluZm9fMS5GaWxlVHlwZS5EaXJlY3Rvcnk7XG4gICAgICAgIGZpbGUuc2l6ZSA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmaWxlLnR5cGUgPSBGaWxlSW5mb18xLkZpbGVUeXBlLkZpbGU7XG4gICAgICAgIGZpbGUuc2l6ZSA9IHBhcnNlSW50KGdyb3Vwc1s0XSwgMTApO1xuICAgIH1cbiAgICBmaWxlLnJhd01vZGlmaWVkQXQgPSBncm91cHNbMV0gKyBcIiBcIiArIGdyb3Vwc1syXTtcbiAgICByZXR1cm4gZmlsZTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUxpc3QoZmlsZXMpIHtcbiAgICByZXR1cm4gZmlsZXM7XG59XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ0ZXN0TGluZSIsInBhcnNlTGluZSIsInRyYW5zZm9ybUxpc3QiLCJGaWxlSW5mb18xIiwicmVxdWlyZSIsIlJFX0xJTkUiLCJSZWdFeHAiLCJsaW5lIiwidGVzdCIsImdyb3VwcyIsIm1hdGNoIiwidW5kZWZpbmVkIiwibmFtZSIsImZpbGUiLCJGaWxlSW5mbyIsImZpbGVUeXBlIiwidHlwZSIsIkZpbGVUeXBlIiwiRGlyZWN0b3J5Iiwic2l6ZSIsIkZpbGUiLCJwYXJzZUludCIsInJhd01vZGlmaWVkQXQiLCJmaWxlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/basic-ftp/dist/parseListDOS.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/basic-ftp/dist/parseListMLSD.js":
/*!**********************************************************!*\
  !*** ../../node_modules/basic-ftp/dist/parseListMLSD.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.testLine = testLine;\nexports.parseLine = parseLine;\nexports.transformList = transformList;\nexports.parseMLSxDate = parseMLSxDate;\nconst FileInfo_1 = __webpack_require__(/*! ./FileInfo */ \"(rsc)/../../node_modules/basic-ftp/dist/FileInfo.js\");\nfunction parseSize(value, info) {\n    info.size = parseInt(value, 10);\n}\n/**\n * Parsers for MLSD facts.\n */ const factHandlersByName = {\n    \"size\": parseSize,\n    \"sizd\": parseSize,\n    \"unique\": (value, info)=>{\n        info.uniqueID = value;\n    },\n    \"modify\": (value, info)=>{\n        info.modifiedAt = parseMLSxDate(value);\n        info.rawModifiedAt = info.modifiedAt.toISOString();\n    },\n    \"type\": (value, info)=>{\n        // There seems to be confusion on how to handle symbolic links for Unix. RFC 3659 doesn't describe\n        // this but mentions some examples using the syntax `type=OS.unix=slink:<target>`. But according to\n        // an entry in the Errata (https://www.rfc-editor.org/errata/eid1500) this syntax can't be valid.\n        // Instead it proposes to use `type=OS.unix=symlink` and to then list the actual target of the\n        // symbolic link as another entry in the directory listing. The unique identifiers can then be used\n        // to derive the connection between link(s) and target. We'll have to handle both cases as there\n        // are differing opinions on how to deal with this. Here are some links on this topic:\n        // - ProFTPD source: https://github.com/proftpd/proftpd/blob/56e6dfa598cbd4ef5c6cba439bcbcd53a63e3b21/modules/mod_facts.c#L531\n        // - ProFTPD bug: http://bugs.proftpd.org/show_bug.cgi?id=3318\n        // - ProFTPD statement: http://www.proftpd.org/docs/modules/mod_facts.html\n        // â€“ FileZilla bug: https://trac.filezilla-project.org/ticket/9310\n        if (value.startsWith(\"OS.unix=slink\")) {\n            info.type = FileInfo_1.FileType.SymbolicLink;\n            info.link = value.substr(value.indexOf(\":\") + 1);\n            return 1 /* FactHandlerResult.Continue */ ;\n        }\n        switch(value){\n            case \"file\":\n                info.type = FileInfo_1.FileType.File;\n                break;\n            case \"dir\":\n                info.type = FileInfo_1.FileType.Directory;\n                break;\n            case \"OS.unix=symlink\":\n                info.type = FileInfo_1.FileType.SymbolicLink;\n                break;\n            case \"cdir\":\n            case \"pdir\":\n                return 2 /* FactHandlerResult.IgnoreFile */ ; // Don't include these entries in the listing\n            default:\n                info.type = FileInfo_1.FileType.Unknown;\n        }\n        return 1 /* FactHandlerResult.Continue */ ;\n    },\n    \"unix.mode\": (value, info)=>{\n        const digits = value.substr(-3);\n        info.permissions = {\n            user: parseInt(digits[0], 10),\n            group: parseInt(digits[1], 10),\n            world: parseInt(digits[2], 10)\n        };\n    },\n    \"unix.ownername\": (value, info)=>{\n        info.user = value;\n    },\n    \"unix.owner\": (value, info)=>{\n        if (info.user === undefined) info.user = value;\n    },\n    get \"unix.uid\" () {\n        return this[\"unix.owner\"];\n    },\n    \"unix.groupname\": (value, info)=>{\n        info.group = value;\n    },\n    \"unix.group\": (value, info)=>{\n        if (info.group === undefined) info.group = value;\n    },\n    get \"unix.gid\" () {\n        return this[\"unix.group\"];\n    }\n};\n/**\n * Split a string once at the first position of a delimiter. For example\n * `splitStringOnce(\"a b c d\", \" \")` returns `[\"a\", \"b c d\"]`.\n */ function splitStringOnce(str, delimiter) {\n    const pos = str.indexOf(delimiter);\n    const a = str.substr(0, pos);\n    const b = str.substr(pos + delimiter.length);\n    return [\n        a,\n        b\n    ];\n}\n/**\n * Returns true if a given line might be part of an MLSD listing.\n *\n * - Example 1: `size=15227;type=dir;perm=el;modify=20190419065730; test one`\n * - Example 2: ` file name` (leading space)\n */ function testLine(line) {\n    return /^\\S+=\\S+;/.test(line) || line.startsWith(\" \");\n}\n/**\n * Parse single line as MLSD listing, see specification at https://tools.ietf.org/html/rfc3659#section-7.\n */ function parseLine(line) {\n    const [packedFacts, name] = splitStringOnce(line, \" \");\n    if (name === \"\" || name === \".\" || name === \"..\") {\n        return undefined;\n    }\n    const info = new FileInfo_1.FileInfo(name);\n    const facts = packedFacts.split(\";\");\n    for (const fact of facts){\n        const [factName, factValue] = splitStringOnce(fact, \"=\");\n        if (!factValue) {\n            continue;\n        }\n        const factHandler = factHandlersByName[factName.toLowerCase()];\n        if (!factHandler) {\n            continue;\n        }\n        const result = factHandler(factValue, info);\n        if (result === 2 /* FactHandlerResult.IgnoreFile */ ) {\n            return undefined;\n        }\n    }\n    return info;\n}\nfunction transformList(files) {\n    // Create a map of all files that are not symbolic links by their unique ID\n    const nonLinksByID = new Map();\n    for (const file of files){\n        if (!file.isSymbolicLink && file.uniqueID !== undefined) {\n            nonLinksByID.set(file.uniqueID, file);\n        }\n    }\n    const resolvedFiles = [];\n    for (const file of files){\n        // Try to associate unresolved symbolic links with a target file/directory.\n        if (file.isSymbolicLink && file.uniqueID !== undefined && file.link === undefined) {\n            const target = nonLinksByID.get(file.uniqueID);\n            if (target !== undefined) {\n                file.link = target.name;\n            }\n        }\n        // The target of a symbolic link is listed as an entry in the directory listing but might\n        // have a path pointing outside of this directory. In that case we don't want this entry\n        // to be part of the listing. We generally don't want these kind of entries at all.\n        const isPartOfDirectory = !file.name.includes(\"/\");\n        if (isPartOfDirectory) {\n            resolvedFiles.push(file);\n        }\n    }\n    return resolvedFiles;\n}\n/**\n * Parse date as specified in https://tools.ietf.org/html/rfc3659#section-2.3.\n *\n * Message contains response code and modified time in the format: YYYYMMDDHHMMSS[.sss]\n * For example `19991005213102` or `19980615100045.014`.\n */ function parseMLSxDate(fact) {\n    return new Date(Date.UTC(+fact.slice(0, 4), +fact.slice(4, 6) - 1, +fact.slice(6, 8), +fact.slice(8, 10), +fact.slice(10, 12), +fact.slice(12, 14), +fact.slice(15, 18) // Milliseconds\n    ));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2ljLWZ0cC9kaXN0L3BhcnNlTGlzdE1MU0QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdCQUFnQixHQUFHRTtBQUNuQkYsaUJBQWlCLEdBQUdHO0FBQ3BCSCxxQkFBcUIsR0FBR0k7QUFDeEJKLHFCQUFxQixHQUFHSztBQUN4QixNQUFNQyxhQUFhQyxtQkFBT0EsQ0FBQyx1RUFBWTtBQUN2QyxTQUFTQyxVQUFVUCxLQUFLLEVBQUVRLElBQUk7SUFDMUJBLEtBQUtDLElBQUksR0FBR0MsU0FBU1YsT0FBTztBQUNoQztBQUNBOztDQUVDLEdBQ0QsTUFBTVcscUJBQXFCO0lBQ3ZCLFFBQVFKO0lBQ1IsUUFBUUE7SUFDUixVQUFVLENBQUNQLE9BQU9RO1FBQ2RBLEtBQUtJLFFBQVEsR0FBR1o7SUFDcEI7SUFDQSxVQUFVLENBQUNBLE9BQU9RO1FBQ2RBLEtBQUtLLFVBQVUsR0FBR1QsY0FBY0o7UUFDaENRLEtBQUtNLGFBQWEsR0FBR04sS0FBS0ssVUFBVSxDQUFDRSxXQUFXO0lBQ3BEO0lBQ0EsUUFBUSxDQUFDZixPQUFPUTtRQUNaLGtHQUFrRztRQUNsRyxtR0FBbUc7UUFDbkcsaUdBQWlHO1FBQ2pHLDhGQUE4RjtRQUM5RixtR0FBbUc7UUFDbkcsZ0dBQWdHO1FBQ2hHLHNGQUFzRjtRQUN0Riw4SEFBOEg7UUFDOUgsOERBQThEO1FBQzlELDBFQUEwRTtRQUMxRSxrRUFBa0U7UUFDbEUsSUFBSVIsTUFBTWdCLFVBQVUsQ0FBQyxrQkFBa0I7WUFDbkNSLEtBQUtTLElBQUksR0FBR1osV0FBV2EsUUFBUSxDQUFDQyxZQUFZO1lBQzVDWCxLQUFLWSxJQUFJLEdBQUdwQixNQUFNcUIsTUFBTSxDQUFDckIsTUFBTXNCLE9BQU8sQ0FBQyxPQUFPO1lBQzlDLE9BQU8sRUFBRSw4QkFBOEI7UUFDM0M7UUFDQSxPQUFRdEI7WUFDSixLQUFLO2dCQUNE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cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9iYXNpYy1mdHAvZGlzdC9wYXJzZUxpc3RNTFNELmpzPzJlNmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRlc3RMaW5lID0gdGVzdExpbmU7XG5leHBvcnRzLnBhcnNlTGluZSA9IHBhcnNlTGluZTtcbmV4cG9ydHMudHJhbnNmb3JtTGlzdCA9IHRyYW5zZm9ybUxpc3Q7XG5leHBvcnRzLnBhcnNlTUxTeERhdGUgPSBwYXJzZU1MU3hEYXRlO1xuY29uc3QgRmlsZUluZm9fMSA9IHJlcXVpcmUoXCIuL0ZpbGVJbmZvXCIpO1xuZnVuY3Rpb24gcGFyc2VTaXplKHZhbHVlLCBpbmZvKSB7XG4gICAgaW5mby5zaXplID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbn1cbi8qKlxuICogUGFyc2VycyBmb3IgTUxTRCBmYWN0cy5cbiAqL1xuY29uc3QgZmFjdEhhbmRsZXJzQnlOYW1lID0ge1xuICAgIFwic2l6ZVwiOiBwYXJzZVNpemUsIC8vIEZpbGUgc2l6ZVxuICAgIFwic2l6ZFwiOiBwYXJzZVNpemUsIC8vIERpcmVjdG9yeSBzaXplXG4gICAgXCJ1bmlxdWVcIjogKHZhbHVlLCBpbmZvKSA9PiB7XG4gICAgICAgIGluZm8udW5pcXVlSUQgPSB2YWx1ZTtcbiAgICB9LFxuICAgIFwibW9kaWZ5XCI6ICh2YWx1ZSwgaW5mbykgPT4ge1xuICAgICAgICBpbmZvLm1vZGlmaWVkQXQgPSBwYXJzZU1MU3hEYXRlKHZhbHVlKTtcbiAgICAgICAgaW5mby5yYXdNb2RpZmllZEF0ID0gaW5mby5tb2RpZmllZEF0LnRvSVNPU3RyaW5nKCk7XG4gICAgfSxcbiAgICBcInR5cGVcIjogKHZhbHVlLCBpbmZvKSA9PiB7XG4gICAgICAgIC8vIFRoZXJlIHNlZW1zIHRvIGJlIGNvbmZ1c2lvbiBvbiBob3cgdG8gaGFuZGxlIHN5bWJvbGljIGxpbmtzIGZvciBVbml4LiBSRkMgMzY1OSBkb2Vzbid0IGRlc2NyaWJlXG4gICAgICAgIC8vIHRoaXMgYnV0IG1lbnRpb25zIHNvbWUgZXhhbXBsZXMgdXNpbmcgdGhlIHN5bnRheCBgdHlwZT1PUy51bml4PXNsaW5rOjx0YXJnZXQ+YC4gQnV0IGFjY29yZGluZyB0b1xuICAgICAgICAvLyBhbiBlbnRyeSBpbiB0aGUgRXJyYXRhIChodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9lcnJhdGEvZWlkMTUwMCkgdGhpcyBzeW50YXggY2FuJ3QgYmUgdmFsaWQuXG4gICAgICAgIC8vIEluc3RlYWQgaXQgcHJvcG9zZXMgdG8gdXNlIGB0eXBlPU9TLnVuaXg9c3ltbGlua2AgYW5kIHRvIHRoZW4gbGlzdCB0aGUgYWN0dWFsIHRhcmdldCBvZiB0aGVcbiAgICAgICAgLy8gc3ltYm9saWMgbGluayBhcyBhbm90aGVyIGVudHJ5IGluIHRoZSBkaXJlY3RvcnkgbGlzdGluZy4gVGhlIHVuaXF1ZSBpZGVudGlmaWVycyBjYW4gdGhlbiBiZSB1c2VkXG4gICAgICAgIC8vIHRvIGRlcml2ZSB0aGUgY29ubmVjdGlvbiBiZXR3ZWVuIGxpbmsocykgYW5kIHRhcmdldC4gV2UnbGwgaGF2ZSB0byBoYW5kbGUgYm90aCBjYXNlcyBhcyB0aGVyZVxuICAgICAgICAvLyBhcmUgZGlmZmVyaW5nIG9waW5pb25zIG9uIGhvdyB0byBkZWFsIHdpdGggdGhpcy4gSGVyZSBhcmUgc29tZSBsaW5rcyBvbiB0aGlzIHRvcGljOlxuICAgICAgICAvLyAtIFByb0ZUUEQgc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vcHJvZnRwZC9wcm9mdHBkL2Jsb2IvNTZlNmRmYTU5OGNiZDRlZjVjNmNiYTQzOWJjYmNkNTNhNjNlM2IyMS9tb2R1bGVzL21vZF9mYWN0cy5jI0w1MzFcbiAgICAgICAgLy8gLSBQcm9GVFBEIGJ1ZzogaHR0cDovL2J1Z3MucHJvZnRwZC5vcmcvc2hvd19idWcuY2dpP2lkPTMzMThcbiAgICAgICAgLy8gLSBQcm9GVFBEIHN0YXRlbWVudDogaHR0cDovL3d3dy5wcm9mdHBkLm9yZy9kb2NzL21vZHVsZXMvbW9kX2ZhY3RzLmh0bWxcbiAgICAgICAgLy8g4oCTIEZpbGVaaWxsYSBidWc6IGh0dHBzOi8vdHJhYy5maWxlemlsbGEtcHJvamVjdC5vcmcvdGlja2V0LzkzMTBcbiAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoXCJPUy51bml4PXNsaW5rXCIpKSB7XG4gICAgICAgICAgICBpbmZvLnR5cGUgPSBGaWxlSW5mb18xLkZpbGVUeXBlLlN5bWJvbGljTGluaztcbiAgICAgICAgICAgIGluZm8ubGluayA9IHZhbHVlLnN1YnN0cih2YWx1ZS5pbmRleE9mKFwiOlwiKSArIDEpO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogRmFjdEhhbmRsZXJSZXN1bHQuQ29udGludWUgKi87XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBcImZpbGVcIjpcbiAgICAgICAgICAgICAgICBpbmZvLnR5cGUgPSBGaWxlSW5mb18xLkZpbGVUeXBlLkZpbGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGlyXCI6XG4gICAgICAgICAgICAgICAgaW5mby50eXBlID0gRmlsZUluZm9fMS5GaWxlVHlwZS5EaXJlY3Rvcnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiT1MudW5peD1zeW1saW5rXCI6XG4gICAgICAgICAgICAgICAgaW5mby50eXBlID0gRmlsZUluZm9fMS5GaWxlVHlwZS5TeW1ib2xpY0xpbms7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHRhcmdldCBvZiB0aGUgc3ltYm9saWMgbGluayBtaWdodCBiZSBkZWZpbmVkIGluIGFub3RoZXIgbGluZSBpbiB0aGUgZGlyZWN0b3J5IGxpc3RpbmcuXG4gICAgICAgICAgICAgICAgLy8gV2UnbGwgaGFuZGxlIHRoaXMgaW4gYHRyYW5zZm9ybUxpc3QoKWAgYmVsb3cuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2RpclwiOiAvLyBDdXJyZW50IGRpcmVjdG9yeSBiZWluZyBsaXN0ZWRcbiAgICAgICAgICAgIGNhc2UgXCJwZGlyXCI6IC8vIFBhcmVudCBkaXJlY3RvcnlcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBGYWN0SGFuZGxlclJlc3VsdC5JZ25vcmVGaWxlICovOyAvLyBEb24ndCBpbmNsdWRlIHRoZXNlIGVudHJpZXMgaW4gdGhlIGxpc3RpbmdcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaW5mby50eXBlID0gRmlsZUluZm9fMS5GaWxlVHlwZS5Vbmtub3duO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxIC8qIEZhY3RIYW5kbGVyUmVzdWx0LkNvbnRpbnVlICovO1xuICAgIH0sXG4gICAgXCJ1bml4Lm1vZGVcIjogKHZhbHVlLCBpbmZvKSA9PiB7XG4gICAgICAgIGNvbnN0IGRpZ2l0cyA9IHZhbHVlLnN1YnN0cigtMyk7XG4gICAgICAgIGluZm8ucGVybWlzc2lvbnMgPSB7XG4gICAgICAgICAgICB1c2VyOiBwYXJzZUludChkaWdpdHNbMF0sIDEwKSxcbiAgICAgICAgICAgIGdyb3VwOiBwYXJzZUludChkaWdpdHNbMV0sIDEwKSxcbiAgICAgICAgICAgIHdvcmxkOiBwYXJzZUludChkaWdpdHNbMl0sIDEwKVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgXCJ1bml4Lm93bmVybmFtZVwiOiAodmFsdWUsIGluZm8pID0+IHtcbiAgICAgICAgaW5mby51c2VyID0gdmFsdWU7XG4gICAgfSxcbiAgICBcInVuaXgub3duZXJcIjogKHZhbHVlLCBpbmZvKSA9PiB7XG4gICAgICAgIGlmIChpbmZvLnVzZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGluZm8udXNlciA9IHZhbHVlO1xuICAgIH0sXG4gICAgZ2V0IFwidW5peC51aWRcIigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbXCJ1bml4Lm93bmVyXCJdO1xuICAgIH0sXG4gICAgXCJ1bml4Lmdyb3VwbmFtZVwiOiAodmFsdWUsIGluZm8pID0+IHtcbiAgICAgICAgaW5mby5ncm91cCA9IHZhbHVlO1xuICAgIH0sXG4gICAgXCJ1bml4Lmdyb3VwXCI6ICh2YWx1ZSwgaW5mbykgPT4ge1xuICAgICAgICBpZiAoaW5mby5ncm91cCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgaW5mby5ncm91cCA9IHZhbHVlO1xuICAgIH0sXG4gICAgZ2V0IFwidW5peC5naWRcIigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbXCJ1bml4Lmdyb3VwXCJdO1xuICAgIH1cbiAgICAvLyBSZWdhcmRpbmcgdGhlIGZhY3QgXCJwZXJtXCI6XG4gICAgLy8gV2UgZG9uJ3QgaGFuZGxlIHBlcm1pc3Npb24gaW5mb3JtYXRpb24gc3RvcmVkIGluIFwicGVybVwiIGJlY2F1c2UgaXRzIGluZm9ybWF0aW9uIGlzIGNvbmNlcHR1YWxseVxuICAgIC8vIGRpZmZlcmVudCBmcm9tIHdoYXQgdXNlcnMgb2YgRlRQIGNsaWVudHMgdXN1YWxseSBhc3NvY2lhdGUgd2l0aCBcInBlcm1pc3Npb25zXCIuIFRob3NlIHRoYXQgaGF2ZVxuICAgIC8vIHNvbWUgZXhwZWN0YXRpb25zIChhbmQgcHJvYmFibHkgd2FudCB0byBlZGl0IHRoZW0gd2l0aCBhIFNJVEUgY29tbWFuZCkgb2Z0ZW4gdW5rbm93aW5nbHkgZXhwZWN0XG4gICAgLy8gdGhlIFVuaXggcGVybWlzc2lvbiBzeXN0ZW0uIFRoZSBpbmZvcm1hdGlvbiBwYXNzZWQgYnkgXCJwZXJtXCIgZGVzY3JpYmVzIHdoYXQgRlRQIGNvbW1hbmRzIGNhbiBiZVxuICAgIC8vIGV4ZWN1dGVkIHdpdGggYSBmaWxlL2RpcmVjdG9yeS4gQnV0IGV2ZW4gdGhpcyBjYW4gYmUgZWl0aGVyIGluY29tcGxldGUgb3IganVzdCBtZWFudCBhcyBhIFwiZ3VpZGVcIlxuICAgIC8vIGFzIHRoZSBzcGVjIG1lbnRpb25zLiBGcm9tIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNjU5I3NlY3Rpb24tNy41LjU6IFwiVGhlIHBlcm1pc3Npb25zIGFyZVxuICAgIC8vIGRlc2NyaWJlZCBoZXJlIGFzIHRoZXkgYXBwbHkgdG8gRlRQIGNvbW1hbmRzLiBUaGV5IG1heSBub3QgbWFwIGVhc2lseSBpbnRvIHBhcnRpY3VsYXIgcGVybWlzc2lvbnNcbiAgICAvLyBhdmFpbGFibGUgb24gdGhlIHNlcnZlcidzIG9wZXJhdGluZyBzeXN0ZW0uXCIgVGhlIHBhcnNlciBieSBBcGFjaGUgQ29tbW9ucyB0cmllcyB0byB0cmFuc2xhdGUgdGhlc2VcbiAgICAvLyB0byBVbml4IHBlcm1pc3Npb25zIOKAkyB0aGlzIGlzIG1pc2xlYWRpbmcgdXNlcnMgYW5kIG1pZ2h0IG5vdCBldmVuIGJlIGNvcnJlY3QuXG59O1xuLyoqXG4gKiBTcGxpdCBhIHN0cmluZyBvbmNlIGF0IHRoZSBmaXJzdCBwb3NpdGlvbiBvZiBhIGRlbGltaXRlci4gRm9yIGV4YW1wbGVcbiAqIGBzcGxpdFN0cmluZ09uY2UoXCJhIGIgYyBkXCIsIFwiIFwiKWAgcmV0dXJucyBgW1wiYVwiLCBcImIgYyBkXCJdYC5cbiAqL1xuZnVuY3Rpb24gc3BsaXRTdHJpbmdPbmNlKHN0ciwgZGVsaW1pdGVyKSB7XG4gICAgY29uc3QgcG9zID0gc3RyLmluZGV4T2YoZGVsaW1pdGVyKTtcbiAgICBjb25zdCBhID0gc3RyLnN1YnN0cigwLCBwb3MpO1xuICAgIGNvbnN0IGIgPSBzdHIuc3Vic3RyKHBvcyArIGRlbGltaXRlci5sZW5ndGgpO1xuICAgIHJldHVybiBbYSwgYl07XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIGdpdmVuIGxpbmUgbWlnaHQgYmUgcGFydCBvZiBhbiBNTFNEIGxpc3RpbmcuXG4gKlxuICogLSBFeGFtcGxlIDE6IGBzaXplPTE1MjI3O3R5cGU9ZGlyO3Blcm09ZWw7bW9kaWZ5PTIwMTkwNDE5MDY1NzMwOyB0ZXN0IG9uZWBcbiAqIC0gRXhhbXBsZSAyOiBgIGZpbGUgbmFtZWAgKGxlYWRpbmcgc3BhY2UpXG4gKi9cbmZ1bmN0aW9uIHRlc3RMaW5lKGxpbmUpIHtcbiAgICByZXR1cm4gL15cXFMrPVxcUys7Ly50ZXN0KGxpbmUpIHx8IGxpbmUuc3RhcnRzV2l0aChcIiBcIik7XG59XG4vKipcbiAqIFBhcnNlIHNpbmdsZSBsaW5lIGFzIE1MU0QgbGlzdGluZywgc2VlIHNwZWNpZmljYXRpb24gYXQgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM2NTkjc2VjdGlvbi03LlxuICovXG5mdW5jdGlvbiBwYXJzZUxpbmUobGluZSkge1xuICAgIGNvbnN0IFtwYWNrZWRGYWN0cywgbmFtZV0gPSBzcGxpdFN0cmluZ09uY2UobGluZSwgXCIgXCIpO1xuICAgIGlmIChuYW1lID09PSBcIlwiIHx8IG5hbWUgPT09IFwiLlwiIHx8IG5hbWUgPT09IFwiLi5cIikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBpbmZvID0gbmV3IEZpbGVJbmZvXzEuRmlsZUluZm8obmFtZSk7XG4gICAgY29uc3QgZmFjdHMgPSBwYWNrZWRGYWN0cy5zcGxpdChcIjtcIik7XG4gICAgZm9yIChjb25zdCBmYWN0IG9mIGZhY3RzKSB7XG4gICAgICAgIGNvbnN0IFtmYWN0TmFtZSwgZmFjdFZhbHVlXSA9IHNwbGl0U3RyaW5nT25jZShmYWN0LCBcIj1cIik7XG4gICAgICAgIGlmICghZmFjdFZhbHVlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWN0SGFuZGxlciA9IGZhY3RIYW5kbGVyc0J5TmFtZVtmYWN0TmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgaWYgKCFmYWN0SGFuZGxlcikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZmFjdEhhbmRsZXIoZmFjdFZhbHVlLCBpbmZvKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gMiAvKiBGYWN0SGFuZGxlclJlc3VsdC5JZ25vcmVGaWxlICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmZvO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtTGlzdChmaWxlcykge1xuICAgIC8vIENyZWF0ZSBhIG1hcCBvZiBhbGwgZmlsZXMgdGhhdCBhcmUgbm90IHN5bWJvbGljIGxpbmtzIGJ5IHRoZWlyIHVuaXF1ZSBJRFxuICAgIGNvbnN0IG5vbkxpbmtzQnlJRCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgaWYgKCFmaWxlLmlzU3ltYm9saWNMaW5rICYmIGZpbGUudW5pcXVlSUQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9uTGlua3NCeUlELnNldChmaWxlLnVuaXF1ZUlELCBmaWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZEZpbGVzID0gW107XG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgIC8vIFRyeSB0byBhc3NvY2lhdGUgdW5yZXNvbHZlZCBzeW1ib2xpYyBsaW5rcyB3aXRoIGEgdGFyZ2V0IGZpbGUvZGlyZWN0b3J5LlxuICAgICAgICBpZiAoZmlsZS5pc1N5bWJvbGljTGluayAmJiBmaWxlLnVuaXF1ZUlEICE9PSB1bmRlZmluZWQgJiYgZmlsZS5saW5rID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IG5vbkxpbmtzQnlJRC5nZXQoZmlsZS51bmlxdWVJRCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmaWxlLmxpbmsgPSB0YXJnZXQubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgdGFyZ2V0IG9mIGEgc3ltYm9saWMgbGluayBpcyBsaXN0ZWQgYXMgYW4gZW50cnkgaW4gdGhlIGRpcmVjdG9yeSBsaXN0aW5nIGJ1dCBtaWdodFxuICAgICAgICAvLyBoYXZlIGEgcGF0aCBwb2ludGluZyBvdXRzaWRlIG9mIHRoaXMgZGlyZWN0b3J5LiBJbiB0aGF0IGNhc2Ugd2UgZG9uJ3Qgd2FudCB0aGlzIGVudHJ5XG4gICAgICAgIC8vIHRvIGJlIHBhcnQgb2YgdGhlIGxpc3RpbmcuIFdlIGdlbmVyYWxseSBkb24ndCB3YW50IHRoZXNlIGtpbmQgb2YgZW50cmllcyBhdCBhbGwuXG4gICAgICAgIGNvbnN0IGlzUGFydE9mRGlyZWN0b3J5ID0gIWZpbGUubmFtZS5pbmNsdWRlcyhcIi9cIik7XG4gICAgICAgIGlmIChpc1BhcnRPZkRpcmVjdG9yeSkge1xuICAgICAgICAgICAgcmVzb2x2ZWRGaWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlZEZpbGVzO1xufVxuLyoqXG4gKiBQYXJzZSBkYXRlIGFzIHNwZWNpZmllZCBpbiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzY1OSNzZWN0aW9uLTIuMy5cbiAqXG4gKiBNZXNzYWdlIGNvbnRhaW5zIHJlc3BvbnNlIGNvZGUgYW5kIG1vZGlmaWVkIHRpbWUgaW4gdGhlIGZvcm1hdDogWVlZWU1NRERISE1NU1NbLnNzc11cbiAqIEZvciBleGFtcGxlIGAxOTk5MTAwNTIxMzEwMmAgb3IgYDE5OTgwNjE1MTAwMDQ1LjAxNGAuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTUxTeERhdGUoZmFjdCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygrZmFjdC5zbGljZSgwLCA0KSwgLy8gWWVhclxuICAgICtmYWN0LnNsaWNlKDQsIDYpIC0gMSwgLy8gTW9udGhcbiAgICArZmFjdC5zbGljZSg2LCA4KSwgLy8gRGF0ZVxuICAgICtmYWN0LnNsaWNlKDgsIDEwKSwgLy8gSG91cnNcbiAgICArZmFjdC5zbGljZSgxMCwgMTIpLCAvLyBNaW51dGVzXG4gICAgK2ZhY3Quc2xpY2UoMTIsIDE0KSwgLy8gU2Vjb25kc1xuICAgICtmYWN0LnNsaWNlKDE1LCAxOCkgLy8gTWlsbGlzZWNvbmRzXG4gICAgKSk7XG59XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ0ZXN0TGluZSIsInBhcnNlTGluZSIsInRyYW5zZm9ybUxpc3QiLCJwYXJzZU1MU3hEYXRlIiwiRmlsZUluZm9fMSIsInJlcXVpcmUiLCJwYXJzZVNpemUiLCJpbmZvIiwic2l6ZSIsInBhcnNlSW50IiwiZmFjdEhhbmRsZXJzQnlOYW1lIiwidW5pcXVlSUQiLCJtb2RpZmllZEF0IiwicmF3TW9kaWZpZWRBdCIsInRvSVNPU3RyaW5nIiwic3RhcnRzV2l0aCIsInR5cGUiLCJGaWxlVHlwZSIsIlN5bWJvbGljTGluayIsImxpbmsiLCJzdWJzdHIiLCJpbmRleE9mIiwiRmlsZSIsIkRpcmVjdG9yeSIsIlVua25vd24iLCJkaWdpdHMiLCJwZXJtaXNzaW9ucyIsInVzZXIiLCJncm91cCIsIndvcmxkIiwidW5kZWZpbmVkIiwic3BsaXRTdHJpbmdPbmNlIiwic3RyIiwiZGVsaW1pdGVyIiwicG9zIiwiYSIsImIiLCJsZW5ndGgiLCJsaW5lIiwidGVzdCIsInBhY2tlZEZhY3RzIiwibmFtZSIsIkZpbGVJbmZvIiwiZmFjdHMiLCJzcGxpdCIsImZhY3QiLCJmYWN0TmFtZSIsImZhY3RWYWx1ZSIsImZhY3RIYW5kbGVyIiwidG9Mb3dlckNhc2UiLCJyZXN1bHQiLCJmaWxlcyIsIm5vbkxpbmtzQnlJRCIsIk1hcCIsImZpbGUiLCJpc1N5bWJvbGljTGluayIsInNldCIsInJlc29sdmVkRmlsZXMiLCJ0YXJnZXQiLCJnZXQiLCJpc1BhcnRPZkRpcmVjdG9yeSIsImluY2x1ZGVzIiwicHVzaCIsIkRhdGUiLCJVVEMiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/basic-ftp/dist/parseListMLSD.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/basic-ftp/dist/parseListUnix.js":
/*!**********************************************************!*\
  !*** ../../node_modules/basic-ftp/dist/parseListUnix.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.testLine = testLine;\nexports.parseLine = parseLine;\nexports.transformList = transformList;\nconst FileInfo_1 = __webpack_require__(/*! ./FileInfo */ \"(rsc)/../../node_modules/basic-ftp/dist/FileInfo.js\");\nconst JA_MONTH = \"æœˆ\";\nconst JA_DAY = \"æ—¥\";\nconst JA_YEAR = \"å¹´\";\n/**\n * This parser is based on the FTP client library source code in Apache Commons Net provided\n * under the Apache 2.0 license. It has been simplified and rewritten to better fit the Javascript language.\n *\n * https://github.com/apache/commons-net/blob/master/src/main/java/org/apache/commons/net/ftp/parser/UnixFTPEntryParser.java\n *\n * Below is the regular expression used by this parser.\n *\n * Permissions:\n *    r   the file is readable\n *    w   the file is writable\n *    x   the file is executable\n *    -   the indicated permission is not granted\n *    L   mandatory locking occurs during access (the set-group-ID bit is\n *        on and the group execution bit is off)\n *    s   the set-user-ID or set-group-ID bit is on, and the corresponding\n *        user or group execution bit is also on\n *    S   undefined bit-state (the set-user-ID bit is on and the user\n *        execution bit is off)\n *    t   the 1000 (octal) bit, or sticky bit, is on [see chmod(1)], and\n *        execution is on\n *    T   the 1000 bit is turned on, and execution is off (undefined bit-\n *        state)\n *    e   z/OS external link bit\n *    Final letter may be appended:\n *    +   file has extended security attributes (e.g. ACL)\n *    Note: local listings on MacOSX also use '@'\n *    this is not allowed for here as does not appear to be shown by FTP servers\n *    {@code @}   file has extended attributes\n */ const RE_LINE = new RegExp(\"([bcdelfmpSs-])\" // file type\n + \"(((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]?)))\\\\+?\" // permissions\n + \"\\\\s*\" // separator TODO why allow it to be omitted??\n + \"(\\\\d+)\" // link count\n + \"\\\\s+\" // separator\n + \"(?:(\\\\S+(?:\\\\s\\\\S+)*?)\\\\s+)?\" // owner name (optional spaces)\n + \"(?:(\\\\S+(?:\\\\s\\\\S+)*)\\\\s+)?\" // group name (optional spaces)\n + \"(\\\\d+(?:,\\\\s*\\\\d+)?)\" // size or n,m\n + \"\\\\s+\" // separator\n + \"(\" + \"(?:\\\\d+[-/]\\\\d+[-/]\\\\d+)\" + // yyyy-mm-dd\n\"|(?:\\\\S{3}\\\\s+\\\\d{1,2})\" + // MMM [d]d\n\"|(?:\\\\d{1,2}\\\\s+\\\\S{3})\" + // [d]d MMM\n\"|(?:\\\\d{1,2}\" + JA_MONTH + \"\\\\s+\\\\d{1,2}\" + JA_DAY + \")\" + \")\" + \"\\\\s+\" // separator\n + \"((?:\\\\d+(?::\\\\d+)?)|(?:\\\\d{4}\" + JA_YEAR + \"))\" // (20)\n + \"\\\\s\" // separator\n + \"(.*)\"); // the rest (21)\n/**\n * Returns true if a given line might be a Unix-style listing.\n *\n * - Example: `-rw-r--r--+   1 patrick  staff   1057 Dec 11 14:35 test.txt`\n */ function testLine(line) {\n    return RE_LINE.test(line);\n}\n/**\n * Parse a single line of a Unix-style directory listing.\n */ function parseLine(line) {\n    const groups = line.match(RE_LINE);\n    if (groups === null) {\n        return undefined;\n    }\n    const name = groups[21];\n    if (name === \".\" || name === \"..\") {\n        return undefined;\n    }\n    const file = new FileInfo_1.FileInfo(name);\n    file.size = parseInt(groups[18], 10);\n    file.user = groups[16];\n    file.group = groups[17];\n    file.hardLinkCount = parseInt(groups[15], 10);\n    file.rawModifiedAt = groups[19] + \" \" + groups[20];\n    file.permissions = {\n        user: parseMode(groups[4], groups[5], groups[6]),\n        group: parseMode(groups[8], groups[9], groups[10]),\n        world: parseMode(groups[12], groups[13], groups[14])\n    };\n    // Set file type\n    switch(groups[1].charAt(0)){\n        case \"d\":\n            file.type = FileInfo_1.FileType.Directory;\n            break;\n        case \"e\":\n            file.type = FileInfo_1.FileType.SymbolicLink;\n            break;\n        case \"l\":\n            file.type = FileInfo_1.FileType.SymbolicLink;\n            break;\n        case \"b\":\n        case \"c\":\n            file.type = FileInfo_1.FileType.File; // TODO change this if DEVICE_TYPE implemented\n            break;\n        case \"f\":\n        case \"-\":\n            file.type = FileInfo_1.FileType.File;\n            break;\n        default:\n            // A 'whiteout' file is an ARTIFICIAL entry in any of several types of\n            // 'translucent' filesystems, of which a 'union' filesystem is one.\n            file.type = FileInfo_1.FileType.Unknown;\n    }\n    // Separate out the link name for symbolic links\n    if (file.isSymbolicLink) {\n        const end = name.indexOf(\" -> \");\n        if (end !== -1) {\n            file.name = name.substring(0, end);\n            file.link = name.substring(end + 4);\n        }\n    }\n    return file;\n}\nfunction transformList(files) {\n    return files;\n}\nfunction parseMode(r, w, x) {\n    let value = 0;\n    if (r !== \"-\") {\n        value += FileInfo_1.FileInfo.UnixPermission.Read;\n    }\n    if (w !== \"-\") {\n        value += FileInfo_1.FileInfo.UnixPermission.Write;\n    }\n    const execToken = x.charAt(0);\n    if (execToken !== \"-\" && execToken.toUpperCase() !== execToken) {\n        value += FileInfo_1.FileInfo.UnixPermission.Execute;\n    }\n    return value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2ljLWZ0cC9kaXN0L3BhcnNlTGlzdFVuaXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdCQUFnQixHQUFHRTtBQUNuQkYsaUJBQWlCLEdBQUdHO0FBQ3BCSCxxQkFBcUIsR0FBR0k7QUFDeEIsTUFBTUMsYUFBYUMsbUJBQU9BLENBQUMsdUVBQVk7QUFDdkMsTUFBTUMsV0FBVztBQUNqQixNQUFNQyxTQUFTO0FBQ2YsTUFBTUMsVUFBVTtBQUNoQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E2QkMsR0FDRCxNQUFNQyxVQUFVLElBQUlDLE9BQU8sa0JBQWtCLFlBQVk7R0FDbkQsK0VBQStFLGNBQWM7R0FDN0YsT0FBTyw4Q0FBOEM7R0FDckQsU0FBUyxhQUFhO0dBQ3RCLE9BQU8sWUFBWTtHQUNuQiwrQkFBK0IsK0JBQStCO0dBQzlELDhCQUE4QiwrQkFBK0I7R0FDN0QsdUJBQXVCLGNBQWM7R0FDckMsT0FBTyxZQUFZO0dBV25CLE1BQ0YsNkJBQTZCLGFBQWE7QUFDMUMsNEJBQTRCLFdBQVc7QUFDdkMsNEJBQTRCLFdBQVc7QUFDdkMsaUJBQWlCSixXQUFXLGlCQUFpQkMsU0FBUyxNQUN0RCxNQUNFLE9BQU8sWUFBWTtHQU1uQixrQ0FBa0NDLFVBQVUsS0FBSyxPQUFPO0dBQ3hELE1BQU0sWUFBWTtHQUNsQixTQUFTLGdCQUFnQjtBQUMvQjs7OztDQUlDLEdBQ0QsU0FBU1AsU0FBU1UsSUFBSTtJQUNsQixPQUFPRixRQUFRRyxJQUFJLENBQUNEO0FBQ3hCO0FBQ0E7O0NBRUMsR0FDRCxTQUFTVCxVQUFVUyxJQUFJO0lBQ25CLE1BQU1FLFNBQVNGLEtBQUtHLEtBQUssQ0FBQ0w7SUFDMUIsSUFBSUksV0FBVyxNQUFNO1FBQ2pCLE9BQU9FO0lBQ1g7SUFDQSxNQUFNQyxPQUFPSCxNQUFNLENBQUMsR0FBRztJQUN2QixJQUFJRyxTQUFTLE9BQU9BLFNBQVMsTUFBTTtRQUMvQixPQUFPRDtJQUNYO0lBQ0EsTUFBTUUsT0FBTyxJQUFJYixXQUFXYyxRQUFRLENBQUNGO0lBQ3JDQyxLQUFLRSxJQUFJLEdBQUdDLFNBQVNQLE1BQU0sQ0FBQyxHQUFHLEVBQUU7SUFDakNJLEtBQUtJLElBQUksR0FBR1IsTUFBTSxDQUFDLEdBQUc7SUFDdEJJLEtBQUtLLEtBQUssR0FBR1QsTUFBTSxDQUFDLEdBQUc7SUFDdkJJLEtBQUtNLGFBQWEsR0FBR0gsU0FBU1AsTUFBTSxDQUFDLEdBQUcsRUFBRTtJQUMxQ0ksS0FBS08sYUFBYSxHQUFHWCxNQUFNLENBQUMsR0FBRyxHQUFHLE1BQU1BLE1BQU0sQ0FBQyxHQUFHO0lBQ2xESSxLQUFLUSxXQUFXLEdBQUc7UUFDZkosTUFBTUssVUFBVWIsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUU7UUFDL0NTLE9BQU9JLFVBQVViLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxHQUFHO1FBQ2pEYyxPQUFPRCxVQUFVYixNQUFNLENBQUMsR0FBRyxFQUFFQSxNQUFNLENBQUMsR0FBRyxFQUFFQSxNQUFNLENBQUMsR0FBRztJQUN2RDtJQUNBLGdCQUFnQjtJQUNoQixPQUFRQSxNQUFNLENBQUMsRUFBRSxDQUFDZSxNQUFNLENBQUM7UUFDckIsS0FBSztZQUNEWCxLQUFLWSxJQUFJLEdBQUd6QixXQUFXMEIsUUFBUSxDQUFDQyxTQUFTO1lBQ3pDO1FBQ0osS0FBSztZQUNEZCxLQUFLWSxJQUFJLEdBQUd6QixXQUFXMEIsUUFBUSxDQUFDRSxZQUFZO1lBQzVDO1FBQ0osS0FBSztZQUNEZixLQUFLWSxJQUFJLEdBQUd6QixXQUFXMEIsUUFBUSxDQUFDRSxZQUFZO1lBQzVDO1FBQ0osS0FBSztRQUNMLEtBQUs7WUFDRGYsS0FBS1ksSUFBSSxHQUFHekIsV0FBVzBCLFFBQVEsQ0FBQ0csSUFBSSxFQUFFLDhDQUE4QztZQUNwRjtRQUNKLEtBQUs7UUFDTCxLQUFLO1lBQ0RoQixLQUFLWSxJQUFJLEdBQUd6QixXQUFXMEIsUUFBUSxDQUFDRyxJQUFJO1lBQ3BDO1FBQ0o7WUFDSSxzRUFBc0U7WUFDdEUsbUVBQW1FO1lBQ25FaEIsS0FBS1ksSUFBSSxHQUFHekIsV0FBVzBCLFFBQVEsQ0FBQ0ksT0FBTztJQUMvQztJQUNBLGdEQUFnRDtJQUNoRCxJQUFJakIsS0FBS2tCLGNBQWMsRUFBRTtRQUNyQixNQUFNQyxNQUFNcEIsS0FBS3FCLE9BQU8sQ0FBQztRQUN6QixJQUFJRCxRQUFRLENBQUMsR0FBRztZQUNabkIsS0FBS0QsSUFBSSxHQUFHQSxLQUFLc0IsU0FBUyxDQUFDLEdBQUdGO1lBQzlCbkIsS0FBS3NCLElBQUksR0FBR3ZCLEtBQUtzQixTQUFTLENBQUNGLE1BQU07UUFDckM7SUFDSjtJQUNBLE9BQU9uQjtBQUNYO0FBQ0EsU0FBU2QsY0FBY3FDLEtBQUs7SUFDeEIsT0FBT0E7QUFDWDtBQUNBLFNBQVNkLFVBQVVlLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3RCLElBQUkzQyxRQUFRO0lBQ1osSUFBSXlDLE1BQU0sS0FBSztRQUNYekMsU0FBU0ksV0FBV2MsUUFBUSxDQUFDMEIsY0FBYyxDQUFDQyxJQUFJO0lBQ3BEO0lBQ0EsSUFBSUgsTUFBTSxLQUFLO1FBQ1gxQyxTQUFTSSxXQUFXYyxRQUFRLENBQUMwQixjQUFjLENBQUNFLEtBQUs7SUFDckQ7SUFDQSxNQUFNQyxZQUFZSixFQUFFZixNQUFNLENBQUM7SUFDM0IsSUFBSW1CLGNBQWMsT0FBT0EsVUFBVUMsV0FBVyxPQUFPRCxXQUFXO1FBQzVEL0MsU0FBU0ksV0FBV2MsUUFBUSxDQUFDMEIsY0FBYyxDQUFDSyxPQUFPO0lBQ3ZEO0lBQ0EsT0FBT2pEO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2ljLWZ0cC9kaXN0L3BhcnNlTGlzdFVuaXguanM/ZGQ1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudGVzdExpbmUgPSB0ZXN0TGluZTtcbmV4cG9ydHMucGFyc2VMaW5lID0gcGFyc2VMaW5lO1xuZXhwb3J0cy50cmFuc2Zvcm1MaXN0ID0gdHJhbnNmb3JtTGlzdDtcbmNvbnN0IEZpbGVJbmZvXzEgPSByZXF1aXJlKFwiLi9GaWxlSW5mb1wiKTtcbmNvbnN0IEpBX01PTlRIID0gXCJcXHU2NzA4XCI7XG5jb25zdCBKQV9EQVkgPSBcIlxcdTY1ZTVcIjtcbmNvbnN0IEpBX1lFQVIgPSBcIlxcdTVlNzRcIjtcbi8qKlxuICogVGhpcyBwYXJzZXIgaXMgYmFzZWQgb24gdGhlIEZUUCBjbGllbnQgbGlicmFyeSBzb3VyY2UgY29kZSBpbiBBcGFjaGUgQ29tbW9ucyBOZXQgcHJvdmlkZWRcbiAqIHVuZGVyIHRoZSBBcGFjaGUgMi4wIGxpY2Vuc2UuIEl0IGhhcyBiZWVuIHNpbXBsaWZpZWQgYW5kIHJld3JpdHRlbiB0byBiZXR0ZXIgZml0IHRoZSBKYXZhc2NyaXB0IGxhbmd1YWdlLlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcGFjaGUvY29tbW9ucy1uZXQvYmxvYi9tYXN0ZXIvc3JjL21haW4vamF2YS9vcmcvYXBhY2hlL2NvbW1vbnMvbmV0L2Z0cC9wYXJzZXIvVW5peEZUUEVudHJ5UGFyc2VyLmphdmFcbiAqXG4gKiBCZWxvdyBpcyB0aGUgcmVndWxhciBleHByZXNzaW9uIHVzZWQgYnkgdGhpcyBwYXJzZXIuXG4gKlxuICogUGVybWlzc2lvbnM6XG4gKiAgICByICAgdGhlIGZpbGUgaXMgcmVhZGFibGVcbiAqICAgIHcgICB0aGUgZmlsZSBpcyB3cml0YWJsZVxuICogICAgeCAgIHRoZSBmaWxlIGlzIGV4ZWN1dGFibGVcbiAqICAgIC0gICB0aGUgaW5kaWNhdGVkIHBlcm1pc3Npb24gaXMgbm90IGdyYW50ZWRcbiAqICAgIEwgICBtYW5kYXRvcnkgbG9ja2luZyBvY2N1cnMgZHVyaW5nIGFjY2VzcyAodGhlIHNldC1ncm91cC1JRCBiaXQgaXNcbiAqICAgICAgICBvbiBhbmQgdGhlIGdyb3VwIGV4ZWN1dGlvbiBiaXQgaXMgb2ZmKVxuICogICAgcyAgIHRoZSBzZXQtdXNlci1JRCBvciBzZXQtZ3JvdXAtSUQgYml0IGlzIG9uLCBhbmQgdGhlIGNvcnJlc3BvbmRpbmdcbiAqICAgICAgICB1c2VyIG9yIGdyb3VwIGV4ZWN1dGlvbiBiaXQgaXMgYWxzbyBvblxuICogICAgUyAgIHVuZGVmaW5lZCBiaXQtc3RhdGUgKHRoZSBzZXQtdXNlci1JRCBiaXQgaXMgb24gYW5kIHRoZSB1c2VyXG4gKiAgICAgICAgZXhlY3V0aW9uIGJpdCBpcyBvZmYpXG4gKiAgICB0ICAgdGhlIDEwMDAgKG9jdGFsKSBiaXQsIG9yIHN0aWNreSBiaXQsIGlzIG9uIFtzZWUgY2htb2QoMSldLCBhbmRcbiAqICAgICAgICBleGVjdXRpb24gaXMgb25cbiAqICAgIFQgICB0aGUgMTAwMCBiaXQgaXMgdHVybmVkIG9uLCBhbmQgZXhlY3V0aW9uIGlzIG9mZiAodW5kZWZpbmVkIGJpdC1cbiAqICAgICAgICBzdGF0ZSlcbiAqICAgIGUgICB6L09TIGV4dGVybmFsIGxpbmsgYml0XG4gKiAgICBGaW5hbCBsZXR0ZXIgbWF5IGJlIGFwcGVuZGVkOlxuICogICAgKyAgIGZpbGUgaGFzIGV4dGVuZGVkIHNlY3VyaXR5IGF0dHJpYnV0ZXMgKGUuZy4gQUNMKVxuICogICAgTm90ZTogbG9jYWwgbGlzdGluZ3Mgb24gTWFjT1NYIGFsc28gdXNlICdAJ1xuICogICAgdGhpcyBpcyBub3QgYWxsb3dlZCBmb3IgaGVyZSBhcyBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgc2hvd24gYnkgRlRQIHNlcnZlcnNcbiAqICAgIHtAY29kZSBAfSAgIGZpbGUgaGFzIGV4dGVuZGVkIGF0dHJpYnV0ZXNcbiAqL1xuY29uc3QgUkVfTElORSA9IG5ldyBSZWdFeHAoXCIoW2JjZGVsZm1wU3MtXSlcIiAvLyBmaWxlIHR5cGVcbiAgICArIFwiKCgocnwtKSh3fC0pKFt4c1N0VEwtXSkpKChyfC0pKHd8LSkoW3hzU3RUTC1dKSkoKHJ8LSkod3wtKShbeHNTdFRMLV0/KSkpXFxcXCs/XCIgLy8gcGVybWlzc2lvbnNcbiAgICArIFwiXFxcXHMqXCIgLy8gc2VwYXJhdG9yIFRPRE8gd2h5IGFsbG93IGl0IHRvIGJlIG9taXR0ZWQ/P1xuICAgICsgXCIoXFxcXGQrKVwiIC8vIGxpbmsgY291bnRcbiAgICArIFwiXFxcXHMrXCIgLy8gc2VwYXJhdG9yXG4gICAgKyBcIig/OihcXFxcUysoPzpcXFxcc1xcXFxTKykqPylcXFxccyspP1wiIC8vIG93bmVyIG5hbWUgKG9wdGlvbmFsIHNwYWNlcylcbiAgICArIFwiKD86KFxcXFxTKyg/OlxcXFxzXFxcXFMrKSopXFxcXHMrKT9cIiAvLyBncm91cCBuYW1lIChvcHRpb25hbCBzcGFjZXMpXG4gICAgKyBcIihcXFxcZCsoPzosXFxcXHMqXFxcXGQrKT8pXCIgLy8gc2l6ZSBvciBuLG1cbiAgICArIFwiXFxcXHMrXCIgLy8gc2VwYXJhdG9yXG4gICAgLyoqXG4gICAgICogbnVtZXJpYyBvciBzdGFuZGFyZCBmb3JtYXQgZGF0ZTpcbiAgICAgKiAgIHl5eXktbW0tZGQgKGV4cGVjdGluZyBoaDptbSB0byBmb2xsb3cpXG4gICAgICogICBNTU0gW2RdZFxuICAgICAqICAgW2RdZCBNTU1cbiAgICAgKiAgIE4uQi4gdXNlIG5vbi1zcGFjZSBmb3IgTU1NIHRvIGFsbG93IGZvciBsYW5ndWFnZXMgc3VjaCBhcyBHZXJtYW4gd2hpY2ggdXNlXG4gICAgICogICBkaWFjcml0aWNzIChlLmcuIHVtbGF1dCkgaW4gc29tZSBhYmJyZXZpYXRpb25zLlxuICAgICAqICAgSmFwYW5lc2UgdXNlcyBudW1lcmljIGRheSBhbmQgbW9udGggd2l0aCBzdWZmaXhlcyB0byBkaXN0aW5ndWlzaCB0aGVtXG4gICAgICogICBbZF1kWFggW2RdZFpaXG4gICAgICovXG4gICAgKyBcIihcIiArXG4gICAgXCIoPzpcXFxcZCtbLS9dXFxcXGQrWy0vXVxcXFxkKylcIiArIC8vIHl5eXktbW0tZGRcbiAgICBcInwoPzpcXFxcU3szfVxcXFxzK1xcXFxkezEsMn0pXCIgKyAvLyBNTU0gW2RdZFxuICAgIFwifCg/OlxcXFxkezEsMn1cXFxccytcXFxcU3szfSlcIiArIC8vIFtkXWQgTU1NXG4gICAgXCJ8KD86XFxcXGR7MSwyfVwiICsgSkFfTU9OVEggKyBcIlxcXFxzK1xcXFxkezEsMn1cIiArIEpBX0RBWSArIFwiKVwiICtcbiAgICBcIilcIlxuICAgICsgXCJcXFxccytcIiAvLyBzZXBhcmF0b3JcbiAgICAvKipcbiAgICAgKiB5ZWFyIChmb3Igbm9uLXJlY2VudCBzdGFuZGFyZCBmb3JtYXQpIC0geXl5eVxuICAgICAqIG9yIHRpbWUgKGZvciBudW1lcmljIG9yIHJlY2VudCBzdGFuZGFyZCBmb3JtYXQpIFtoXWg6bW1cbiAgICAgKiBvciBKYXBhbmVzZSB5ZWFyIC0geXl5eVhYXG4gICAgICovXG4gICAgKyBcIigoPzpcXFxcZCsoPzo6XFxcXGQrKT8pfCg/OlxcXFxkezR9XCIgKyBKQV9ZRUFSICsgXCIpKVwiIC8vICgyMClcbiAgICArIFwiXFxcXHNcIiAvLyBzZXBhcmF0b3JcbiAgICArIFwiKC4qKVwiKTsgLy8gdGhlIHJlc3QgKDIxKVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBnaXZlbiBsaW5lIG1pZ2h0IGJlIGEgVW5peC1zdHlsZSBsaXN0aW5nLlxuICpcbiAqIC0gRXhhbXBsZTogYC1ydy1yLS1yLS0rICAgMSBwYXRyaWNrICBzdGFmZiAgIDEwNTcgRGVjIDExIDE0OjM1IHRlc3QudHh0YFxuICovXG5mdW5jdGlvbiB0ZXN0TGluZShsaW5lKSB7XG4gICAgcmV0dXJuIFJFX0xJTkUudGVzdChsaW5lKTtcbn1cbi8qKlxuICogUGFyc2UgYSBzaW5nbGUgbGluZSBvZiBhIFVuaXgtc3R5bGUgZGlyZWN0b3J5IGxpc3RpbmcuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTGluZShsaW5lKSB7XG4gICAgY29uc3QgZ3JvdXBzID0gbGluZS5tYXRjaChSRV9MSU5FKTtcbiAgICBpZiAoZ3JvdXBzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSBncm91cHNbMjFdO1xuICAgIGlmIChuYW1lID09PSBcIi5cIiB8fCBuYW1lID09PSBcIi4uXCIpIHsgLy8gSWdub3JlIHBhcmVudCBkaXJlY3RvcnkgbGlua3NcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgZmlsZSA9IG5ldyBGaWxlSW5mb18xLkZpbGVJbmZvKG5hbWUpO1xuICAgIGZpbGUuc2l6ZSA9IHBhcnNlSW50KGdyb3Vwc1sxOF0sIDEwKTtcbiAgICBmaWxlLnVzZXIgPSBncm91cHNbMTZdO1xuICAgIGZpbGUuZ3JvdXAgPSBncm91cHNbMTddO1xuICAgIGZpbGUuaGFyZExpbmtDb3VudCA9IHBhcnNlSW50KGdyb3Vwc1sxNV0sIDEwKTtcbiAgICBmaWxlLnJhd01vZGlmaWVkQXQgPSBncm91cHNbMTldICsgXCIgXCIgKyBncm91cHNbMjBdO1xuICAgIGZpbGUucGVybWlzc2lvbnMgPSB7XG4gICAgICAgIHVzZXI6IHBhcnNlTW9kZShncm91cHNbNF0sIGdyb3Vwc1s1XSwgZ3JvdXBzWzZdKSxcbiAgICAgICAgZ3JvdXA6IHBhcnNlTW9kZShncm91cHNbOF0sIGdyb3Vwc1s5XSwgZ3JvdXBzWzEwXSksXG4gICAgICAgIHdvcmxkOiBwYXJzZU1vZGUoZ3JvdXBzWzEyXSwgZ3JvdXBzWzEzXSwgZ3JvdXBzWzE0XSksXG4gICAgfTtcbiAgICAvLyBTZXQgZmlsZSB0eXBlXG4gICAgc3dpdGNoIChncm91cHNbMV0uY2hhckF0KDApKSB7XG4gICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICBmaWxlLnR5cGUgPSBGaWxlSW5mb18xLkZpbGVUeXBlLkRpcmVjdG9yeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZVwiOiAvLyBORVQtMzkgPT4gei9PUyBleHRlcm5hbCBsaW5rXG4gICAgICAgICAgICBmaWxlLnR5cGUgPSBGaWxlSW5mb18xLkZpbGVUeXBlLlN5bWJvbGljTGluaztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibFwiOlxuICAgICAgICAgICAgZmlsZS50eXBlID0gRmlsZUluZm9fMS5GaWxlVHlwZS5TeW1ib2xpY0xpbms7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJcIjpcbiAgICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgICAgIGZpbGUudHlwZSA9IEZpbGVJbmZvXzEuRmlsZVR5cGUuRmlsZTsgLy8gVE9ETyBjaGFuZ2UgdGhpcyBpZiBERVZJQ0VfVFlQRSBpbXBsZW1lbnRlZFxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmXCI6XG4gICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgICBmaWxlLnR5cGUgPSBGaWxlSW5mb18xLkZpbGVUeXBlLkZpbGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIEEgJ3doaXRlb3V0JyBmaWxlIGlzIGFuIEFSVElGSUNJQUwgZW50cnkgaW4gYW55IG9mIHNldmVyYWwgdHlwZXMgb2ZcbiAgICAgICAgICAgIC8vICd0cmFuc2x1Y2VudCcgZmlsZXN5c3RlbXMsIG9mIHdoaWNoIGEgJ3VuaW9uJyBmaWxlc3lzdGVtIGlzIG9uZS5cbiAgICAgICAgICAgIGZpbGUudHlwZSA9IEZpbGVJbmZvXzEuRmlsZVR5cGUuVW5rbm93bjtcbiAgICB9XG4gICAgLy8gU2VwYXJhdGUgb3V0IHRoZSBsaW5rIG5hbWUgZm9yIHN5bWJvbGljIGxpbmtzXG4gICAgaWYgKGZpbGUuaXNTeW1ib2xpY0xpbmspIHtcbiAgICAgICAgY29uc3QgZW5kID0gbmFtZS5pbmRleE9mKFwiIC0+IFwiKTtcbiAgICAgICAgaWYgKGVuZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGZpbGUubmFtZSA9IG5hbWUuc3Vic3RyaW5nKDAsIGVuZCk7XG4gICAgICAgICAgICBmaWxlLmxpbmsgPSBuYW1lLnN1YnN0cmluZyhlbmQgKyA0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlsZTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUxpc3QoZmlsZXMpIHtcbiAgICByZXR1cm4gZmlsZXM7XG59XG5mdW5jdGlvbiBwYXJzZU1vZGUociwgdywgeCkge1xuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgaWYgKHIgIT09IFwiLVwiKSB7XG4gICAgICAgIHZhbHVlICs9IEZpbGVJbmZvXzEuRmlsZUluZm8uVW5peFBlcm1pc3Npb24uUmVhZDtcbiAgICB9XG4gICAgaWYgKHcgIT09IFwiLVwiKSB7XG4gICAgICAgIHZhbHVlICs9IEZpbGVJbmZvXzEuRmlsZUluZm8uVW5peFBlcm1pc3Npb24uV3JpdGU7XG4gICAgfVxuICAgIGNvbnN0IGV4ZWNUb2tlbiA9IHguY2hhckF0KDApO1xuICAgIGlmIChleGVjVG9rZW4gIT09IFwiLVwiICYmIGV4ZWNUb2tlbi50b1VwcGVyQ2FzZSgpICE9PSBleGVjVG9rZW4pIHtcbiAgICAgICAgdmFsdWUgKz0gRmlsZUluZm9fMS5GaWxlSW5mby5Vbml4UGVybWlzc2lvbi5FeGVjdXRlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ0ZXN0TGluZSIsInBhcnNlTGluZSIsInRyYW5zZm9ybUxpc3QiLCJGaWxlSW5mb18xIiwicmVxdWlyZSIsIkpBX01PTlRIIiwiSkFfREFZIiwiSkFfWUVBUiIsIlJFX0xJTkUiLCJSZWdFeHAiLCJsaW5lIiwidGVzdCIsImdyb3VwcyIsIm1hdGNoIiwidW5kZWZpbmVkIiwibmFtZSIsImZpbGUiLCJGaWxlSW5mbyIsInNpemUiLCJwYXJzZUludCIsInVzZXIiLCJncm91cCIsImhhcmRMaW5rQ291bnQiLCJyYXdNb2RpZmllZEF0IiwicGVybWlzc2lvbnMiLCJwYXJzZU1vZGUiLCJ3b3JsZCIsImNoYXJBdCIsInR5cGUiLCJGaWxlVHlwZSIsIkRpcmVjdG9yeSIsIlN5bWJvbGljTGluayIsIkZpbGUiLCJVbmtub3duIiwiaXNTeW1ib2xpY0xpbmsiLCJlbmQiLCJpbmRleE9mIiwic3Vic3RyaW5nIiwibGluayIsImZpbGVzIiwiciIsInciLCJ4IiwiVW5peFBlcm1pc3Npb24iLCJSZWFkIiwiV3JpdGUiLCJleGVjVG9rZW4iLCJ0b1VwcGVyQ2FzZSIsIkV4ZWN1dGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/basic-ftp/dist/parseListUnix.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/basic-ftp/dist/transfer.js":
/*!*****************************************************!*\
  !*** ../../node_modules/basic-ftp/dist/transfer.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.enterPassiveModeIPv6 = enterPassiveModeIPv6;\nexports.parseEpsvResponse = parseEpsvResponse;\nexports.enterPassiveModeIPv4 = enterPassiveModeIPv4;\nexports.enterPassiveModeIPv4_forceControlHostIP = enterPassiveModeIPv4_forceControlHostIP;\nexports.parsePasvResponse = parsePasvResponse;\nexports.connectForPassiveTransfer = connectForPassiveTransfer;\nexports.uploadFrom = uploadFrom;\nexports.downloadTo = downloadTo;\nconst netUtils_1 = __webpack_require__(/*! ./netUtils */ \"(rsc)/../../node_modules/basic-ftp/dist/netUtils.js\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst parseControlResponse_1 = __webpack_require__(/*! ./parseControlResponse */ \"(rsc)/../../node_modules/basic-ftp/dist/parseControlResponse.js\");\n/**\n * Prepare a data socket using passive mode over IPv6.\n */ async function enterPassiveModeIPv6(ftp) {\n    const res = await ftp.request(\"EPSV\");\n    const port = parseEpsvResponse(res.message);\n    if (!port) {\n        throw new Error(\"Can't parse EPSV response: \" + res.message);\n    }\n    const controlHost = ftp.socket.remoteAddress;\n    if (controlHost === undefined) {\n        throw new Error(\"Control socket is disconnected, can't get remote address.\");\n    }\n    await connectForPassiveTransfer(controlHost, port, ftp);\n    return res;\n}\n/**\n * Parse an EPSV response. Returns only the port as in EPSV the host of the control connection is used.\n */ function parseEpsvResponse(message) {\n    // Get port from EPSV response, e.g. \"229 Entering Extended Passive Mode (|||6446|)\"\n    // Some FTP Servers such as the one on IBM i (OS/400) use ! instead of | in their EPSV response.\n    const groups = message.match(/[|!]{3}(.+)[|!]/);\n    if (groups === null || groups[1] === undefined) {\n        throw new Error(`Can't parse response to 'EPSV': ${message}`);\n    }\n    const port = parseInt(groups[1], 10);\n    if (Number.isNaN(port)) {\n        throw new Error(`Can't parse response to 'EPSV', port is not a number: ${message}`);\n    }\n    return port;\n}\n/**\n * Prepare a data socket using passive mode over IPv4.\n */ async function enterPassiveModeIPv4(ftp) {\n    const res = await ftp.request(\"PASV\");\n    const target = parsePasvResponse(res.message);\n    if (!target) {\n        throw new Error(\"Can't parse PASV response: \" + res.message);\n    }\n    // If the host in the PASV response has a local address while the control connection hasn't,\n    // we assume a NAT issue and use the IP of the control connection as the target for the data connection.\n    // We can't always perform this replacement because it's possible (although unlikely) that the FTP server\n    // indeed uses a different host for data connections.\n    const controlHost = ftp.socket.remoteAddress;\n    if ((0, netUtils_1.ipIsPrivateV4Address)(target.host) && controlHost && !(0, netUtils_1.ipIsPrivateV4Address)(controlHost)) {\n        target.host = controlHost;\n    }\n    await connectForPassiveTransfer(target.host, target.port, ftp);\n    return res;\n}\n/**\n * Prepare a data socket using passive mode over IPv4. Ignore the IP provided by the PASV response,\n * and use the control host IP. This is the same behaviour as with the more modern variant EPSV. Use\n * this to fix issues around NAT or provide more security by preventing FTP bounce attacks.\n */ async function enterPassiveModeIPv4_forceControlHostIP(ftp) {\n    const res = await ftp.request(\"PASV\");\n    const target = parsePasvResponse(res.message);\n    if (!target) {\n        throw new Error(\"Can't parse PASV response: \" + res.message);\n    }\n    const controlHost = ftp.socket.remoteAddress;\n    if (controlHost === undefined) {\n        throw new Error(\"Control socket is disconnected, can't get remote address.\");\n    }\n    await connectForPassiveTransfer(controlHost, target.port, ftp);\n    return res;\n}\n/**\n * Parse a PASV response.\n */ function parsePasvResponse(message) {\n    // Get host and port from PASV response, e.g. \"227 Entering Passive Mode (192,168,1,100,10,229)\"\n    const groups = message.match(/([-\\d]+,[-\\d]+,[-\\d]+,[-\\d]+),([-\\d]+),([-\\d]+)/);\n    if (groups === null || groups.length !== 4) {\n        throw new Error(`Can't parse response to 'PASV': ${message}`);\n    }\n    return {\n        host: groups[1].replace(/,/g, \".\"),\n        port: (parseInt(groups[2], 10) & 255) * 256 + (parseInt(groups[3], 10) & 255)\n    };\n}\nfunction connectForPassiveTransfer(host, port, ftp) {\n    return new Promise((resolve, reject)=>{\n        let socket = ftp._newSocket();\n        const handleConnErr = function(err) {\n            err.message = \"Can't open data connection in passive mode: \" + err.message;\n            reject(err);\n        };\n        const handleTimeout = function() {\n            socket.destroy();\n            reject(new Error(`Timeout when trying to open data connection to ${host}:${port}`));\n        };\n        socket.setTimeout(ftp.timeout);\n        socket.on(\"error\", handleConnErr);\n        socket.on(\"timeout\", handleTimeout);\n        socket.connect({\n            port,\n            host,\n            family: ftp.ipFamily\n        }, ()=>{\n            if (ftp.socket instanceof tls_1.TLSSocket) {\n                socket = (0, tls_1.connect)(Object.assign({}, ftp.tlsOptions, {\n                    socket,\n                    // Reuse the TLS session negotiated earlier when the control connection\n                    // was upgraded. Servers expect this because it provides additional\n                    // security: If a completely new session would be negotiated, a hacker\n                    // could guess the port and connect to the new data connection before we do\n                    // by just starting his/her own TLS session.\n                    session: ftp.socket.getSession()\n                }));\n            // It's the responsibility of the transfer task to wait until the\n            // TLS socket issued the event 'secureConnect'. We can't do this\n            // here because some servers will start upgrading after the\n            // specific transfer request has been made. List and download don't\n            // have to wait for this event because the server sends whenever it\n            // is ready. But for upload this has to be taken into account,\n            // see the details in the upload() function below.\n            }\n            // Let the FTPContext listen to errors from now on, remove local handler.\n            socket.removeListener(\"error\", handleConnErr);\n            socket.removeListener(\"timeout\", handleTimeout);\n            ftp.dataSocket = socket;\n            resolve();\n        });\n    });\n}\n/**\n * Helps resolving/rejecting transfers.\n *\n * This is used internally for all FTP transfers. For example when downloading, the server might confirm\n * with \"226 Transfer complete\" when in fact the download on the data connection has not finished\n * yet. With all transfers we make sure that a) the result arrived and b) has been confirmed by\n * e.g. the control connection. We just don't know in which order this will happen.\n */ class TransferResolver {\n    /**\n     * Instantiate a TransferResolver\n     */ constructor(ftp, progress){\n        this.ftp = ftp;\n        this.progress = progress;\n        this.response = undefined;\n        this.dataTransferDone = false;\n    }\n    /**\n     * Mark the beginning of a transfer.\n     *\n     * @param name - Name of the transfer, usually the filename.\n     * @param type - Type of transfer, usually \"upload\" or \"download\".\n     */ onDataStart(name, type) {\n        // Let the data socket be in charge of tracking timeouts during transfer.\n        // The control socket sits idle during this time anyway and might provoke\n        // a timeout unnecessarily. The control connection will take care\n        // of timeouts again once data transfer is complete or failed.\n        if (this.ftp.dataSocket === undefined) {\n            throw new Error(\"Data transfer should start but there is no data connection.\");\n        }\n        this.ftp.socket.setTimeout(0);\n        this.ftp.dataSocket.setTimeout(this.ftp.timeout);\n        this.progress.start(this.ftp.dataSocket, name, type);\n    }\n    /**\n     * The data connection has finished the transfer.\n     */ onDataDone(task) {\n        this.progress.updateAndStop();\n        // Hand-over timeout tracking back to the control connection. It's possible that\n        // we don't receive the response over the control connection that the transfer is\n        // done. In this case, we want to correctly associate the resulting timeout with\n        // the control connection.\n        this.ftp.socket.setTimeout(this.ftp.timeout);\n        if (this.ftp.dataSocket) {\n            this.ftp.dataSocket.setTimeout(0);\n        }\n        this.dataTransferDone = true;\n        this.tryResolve(task);\n    }\n    /**\n     * The control connection reports the transfer as finished.\n     */ onControlDone(task, response) {\n        this.response = response;\n        this.tryResolve(task);\n    }\n    /**\n     * An error has been reported and the task should be rejected.\n     */ onError(task, err) {\n        this.progress.updateAndStop();\n        this.ftp.socket.setTimeout(this.ftp.timeout);\n        this.ftp.dataSocket = undefined;\n        task.reject(err);\n    }\n    /**\n     * Control connection sent an unexpected request requiring a response from our part. We\n     * can't provide that (because unknown) and have to close the contrext with an error because\n     * the FTP server is now caught up in a state we can't resolve.\n     */ onUnexpectedRequest(response) {\n        const err = new Error(`Unexpected FTP response is requesting an answer: ${response.message}`);\n        this.ftp.closeWithError(err);\n    }\n    tryResolve(task) {\n        // To resolve, we need both control and data connection to report that the transfer is done.\n        const canResolve = this.dataTransferDone && this.response !== undefined;\n        if (canResolve) {\n            this.ftp.dataSocket = undefined;\n            task.resolve(this.response);\n        }\n    }\n}\nfunction uploadFrom(source, config) {\n    const resolver = new TransferResolver(config.ftp, config.tracker);\n    const fullCommand = `${config.command} ${config.remotePath}`;\n    return config.ftp.handle(fullCommand, (res, task)=>{\n        if (res instanceof Error) {\n            resolver.onError(task, res);\n        } else if (res.code === 150 || res.code === 125) {\n            const dataSocket = config.ftp.dataSocket;\n            if (!dataSocket) {\n                resolver.onError(task, new Error(\"Upload should begin but no data connection is available.\"));\n                return;\n            }\n            // If we are using TLS, we have to wait until the dataSocket issued\n            // 'secureConnect'. If this hasn't happened yet, getCipher() returns undefined.\n            const canUpload = \"getCipher\" in dataSocket ? dataSocket.getCipher() !== undefined : true;\n            onConditionOrEvent(canUpload, dataSocket, \"secureConnect\", ()=>{\n                config.ftp.log(`Uploading to ${(0, netUtils_1.describeAddress)(dataSocket)} (${(0, netUtils_1.describeTLS)(dataSocket)})`);\n                resolver.onDataStart(config.remotePath, config.type);\n                (0, stream_1.pipeline)(source, dataSocket, (err)=>{\n                    if (err) {\n                        resolver.onError(task, err);\n                    } else {\n                        resolver.onDataDone(task);\n                    }\n                });\n            });\n        } else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {\n            resolver.onControlDone(task, res);\n        } else if ((0, parseControlResponse_1.positiveIntermediate)(res.code)) {\n            resolver.onUnexpectedRequest(res);\n        }\n    // Ignore all other positive preliminary response codes (< 200)\n    });\n}\nfunction downloadTo(destination, config) {\n    if (!config.ftp.dataSocket) {\n        throw new Error(\"Download will be initiated but no data connection is available.\");\n    }\n    const resolver = new TransferResolver(config.ftp, config.tracker);\n    return config.ftp.handle(config.command, (res, task)=>{\n        if (res instanceof Error) {\n            resolver.onError(task, res);\n        } else if (res.code === 150 || res.code === 125) {\n            const dataSocket = config.ftp.dataSocket;\n            if (!dataSocket) {\n                resolver.onError(task, new Error(\"Download should begin but no data connection is available.\"));\n                return;\n            }\n            config.ftp.log(`Downloading from ${(0, netUtils_1.describeAddress)(dataSocket)} (${(0, netUtils_1.describeTLS)(dataSocket)})`);\n            resolver.onDataStart(config.remotePath, config.type);\n            (0, stream_1.pipeline)(dataSocket, destination, (err)=>{\n                if (err) {\n                    resolver.onError(task, err);\n                } else {\n                    resolver.onDataDone(task);\n                }\n            });\n        } else if (res.code === 350) {\n            config.ftp.send(\"RETR \" + config.remotePath);\n        } else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {\n            resolver.onControlDone(task, res);\n        } else if ((0, parseControlResponse_1.positiveIntermediate)(res.code)) {\n            resolver.onUnexpectedRequest(res);\n        }\n    // Ignore all other positive preliminary response codes (< 200)\n    });\n}\n/**\n * Calls a function immediately if a condition is met or subscribes to an event and calls\n * it once the event is emitted.\n *\n * @param condition  The condition to test.\n * @param emitter  The emitter to use if the condition is not met.\n * @param eventName  The event to subscribe to if the condition is not met.\n * @param action  The function to call.\n */ function onConditionOrEvent(condition, emitter, eventName, action) {\n    if (condition === true) {\n        action();\n    } else {\n        emitter.once(eventName, ()=>action());\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2ljLWZ0cC9kaXN0L3RyYW5zZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw0QkFBNEIsR0FBR0U7QUFDL0JGLHlCQUF5QixHQUFHRztBQUM1QkgsNEJBQTRCLEdBQUdJO0FBQy9CSiwrQ0FBK0MsR0FBR0s7QUFDbERMLHlCQUF5QixHQUFHTTtBQUM1Qk4saUNBQWlDLEdBQUdPO0FBQ3BDUCxrQkFBa0IsR0FBR1E7QUFDckJSLGtCQUFrQixHQUFHUztBQUNyQixNQUFNQyxhQUFhQyxtQkFBT0EsQ0FBQyx1RUFBWTtBQUN2QyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNRSxRQUFRRixtQkFBT0EsQ0FBQyxnQkFBSztBQUMzQixNQUFNRyx5QkFBeUJILG1CQUFPQSxDQUFDLCtGQUF3QjtBQUMvRDs7Q0FFQyxHQUNELGVBQWVULHFCQUFxQmEsR0FBRztJQUNuQyxNQUFNQyxNQUFNLE1BQU1ELElBQUlFLE9BQU8sQ0FBQztJQUM5QixNQUFNQyxPQUFPZixrQkFBa0JhLElBQUlHLE9BQU87SUFDMUMsSUFBSSxDQUFDRCxNQUFNO1FBQ1AsTUFBTSxJQUFJRSxNQUFNLGdDQUFnQ0osSUFBSUcsT0FBTztJQUMvRDtJQUNBLE1BQU1FLGNBQWNOLElBQUlPLE1BQU0sQ0FBQ0MsYUFBYTtJQUM1QyxJQUFJRixnQkFBZ0JHLFdBQVc7UUFDM0IsTUFBTSxJQUFJSixNQUFNO0lBQ3BCO0lBQ0EsTUFBTWIsMEJBQTBCYyxhQUFhSCxNQUFNSDtJQUNuRCxPQUFPQztBQUNYO0FBQ0E7O0NBRUMsR0FDRCxTQUFTYixrQkFBa0JnQixPQUFPO0lBQzlCLG9GQUFvRjtJQUNwRixnR0FBZ0c7SUFDaEcsTUFBTU0sU0FBU04sUUFBUU8sS0FBSyxDQUFDO0lBQzdCLElBQUlELFdBQVcsUUFBUUEsTUFBTSxDQUFDLEVBQUUsS0FBS0QsV0FB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LCtEQUErRDtJQUNuRTtBQUNKO0FBQ0E7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTcUUsbUJBQW1CUyxTQUFTLEVBQUVDLE9BQU8sRUFBRUMsU0FBUyxFQUFFQyxNQUFNO0lBQzdELElBQUlILGNBQWMsTUFBTTtRQUNwQkc7SUFDSixPQUNLO1FBQ0RGLFFBQVFHLElBQUksQ0FBQ0YsV0FBVyxJQUFNQztJQUNsQztBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9iYXNpYy1mdHAvZGlzdC90cmFuc2Zlci5qcz80ODM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbnRlclBhc3NpdmVNb2RlSVB2NiA9IGVudGVyUGFzc2l2ZU1vZGVJUHY2O1xuZXhwb3J0cy5wYXJzZUVwc3ZSZXNwb25zZSA9IHBhcnNlRXBzdlJlc3BvbnNlO1xuZXhwb3J0cy5lbnRlclBhc3NpdmVNb2RlSVB2NCA9IGVudGVyUGFzc2l2ZU1vZGVJUHY0O1xuZXhwb3J0cy5lbnRlclBhc3NpdmVNb2RlSVB2NF9mb3JjZUNvbnRyb2xIb3N0SVAgPSBlbnRlclBhc3NpdmVNb2RlSVB2NF9mb3JjZUNvbnRyb2xIb3N0SVA7XG5leHBvcnRzLnBhcnNlUGFzdlJlc3BvbnNlID0gcGFyc2VQYXN2UmVzcG9uc2U7XG5leHBvcnRzLmNvbm5lY3RGb3JQYXNzaXZlVHJhbnNmZXIgPSBjb25uZWN0Rm9yUGFzc2l2ZVRyYW5zZmVyO1xuZXhwb3J0cy51cGxvYWRGcm9tID0gdXBsb2FkRnJvbTtcbmV4cG9ydHMuZG93bmxvYWRUbyA9IGRvd25sb2FkVG87XG5jb25zdCBuZXRVdGlsc18xID0gcmVxdWlyZShcIi4vbmV0VXRpbHNcIik7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCB0bHNfMSA9IHJlcXVpcmUoXCJ0bHNcIik7XG5jb25zdCBwYXJzZUNvbnRyb2xSZXNwb25zZV8xID0gcmVxdWlyZShcIi4vcGFyc2VDb250cm9sUmVzcG9uc2VcIik7XG4vKipcbiAqIFByZXBhcmUgYSBkYXRhIHNvY2tldCB1c2luZyBwYXNzaXZlIG1vZGUgb3ZlciBJUHY2LlxuICovXG5hc3luYyBmdW5jdGlvbiBlbnRlclBhc3NpdmVNb2RlSVB2NihmdHApIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmdHAucmVxdWVzdChcIkVQU1ZcIik7XG4gICAgY29uc3QgcG9ydCA9IHBhcnNlRXBzdlJlc3BvbnNlKHJlcy5tZXNzYWdlKTtcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGFyc2UgRVBTViByZXNwb25zZTogXCIgKyByZXMubWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRyb2xIb3N0ID0gZnRwLnNvY2tldC5yZW1vdGVBZGRyZXNzO1xuICAgIGlmIChjb250cm9sSG9zdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRyb2wgc29ja2V0IGlzIGRpc2Nvbm5lY3RlZCwgY2FuJ3QgZ2V0IHJlbW90ZSBhZGRyZXNzLlwiKTtcbiAgICB9XG4gICAgYXdhaXQgY29ubmVjdEZvclBhc3NpdmVUcmFuc2Zlcihjb250cm9sSG9zdCwgcG9ydCwgZnRwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBQYXJzZSBhbiBFUFNWIHJlc3BvbnNlLiBSZXR1cm5zIG9ubHkgdGhlIHBvcnQgYXMgaW4gRVBTViB0aGUgaG9zdCBvZiB0aGUgY29udHJvbCBjb25uZWN0aW9uIGlzIHVzZWQuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRXBzdlJlc3BvbnNlKG1lc3NhZ2UpIHtcbiAgICAvLyBHZXQgcG9ydCBmcm9tIEVQU1YgcmVzcG9uc2UsIGUuZy4gXCIyMjkgRW50ZXJpbmcgRXh0ZW5kZWQgUGFzc2l2ZSBNb2RlICh8fHw2NDQ2fClcIlxuICAgIC8vIFNvbWUgRlRQIFNlcnZlcnMgc3VjaCBhcyB0aGUgb25lIG9uIElCTSBpIChPUy80MDApIHVzZSAhIGluc3RlYWQgb2YgfCBpbiB0aGVpciBFUFNWIHJlc3BvbnNlLlxuICAgIGNvbnN0IGdyb3VwcyA9IG1lc3NhZ2UubWF0Y2goL1t8IV17M30oLispW3whXS8pO1xuICAgIGlmIChncm91cHMgPT09IG51bGwgfHwgZ3JvdXBzWzFdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBwYXJzZSByZXNwb25zZSB0byAnRVBTVic6ICR7bWVzc2FnZX1gKTtcbiAgICB9XG4gICAgY29uc3QgcG9ydCA9IHBhcnNlSW50KGdyb3Vwc1sxXSwgMTApO1xuICAgIGlmIChOdW1iZXIuaXNOYU4ocG9ydCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBwYXJzZSByZXNwb25zZSB0byAnRVBTVicsIHBvcnQgaXMgbm90IGEgbnVtYmVyOiAke21lc3NhZ2V9YCk7XG4gICAgfVxuICAgIHJldHVybiBwb3J0O1xufVxuLyoqXG4gKiBQcmVwYXJlIGEgZGF0YSBzb2NrZXQgdXNpbmcgcGFzc2l2ZSBtb2RlIG92ZXIgSVB2NC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZW50ZXJQYXNzaXZlTW9kZUlQdjQoZnRwKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZnRwLnJlcXVlc3QoXCJQQVNWXCIpO1xuICAgIGNvbnN0IHRhcmdldCA9IHBhcnNlUGFzdlJlc3BvbnNlKHJlcy5tZXNzYWdlKTtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwYXJzZSBQQVNWIHJlc3BvbnNlOiBcIiArIHJlcy5tZXNzYWdlKTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGhvc3QgaW4gdGhlIFBBU1YgcmVzcG9uc2UgaGFzIGEgbG9jYWwgYWRkcmVzcyB3aGlsZSB0aGUgY29udHJvbCBjb25uZWN0aW9uIGhhc24ndCxcbiAgICAvLyB3ZSBhc3N1bWUgYSBOQVQgaXNzdWUgYW5kIHVzZSB0aGUgSVAgb2YgdGhlIGNvbnRyb2wgY29ubmVjdGlvbiBhcyB0aGUgdGFyZ2V0IGZvciB0aGUgZGF0YSBjb25uZWN0aW9uLlxuICAgIC8vIFdlIGNhbid0IGFsd2F5cyBwZXJmb3JtIHRoaXMgcmVwbGFjZW1lbnQgYmVjYXVzZSBpdCdzIHBvc3NpYmxlIChhbHRob3VnaCB1bmxpa2VseSkgdGhhdCB0aGUgRlRQIHNlcnZlclxuICAgIC8vIGluZGVlZCB1c2VzIGEgZGlmZmVyZW50IGhvc3QgZm9yIGRhdGEgY29ubmVjdGlvbnMuXG4gICAgY29uc3QgY29udHJvbEhvc3QgPSBmdHAuc29ja2V0LnJlbW90ZUFkZHJlc3M7XG4gICAgaWYgKCgwLCBuZXRVdGlsc18xLmlwSXNQcml2YXRlVjRBZGRyZXNzKSh0YXJnZXQuaG9zdCkgJiYgY29udHJvbEhvc3QgJiYgISgwLCBuZXRVdGlsc18xLmlwSXNQcml2YXRlVjRBZGRyZXNzKShjb250cm9sSG9zdCkpIHtcbiAgICAgICAgdGFyZ2V0Lmhvc3QgPSBjb250cm9sSG9zdDtcbiAgICB9XG4gICAgYXdhaXQgY29ubmVjdEZvclBhc3NpdmVUcmFuc2Zlcih0YXJnZXQuaG9zdCwgdGFyZ2V0LnBvcnQsIGZ0cCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogUHJlcGFyZSBhIGRhdGEgc29ja2V0IHVzaW5nIHBhc3NpdmUgbW9kZSBvdmVyIElQdjQuIElnbm9yZSB0aGUgSVAgcHJvdmlkZWQgYnkgdGhlIFBBU1YgcmVzcG9uc2UsXG4gKiBhbmQgdXNlIHRoZSBjb250cm9sIGhvc3QgSVAuIFRoaXMgaXMgdGhlIHNhbWUgYmVoYXZpb3VyIGFzIHdpdGggdGhlIG1vcmUgbW9kZXJuIHZhcmlhbnQgRVBTVi4gVXNlXG4gKiB0aGlzIHRvIGZpeCBpc3N1ZXMgYXJvdW5kIE5BVCBvciBwcm92aWRlIG1vcmUgc2VjdXJpdHkgYnkgcHJldmVudGluZyBGVFAgYm91bmNlIGF0dGFja3MuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGVudGVyUGFzc2l2ZU1vZGVJUHY0X2ZvcmNlQ29udHJvbEhvc3RJUChmdHApIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmdHAucmVxdWVzdChcIlBBU1ZcIik7XG4gICAgY29uc3QgdGFyZ2V0ID0gcGFyc2VQYXN2UmVzcG9uc2UocmVzLm1lc3NhZ2UpO1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBhcnNlIFBBU1YgcmVzcG9uc2U6IFwiICsgcmVzLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBjb250cm9sSG9zdCA9IGZ0cC5zb2NrZXQucmVtb3RlQWRkcmVzcztcbiAgICBpZiAoY29udHJvbEhvc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250cm9sIHNvY2tldCBpcyBkaXNjb25uZWN0ZWQsIGNhbid0IGdldCByZW1vdGUgYWRkcmVzcy5cIik7XG4gICAgfVxuICAgIGF3YWl0IGNvbm5lY3RGb3JQYXNzaXZlVHJhbnNmZXIoY29udHJvbEhvc3QsIHRhcmdldC5wb3J0LCBmdHApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIFBhcnNlIGEgUEFTViByZXNwb25zZS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VQYXN2UmVzcG9uc2UobWVzc2FnZSkge1xuICAgIC8vIEdldCBob3N0IGFuZCBwb3J0IGZyb20gUEFTViByZXNwb25zZSwgZS5nLiBcIjIyNyBFbnRlcmluZyBQYXNzaXZlIE1vZGUgKDE5MiwxNjgsMSwxMDAsMTAsMjI5KVwiXG4gICAgY29uc3QgZ3JvdXBzID0gbWVzc2FnZS5tYXRjaCgvKFstXFxkXSssWy1cXGRdKyxbLVxcZF0rLFstXFxkXSspLChbLVxcZF0rKSwoWy1cXGRdKykvKTtcbiAgICBpZiAoZ3JvdXBzID09PSBudWxsIHx8IGdyb3Vwcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBwYXJzZSByZXNwb25zZSB0byAnUEFTVic6ICR7bWVzc2FnZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaG9zdDogZ3JvdXBzWzFdLnJlcGxhY2UoLywvZywgXCIuXCIpLFxuICAgICAgICBwb3J0OiAocGFyc2VJbnQoZ3JvdXBzWzJdLCAxMCkgJiAyNTUpICogMjU2ICsgKHBhcnNlSW50KGdyb3Vwc1szXSwgMTApICYgMjU1KVxuICAgIH07XG59XG5mdW5jdGlvbiBjb25uZWN0Rm9yUGFzc2l2ZVRyYW5zZmVyKGhvc3QsIHBvcnQsIGZ0cCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCBzb2NrZXQgPSBmdHAuX25ld1NvY2tldCgpO1xuICAgICAgICBjb25zdCBoYW5kbGVDb25uRXJyID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBcIkNhbid0IG9wZW4gZGF0YSBjb25uZWN0aW9uIGluIHBhc3NpdmUgbW9kZTogXCIgKyBlcnIubWVzc2FnZTtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYW5kbGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFRpbWVvdXQgd2hlbiB0cnlpbmcgdG8gb3BlbiBkYXRhIGNvbm5lY3Rpb24gdG8gJHtob3N0fToke3BvcnR9YCkpO1xuICAgICAgICB9O1xuICAgICAgICBzb2NrZXQuc2V0VGltZW91dChmdHAudGltZW91dCk7XG4gICAgICAgIHNvY2tldC5vbihcImVycm9yXCIsIGhhbmRsZUNvbm5FcnIpO1xuICAgICAgICBzb2NrZXQub24oXCJ0aW1lb3V0XCIsIGhhbmRsZVRpbWVvdXQpO1xuICAgICAgICBzb2NrZXQuY29ubmVjdCh7IHBvcnQsIGhvc3QsIGZhbWlseTogZnRwLmlwRmFtaWx5IH0sICgpID0+IHtcbiAgICAgICAgICAgIGlmIChmdHAuc29ja2V0IGluc3RhbmNlb2YgdGxzXzEuVExTU29ja2V0KSB7XG4gICAgICAgICAgICAgICAgc29ja2V0ID0gKDAsIHRsc18xLmNvbm5lY3QpKE9iamVjdC5hc3NpZ24oe30sIGZ0cC50bHNPcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV1c2UgdGhlIFRMUyBzZXNzaW9uIG5lZ290aWF0ZWQgZWFybGllciB3aGVuIHRoZSBjb250cm9sIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gd2FzIHVwZ3JhZGVkLiBTZXJ2ZXJzIGV4cGVjdCB0aGlzIGJlY2F1c2UgaXQgcHJvdmlkZXMgYWRkaXRpb25hbFxuICAgICAgICAgICAgICAgICAgICAvLyBzZWN1cml0eTogSWYgYSBjb21wbGV0ZWx5IG5ldyBzZXNzaW9uIHdvdWxkIGJlIG5lZ290aWF0ZWQsIGEgaGFja2VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvdWxkIGd1ZXNzIHRoZSBwb3J0IGFuZCBjb25uZWN0IHRvIHRoZSBuZXcgZGF0YSBjb25uZWN0aW9uIGJlZm9yZSB3ZSBkb1xuICAgICAgICAgICAgICAgICAgICAvLyBieSBqdXN0IHN0YXJ0aW5nIGhpcy9oZXIgb3duIFRMUyBzZXNzaW9uLlxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uOiBmdHAuc29ja2V0LmdldFNlc3Npb24oKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgdHJhbnNmZXIgdGFzayB0byB3YWl0IHVudGlsIHRoZVxuICAgICAgICAgICAgICAgIC8vIFRMUyBzb2NrZXQgaXNzdWVkIHRoZSBldmVudCAnc2VjdXJlQ29ubmVjdCcuIFdlIGNhbid0IGRvIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBoZXJlIGJlY2F1c2Ugc29tZSBzZXJ2ZXJzIHdpbGwgc3RhcnQgdXBncmFkaW5nIGFmdGVyIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHRyYW5zZmVyIHJlcXVlc3QgaGFzIGJlZW4gbWFkZS4gTGlzdCBhbmQgZG93bmxvYWQgZG9uJ3RcbiAgICAgICAgICAgICAgICAvLyBoYXZlIHRvIHdhaXQgZm9yIHRoaXMgZXZlbnQgYmVjYXVzZSB0aGUgc2VydmVyIHNlbmRzIHdoZW5ldmVyIGl0XG4gICAgICAgICAgICAgICAgLy8gaXMgcmVhZHkuIEJ1dCBmb3IgdXBsb2FkIHRoaXMgaGFzIHRvIGJlIHRha2VuIGludG8gYWNjb3VudCxcbiAgICAgICAgICAgICAgICAvLyBzZWUgdGhlIGRldGFpbHMgaW4gdGhlIHVwbG9hZCgpIGZ1bmN0aW9uIGJlbG93LlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGV0IHRoZSBGVFBDb250ZXh0IGxpc3RlbiB0byBlcnJvcnMgZnJvbSBub3cgb24sIHJlbW92ZSBsb2NhbCBoYW5kbGVyLlxuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgaGFuZGxlQ29ubkVycik7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoXCJ0aW1lb3V0XCIsIGhhbmRsZVRpbWVvdXQpO1xuICAgICAgICAgICAgZnRwLmRhdGFTb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLyoqXG4gKiBIZWxwcyByZXNvbHZpbmcvcmVqZWN0aW5nIHRyYW5zZmVycy5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxseSBmb3IgYWxsIEZUUCB0cmFuc2ZlcnMuIEZvciBleGFtcGxlIHdoZW4gZG93bmxvYWRpbmcsIHRoZSBzZXJ2ZXIgbWlnaHQgY29uZmlybVxuICogd2l0aCBcIjIyNiBUcmFuc2ZlciBjb21wbGV0ZVwiIHdoZW4gaW4gZmFjdCB0aGUgZG93bmxvYWQgb24gdGhlIGRhdGEgY29ubmVjdGlvbiBoYXMgbm90IGZpbmlzaGVkXG4gKiB5ZXQuIFdpdGggYWxsIHRyYW5zZmVycyB3ZSBtYWtlIHN1cmUgdGhhdCBhKSB0aGUgcmVzdWx0IGFycml2ZWQgYW5kIGIpIGhhcyBiZWVuIGNvbmZpcm1lZCBieVxuICogZS5nLiB0aGUgY29udHJvbCBjb25uZWN0aW9uLiBXZSBqdXN0IGRvbid0IGtub3cgaW4gd2hpY2ggb3JkZXIgdGhpcyB3aWxsIGhhcHBlbi5cbiAqL1xuY2xhc3MgVHJhbnNmZXJSZXNvbHZlciB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYSBUcmFuc2ZlclJlc29sdmVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnRwLCBwcm9ncmVzcykge1xuICAgICAgICB0aGlzLmZ0cCA9IGZ0cDtcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRhdGFUcmFuc2ZlckRvbmUgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFyayB0aGUgYmVnaW5uaW5nIG9mIGEgdHJhbnNmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSAtIE5hbWUgb2YgdGhlIHRyYW5zZmVyLCB1c3VhbGx5IHRoZSBmaWxlbmFtZS5cbiAgICAgKiBAcGFyYW0gdHlwZSAtIFR5cGUgb2YgdHJhbnNmZXIsIHVzdWFsbHkgXCJ1cGxvYWRcIiBvciBcImRvd25sb2FkXCIuXG4gICAgICovXG4gICAgb25EYXRhU3RhcnQobmFtZSwgdHlwZSkge1xuICAgICAgICAvLyBMZXQgdGhlIGRhdGEgc29ja2V0IGJlIGluIGNoYXJnZSBvZiB0cmFja2luZyB0aW1lb3V0cyBkdXJpbmcgdHJhbnNmZXIuXG4gICAgICAgIC8vIFRoZSBjb250cm9sIHNvY2tldCBzaXRzIGlkbGUgZHVyaW5nIHRoaXMgdGltZSBhbnl3YXkgYW5kIG1pZ2h0IHByb3Zva2VcbiAgICAgICAgLy8gYSB0aW1lb3V0IHVubmVjZXNzYXJpbHkuIFRoZSBjb250cm9sIGNvbm5lY3Rpb24gd2lsbCB0YWtlIGNhcmVcbiAgICAgICAgLy8gb2YgdGltZW91dHMgYWdhaW4gb25jZSBkYXRhIHRyYW5zZmVyIGlzIGNvbXBsZXRlIG9yIGZhaWxlZC5cbiAgICAgICAgaWYgKHRoaXMuZnRwLmRhdGFTb2NrZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSB0cmFuc2ZlciBzaG91bGQgc3RhcnQgYnV0IHRoZXJlIGlzIG5vIGRhdGEgY29ubmVjdGlvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mdHAuc29ja2V0LnNldFRpbWVvdXQoMCk7XG4gICAgICAgIHRoaXMuZnRwLmRhdGFTb2NrZXQuc2V0VGltZW91dCh0aGlzLmZ0cC50aW1lb3V0KTtcbiAgICAgICAgdGhpcy5wcm9ncmVzcy5zdGFydCh0aGlzLmZ0cC5kYXRhU29ja2V0LCBuYW1lLCB0eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGRhdGEgY29ubmVjdGlvbiBoYXMgZmluaXNoZWQgdGhlIHRyYW5zZmVyLlxuICAgICAqL1xuICAgIG9uRGF0YURvbmUodGFzaykge1xuICAgICAgICB0aGlzLnByb2dyZXNzLnVwZGF0ZUFuZFN0b3AoKTtcbiAgICAgICAgLy8gSGFuZC1vdmVyIHRpbWVvdXQgdHJhY2tpbmcgYmFjayB0byB0aGUgY29udHJvbCBjb25uZWN0aW9uLiBJdCdzIHBvc3NpYmxlIHRoYXRcbiAgICAgICAgLy8gd2UgZG9uJ3QgcmVjZWl2ZSB0aGUgcmVzcG9uc2Ugb3ZlciB0aGUgY29udHJvbCBjb25uZWN0aW9uIHRoYXQgdGhlIHRyYW5zZmVyIGlzXG4gICAgICAgIC8vIGRvbmUuIEluIHRoaXMgY2FzZSwgd2Ugd2FudCB0byBjb3JyZWN0bHkgYXNzb2NpYXRlIHRoZSByZXN1bHRpbmcgdGltZW91dCB3aXRoXG4gICAgICAgIC8vIHRoZSBjb250cm9sIGNvbm5lY3Rpb24uXG4gICAgICAgIHRoaXMuZnRwLnNvY2tldC5zZXRUaW1lb3V0KHRoaXMuZnRwLnRpbWVvdXQpO1xuICAgICAgICBpZiAodGhpcy5mdHAuZGF0YVNvY2tldCkge1xuICAgICAgICAgICAgdGhpcy5mdHAuZGF0YVNvY2tldC5zZXRUaW1lb3V0KDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YVRyYW5zZmVyRG9uZSA9IHRydWU7XG4gICAgICAgIHRoaXMudHJ5UmVzb2x2ZSh0YXNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRyb2wgY29ubmVjdGlvbiByZXBvcnRzIHRoZSB0cmFuc2ZlciBhcyBmaW5pc2hlZC5cbiAgICAgKi9cbiAgICBvbkNvbnRyb2xEb25lKHRhc2ssIHJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgdGhpcy50cnlSZXNvbHZlKHRhc2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBlcnJvciBoYXMgYmVlbiByZXBvcnRlZCBhbmQgdGhlIHRhc2sgc2hvdWxkIGJlIHJlamVjdGVkLlxuICAgICAqL1xuICAgIG9uRXJyb3IodGFzaywgZXJyKSB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MudXBkYXRlQW5kU3RvcCgpO1xuICAgICAgICB0aGlzLmZ0cC5zb2NrZXQuc2V0VGltZW91dCh0aGlzLmZ0cC50aW1lb3V0KTtcbiAgICAgICAgdGhpcy5mdHAuZGF0YVNvY2tldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGFzay5yZWplY3QoZXJyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udHJvbCBjb25uZWN0aW9uIHNlbnQgYW4gdW5leHBlY3RlZCByZXF1ZXN0IHJlcXVpcmluZyBhIHJlc3BvbnNlIGZyb20gb3VyIHBhcnQuIFdlXG4gICAgICogY2FuJ3QgcHJvdmlkZSB0aGF0IChiZWNhdXNlIHVua25vd24pIGFuZCBoYXZlIHRvIGNsb3NlIHRoZSBjb250cmV4dCB3aXRoIGFuIGVycm9yIGJlY2F1c2VcbiAgICAgKiB0aGUgRlRQIHNlcnZlciBpcyBub3cgY2F1Z2h0IHVwIGluIGEgc3RhdGUgd2UgY2FuJ3QgcmVzb2x2ZS5cbiAgICAgKi9cbiAgICBvblVuZXhwZWN0ZWRSZXF1ZXN0KHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgVW5leHBlY3RlZCBGVFAgcmVzcG9uc2UgaXMgcmVxdWVzdGluZyBhbiBhbnN3ZXI6ICR7cmVzcG9uc2UubWVzc2FnZX1gKTtcbiAgICAgICAgdGhpcy5mdHAuY2xvc2VXaXRoRXJyb3IoZXJyKTtcbiAgICB9XG4gICAgdHJ5UmVzb2x2ZSh0YXNrKSB7XG4gICAgICAgIC8vIFRvIHJlc29sdmUsIHdlIG5lZWQgYm90aCBjb250cm9sIGFuZCBkYXRhIGNvbm5lY3Rpb24gdG8gcmVwb3J0IHRoYXQgdGhlIHRyYW5zZmVyIGlzIGRvbmUuXG4gICAgICAgIGNvbnN0IGNhblJlc29sdmUgPSB0aGlzLmRhdGFUcmFuc2ZlckRvbmUgJiYgdGhpcy5yZXNwb25zZSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoY2FuUmVzb2x2ZSkge1xuICAgICAgICAgICAgdGhpcy5mdHAuZGF0YVNvY2tldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRhc2sucmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHVwbG9hZEZyb20oc291cmNlLCBjb25maWcpIHtcbiAgICBjb25zdCByZXNvbHZlciA9IG5ldyBUcmFuc2ZlclJlc29sdmVyKGNvbmZpZy5mdHAsIGNvbmZpZy50cmFja2VyKTtcbiAgICBjb25zdCBmdWxsQ29tbWFuZCA9IGAke2NvbmZpZy5jb21tYW5kfSAke2NvbmZpZy5yZW1vdGVQYXRofWA7XG4gICAgcmV0dXJuIGNvbmZpZy5mdHAuaGFuZGxlKGZ1bGxDb21tYW5kLCAocmVzLCB0YXNrKSA9PiB7XG4gICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmVzb2x2ZXIub25FcnJvcih0YXNrLCByZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcy5jb2RlID09PSAxNTAgfHwgcmVzLmNvZGUgPT09IDEyNSkgeyAvLyBSZWFkeSB0byB1cGxvYWRcbiAgICAgICAgICAgIGNvbnN0IGRhdGFTb2NrZXQgPSBjb25maWcuZnRwLmRhdGFTb2NrZXQ7XG4gICAgICAgICAgICBpZiAoIWRhdGFTb2NrZXQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlci5vbkVycm9yKHRhc2ssIG5ldyBFcnJvcihcIlVwbG9hZCBzaG91bGQgYmVnaW4gYnV0IG5vIGRhdGEgY29ubmVjdGlvbiBpcyBhdmFpbGFibGUuXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgdXNpbmcgVExTLCB3ZSBoYXZlIHRvIHdhaXQgdW50aWwgdGhlIGRhdGFTb2NrZXQgaXNzdWVkXG4gICAgICAgICAgICAvLyAnc2VjdXJlQ29ubmVjdCcuIElmIHRoaXMgaGFzbid0IGhhcHBlbmVkIHlldCwgZ2V0Q2lwaGVyKCkgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgICAgICAgICBjb25zdCBjYW5VcGxvYWQgPSBcImdldENpcGhlclwiIGluIGRhdGFTb2NrZXQgPyBkYXRhU29ja2V0LmdldENpcGhlcigpICE9PSB1bmRlZmluZWQgOiB0cnVlO1xuICAgICAgICAgICAgb25Db25kaXRpb25PckV2ZW50KGNhblVwbG9hZCwgZGF0YVNvY2tldCwgXCJzZWN1cmVDb25uZWN0XCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25maWcuZnRwLmxvZyhgVXBsb2FkaW5nIHRvICR7KDAsIG5ldFV0aWxzXzEuZGVzY3JpYmVBZGRyZXNzKShkYXRhU29ja2V0KX0gKCR7KDAsIG5ldFV0aWxzXzEuZGVzY3JpYmVUTFMpKGRhdGFTb2NrZXQpfSlgKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlci5vbkRhdGFTdGFydChjb25maWcucmVtb3RlUGF0aCwgY29uZmlnLnR5cGUpO1xuICAgICAgICAgICAgICAgICgwLCBzdHJlYW1fMS5waXBlbGluZSkoc291cmNlLCBkYXRhU29ja2V0LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlci5vbkVycm9yKHRhc2ssIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlci5vbkRhdGFEb25lKHRhc2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgcGFyc2VDb250cm9sUmVzcG9uc2VfMS5wb3NpdGl2ZUNvbXBsZXRpb24pKHJlcy5jb2RlKSkgeyAvLyBUcmFuc2ZlciBjb21wbGV0ZVxuICAgICAgICAgICAgcmVzb2x2ZXIub25Db250cm9sRG9uZSh0YXNrLCByZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBwYXJzZUNvbnRyb2xSZXNwb25zZV8xLnBvc2l0aXZlSW50ZXJtZWRpYXRlKShyZXMuY29kZSkpIHtcbiAgICAgICAgICAgIHJlc29sdmVyLm9uVW5leHBlY3RlZFJlcXVlc3QocmVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZ25vcmUgYWxsIG90aGVyIHBvc2l0aXZlIHByZWxpbWluYXJ5IHJlc3BvbnNlIGNvZGVzICg8IDIwMClcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGRvd25sb2FkVG8oZGVzdGluYXRpb24sIGNvbmZpZykge1xuICAgIGlmICghY29uZmlnLmZ0cC5kYXRhU29ja2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRvd25sb2FkIHdpbGwgYmUgaW5pdGlhdGVkIGJ1dCBubyBkYXRhIGNvbm5lY3Rpb24gaXMgYXZhaWxhYmxlLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBuZXcgVHJhbnNmZXJSZXNvbHZlcihjb25maWcuZnRwLCBjb25maWcudHJhY2tlcik7XG4gICAgcmV0dXJuIGNvbmZpZy5mdHAuaGFuZGxlKGNvbmZpZy5jb21tYW5kLCAocmVzLCB0YXNrKSA9PiB7XG4gICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmVzb2x2ZXIub25FcnJvcih0YXNrLCByZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcy5jb2RlID09PSAxNTAgfHwgcmVzLmNvZGUgPT09IDEyNSkgeyAvLyBSZWFkeSB0byBkb3dubG9hZFxuICAgICAgICAgICAgY29uc3QgZGF0YVNvY2tldCA9IGNvbmZpZy5mdHAuZGF0YVNvY2tldDtcbiAgICAgICAgICAgIGlmICghZGF0YVNvY2tldCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVyLm9uRXJyb3IodGFzaywgbmV3IEVycm9yKFwiRG93bmxvYWQgc2hvdWxkIGJlZ2luIGJ1dCBubyBkYXRhIGNvbm5lY3Rpb24gaXMgYXZhaWxhYmxlLlwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnLmZ0cC5sb2coYERvd25sb2FkaW5nIGZyb20gJHsoMCwgbmV0VXRpbHNfMS5kZXNjcmliZUFkZHJlc3MpKGRhdGFTb2NrZXQpfSAoJHsoMCwgbmV0VXRpbHNfMS5kZXNjcmliZVRMUykoZGF0YVNvY2tldCl9KWApO1xuICAgICAgICAgICAgcmVzb2x2ZXIub25EYXRhU3RhcnQoY29uZmlnLnJlbW90ZVBhdGgsIGNvbmZpZy50eXBlKTtcbiAgICAgICAgICAgICgwLCBzdHJlYW1fMS5waXBlbGluZSkoZGF0YVNvY2tldCwgZGVzdGluYXRpb24sIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlci5vbkVycm9yKHRhc2ssIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlci5vbkRhdGFEb25lKHRhc2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcy5jb2RlID09PSAzNTApIHsgLy8gUmVzdGFydGluZyBhdCBzdGFydEF0LlxuICAgICAgICAgICAgY29uZmlnLmZ0cC5zZW5kKFwiUkVUUiBcIiArIGNvbmZpZy5yZW1vdGVQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgcGFyc2VDb250cm9sUmVzcG9uc2VfMS5wb3NpdGl2ZUNvbXBsZXRpb24pKHJlcy5jb2RlKSkgeyAvLyBUcmFuc2ZlciBjb21wbGV0ZVxuICAgICAgICAgICAgcmVzb2x2ZXIub25Db250cm9sRG9uZSh0YXNrLCByZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBwYXJzZUNvbnRyb2xSZXNwb25zZV8xLnBvc2l0aXZlSW50ZXJtZWRpYXRlKShyZXMuY29kZSkpIHtcbiAgICAgICAgICAgIHJlc29sdmVyLm9uVW5leHBlY3RlZFJlcXVlc3QocmVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZ25vcmUgYWxsIG90aGVyIHBvc2l0aXZlIHByZWxpbWluYXJ5IHJlc3BvbnNlIGNvZGVzICg8IDIwMClcbiAgICB9KTtcbn1cbi8qKlxuICogQ2FsbHMgYSBmdW5jdGlvbiBpbW1lZGlhdGVseSBpZiBhIGNvbmRpdGlvbiBpcyBtZXQgb3Igc3Vic2NyaWJlcyB0byBhbiBldmVudCBhbmQgY2FsbHNcbiAqIGl0IG9uY2UgdGhlIGV2ZW50IGlzIGVtaXR0ZWQuXG4gKlxuICogQHBhcmFtIGNvbmRpdGlvbiAgVGhlIGNvbmRpdGlvbiB0byB0ZXN0LlxuICogQHBhcmFtIGVtaXR0ZXIgIFRoZSBlbWl0dGVyIHRvIHVzZSBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBAcGFyYW0gZXZlbnROYW1lICBUaGUgZXZlbnQgdG8gc3Vic2NyaWJlIHRvIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIEBwYXJhbSBhY3Rpb24gIFRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICovXG5mdW5jdGlvbiBvbkNvbmRpdGlvbk9yRXZlbnQoY29uZGl0aW9uLCBlbWl0dGVyLCBldmVudE5hbWUsIGFjdGlvbikge1xuICAgIGlmIChjb25kaXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgYWN0aW9uKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbWl0dGVyLm9uY2UoZXZlbnROYW1lLCAoKSA9PiBhY3Rpb24oKSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW50ZXJQYXNzaXZlTW9kZUlQdjYiLCJwYXJzZUVwc3ZSZXNwb25zZSIsImVudGVyUGFzc2l2ZU1vZGVJUHY0IiwiZW50ZXJQYXNzaXZlTW9kZUlQdjRfZm9yY2VDb250cm9sSG9zdElQIiwicGFyc2VQYXN2UmVzcG9uc2UiLCJjb25uZWN0Rm9yUGFzc2l2ZVRyYW5zZmVyIiwidXBsb2FkRnJvbSIsImRvd25sb2FkVG8iLCJuZXRVdGlsc18xIiwicmVxdWlyZSIsInN0cmVhbV8xIiwidGxzXzEiLCJwYXJzZUNvbnRyb2xSZXNwb25zZV8xIiwiZnRwIiwicmVzIiwicmVxdWVzdCIsInBvcnQiLCJtZXNzYWdlIiwiRXJyb3IiLCJjb250cm9sSG9zdCIsInNvY2tldCIsInJlbW90ZUFkZHJlc3MiLCJ1bmRlZmluZWQiLCJncm91cHMiLCJtYXRjaCIsInBhcnNlSW50IiwiTnVtYmVyIiwiaXNOYU4iLCJ0YXJnZXQiLCJpcElzUHJpdmF0ZVY0QWRkcmVzcyIsImhvc3QiLCJsZW5ndGgiLCJyZXBsYWNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJfbmV3U29ja2V0IiwiaGFuZGxlQ29ubkVyciIsImVyciIsImhhbmRsZVRpbWVvdXQiLCJkZXN0cm95Iiwic2V0VGltZW91dCIsInRpbWVvdXQiLCJvbiIsImNvbm5lY3QiLCJmYW1pbHkiLCJpcEZhbWlseSIsIlRMU1NvY2tldCIsImFzc2lnbiIsInRsc09wdGlvbnMiLCJzZXNzaW9uIiwiZ2V0U2Vzc2lvbiIsInJlbW92ZUxpc3RlbmVyIiwiZGF0YVNvY2tldCIsIlRyYW5zZmVyUmVzb2x2ZXIiLCJjb25zdHJ1Y3RvciIsInByb2dyZXNzIiwicmVzcG9uc2UiLCJkYXRhVHJhbnNmZXJEb25lIiwib25EYXRhU3RhcnQiLCJuYW1lIiwidHlwZSIsInN0YXJ0Iiwib25EYXRhRG9uZSIsInRhc2siLCJ1cGRhdGVBbmRTdG9wIiwidHJ5UmVzb2x2ZSIsIm9uQ29udHJvbERvbmUiLCJvbkVycm9yIiwib25VbmV4cGVjdGVkUmVxdWVzdCIsImNsb3NlV2l0aEVycm9yIiwiY2FuUmVzb2x2ZSIsInNvdXJjZSIsImNvbmZpZyIsInJlc29sdmVyIiwidHJhY2tlciIsImZ1bGxDb21tYW5kIiwiY29tbWFuZCIsInJlbW90ZVBhdGgiLCJoYW5kbGUiLCJjb2RlIiwiY2FuVXBsb2FkIiwiZ2V0Q2lwaGVyIiwib25Db25kaXRpb25PckV2ZW50IiwibG9nIiwiZGVzY3JpYmVBZGRyZXNzIiwiZGVzY3JpYmVUTFMiLCJwaXBlbGluZSIsInBvc2l0aXZlQ29tcGxldGlvbiIsInBvc2l0aXZlSW50ZXJtZWRpYXRlIiwiZGVzdGluYXRpb24iLCJzZW5kIiwiY29uZGl0aW9uIiwiZW1pdHRlciIsImV2ZW50TmFtZSIsImFjdGlvbiIsIm9uY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/basic-ftp/dist/transfer.js\n");

/***/ })

};
;