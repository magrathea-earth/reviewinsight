/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/escodegen";
exports.ids = ["vendor-chunks/escodegen"];
exports.modules = {

/***/ "(rsc)/../../node_modules/escodegen/escodegen.js":
/*!*************************************************!*\
  !*** ../../node_modules/escodegen/escodegen.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>\n  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>\n  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>\n  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>\n  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>\n  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>\n  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2020 Apple Inc. All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/ /*global exports:true, require:true, global:true*/ (function() {\n    \"use strict\";\n    var Syntax, Precedence, BinaryPrecedence, SourceNode, estraverse, esutils, base, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse, sourceMap, sourceCode, preserveBlankLines, FORMAT_MINIFY, FORMAT_DEFAULTS;\n    estraverse = __webpack_require__(/*! estraverse */ \"(rsc)/../../node_modules/estraverse/estraverse.js\");\n    esutils = __webpack_require__(/*! esutils */ \"(rsc)/../../node_modules/esutils/lib/utils.js\");\n    Syntax = estraverse.Syntax;\n    // Generation is done by generateExpression.\n    function isExpression(node) {\n        return CodeGenerator.Expression.hasOwnProperty(node.type);\n    }\n    // Generation is done by generateStatement.\n    function isStatement(node) {\n        return CodeGenerator.Statement.hasOwnProperty(node.type);\n    }\n    Precedence = {\n        Sequence: 0,\n        Yield: 1,\n        Assignment: 1,\n        Conditional: 2,\n        ArrowFunction: 2,\n        Coalesce: 3,\n        LogicalOR: 4,\n        LogicalAND: 5,\n        BitwiseOR: 6,\n        BitwiseXOR: 7,\n        BitwiseAND: 8,\n        Equality: 9,\n        Relational: 10,\n        BitwiseSHIFT: 11,\n        Additive: 12,\n        Multiplicative: 13,\n        Exponentiation: 14,\n        Await: 15,\n        Unary: 15,\n        Postfix: 16,\n        OptionalChaining: 17,\n        Call: 18,\n        New: 19,\n        TaggedTemplate: 20,\n        Member: 21,\n        Primary: 22\n    };\n    BinaryPrecedence = {\n        \"??\": Precedence.Coalesce,\n        \"||\": Precedence.LogicalOR,\n        \"&&\": Precedence.LogicalAND,\n        \"|\": Precedence.BitwiseOR,\n        \"^\": Precedence.BitwiseXOR,\n        \"&\": Precedence.BitwiseAND,\n        \"==\": Precedence.Equality,\n        \"!=\": Precedence.Equality,\n        \"===\": Precedence.Equality,\n        \"!==\": Precedence.Equality,\n        \"is\": Precedence.Equality,\n        \"isnt\": Precedence.Equality,\n        \"<\": Precedence.Relational,\n        \">\": Precedence.Relational,\n        \"<=\": Precedence.Relational,\n        \">=\": Precedence.Relational,\n        \"in\": Precedence.Relational,\n        \"instanceof\": Precedence.Relational,\n        \"<<\": Precedence.BitwiseSHIFT,\n        \">>\": Precedence.BitwiseSHIFT,\n        \">>>\": Precedence.BitwiseSHIFT,\n        \"+\": Precedence.Additive,\n        \"-\": Precedence.Additive,\n        \"*\": Precedence.Multiplicative,\n        \"%\": Precedence.Multiplicative,\n        \"/\": Precedence.Multiplicative,\n        \"**\": Precedence.Exponentiation\n    };\n    //Flags\n    var F_ALLOW_IN = 1, F_ALLOW_CALL = 1 << 1, F_ALLOW_UNPARATH_NEW = 1 << 2, F_FUNC_BODY = 1 << 3, F_DIRECTIVE_CTX = 1 << 4, F_SEMICOLON_OPT = 1 << 5, F_FOUND_COALESCE = 1 << 6;\n    //Expression flag sets\n    //NOTE: Flag order:\n    // F_ALLOW_IN\n    // F_ALLOW_CALL\n    // F_ALLOW_UNPARATH_NEW\n    var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TTF = F_ALLOW_IN | F_ALLOW_CALL, E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TFF = F_ALLOW_IN, E_FFT = F_ALLOW_UNPARATH_NEW, E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;\n    //Statement flag sets\n    //NOTE: Flag order:\n    // F_ALLOW_IN\n    // F_FUNC_BODY\n    // F_DIRECTIVE_CTX\n    // F_SEMICOLON_OPT\n    var S_TFFF = F_ALLOW_IN, S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT, S_FFFF = 0x00, S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX, S_TTFF = F_ALLOW_IN | F_FUNC_BODY;\n    function getDefaultOptions() {\n        // default options\n        return {\n            indent: null,\n            base: null,\n            parse: null,\n            comment: false,\n            format: {\n                indent: {\n                    style: \"    \",\n                    base: 0,\n                    adjustMultilineComment: false\n                },\n                newline: \"\\n\",\n                space: \" \",\n                json: false,\n                renumber: false,\n                hexadecimal: false,\n                quotes: \"single\",\n                escapeless: false,\n                compact: false,\n                parentheses: true,\n                semicolons: true,\n                safeConcatenation: false,\n                preserveBlankLines: false\n            },\n            moz: {\n                comprehensionExpressionStartsWithAssignment: false,\n                starlessGenerator: false\n            },\n            sourceMap: null,\n            sourceMapRoot: null,\n            sourceMapWithCode: false,\n            directive: false,\n            raw: true,\n            verbatim: null,\n            sourceCode: null\n        };\n    }\n    function stringRepeat(str, num) {\n        var result = \"\";\n        for(num |= 0; num > 0; num >>>= 1, str += str){\n            if (num & 1) {\n                result += str;\n            }\n        }\n        return result;\n    }\n    function hasLineTerminator(str) {\n        return /[\\r\\n]/g.test(str);\n    }\n    function endsWithLineTerminator(str) {\n        var len = str.length;\n        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));\n    }\n    function merge(target, override) {\n        var key;\n        for(key in override){\n            if (override.hasOwnProperty(key)) {\n                target[key] = override[key];\n            }\n        }\n        return target;\n    }\n    function updateDeeply(target, override) {\n        var key, val;\n        function isHashObject(target) {\n            return typeof target === \"object\" && target instanceof Object && !(target instanceof RegExp);\n        }\n        for(key in override){\n            if (override.hasOwnProperty(key)) {\n                val = override[key];\n                if (isHashObject(val)) {\n                    if (isHashObject(target[key])) {\n                        updateDeeply(target[key], val);\n                    } else {\n                        target[key] = updateDeeply({}, val);\n                    }\n                } else {\n                    target[key] = val;\n                }\n            }\n        }\n        return target;\n    }\n    function generateNumber(value) {\n        var result, point, temp, exponent, pos;\n        if (value !== value) {\n            throw new Error(\"Numeric literal whose value is NaN\");\n        }\n        if (value < 0 || value === 0 && 1 / value < 0) {\n            throw new Error(\"Numeric literal whose value is negative\");\n        }\n        if (value === 1 / 0) {\n            return json ? \"null\" : renumber ? \"1e400\" : \"1e+400\";\n        }\n        result = \"\" + value;\n        if (!renumber || result.length < 3) {\n            return result;\n        }\n        point = result.indexOf(\".\");\n        if (!json && result.charCodeAt(0) === 0x30 /* 0 */  && point === 1) {\n            point = 0;\n            result = result.slice(1);\n        }\n        temp = result;\n        result = result.replace(\"e+\", \"e\");\n        exponent = 0;\n        if ((pos = temp.indexOf(\"e\")) > 0) {\n            exponent = +temp.slice(pos + 1);\n            temp = temp.slice(0, pos);\n        }\n        if (point >= 0) {\n            exponent -= temp.length - point - 1;\n            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + \"\";\n        }\n        pos = 0;\n        while(temp.charCodeAt(temp.length + pos - 1) === 0x30 /* 0 */ ){\n            --pos;\n        }\n        if (pos !== 0) {\n            exponent -= pos;\n            temp = temp.slice(0, pos);\n        }\n        if (exponent !== 0) {\n            temp += \"e\" + exponent;\n        }\n        if ((temp.length < result.length || hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = \"0x\" + value.toString(16)).length < result.length) && +temp === value) {\n            result = temp;\n        }\n        return result;\n    }\n    // Generate valid RegExp expression.\n    // This function is based on https://github.com/Constellation/iv Engine\n    function escapeRegExpCharacter(ch, previousIsBackslash) {\n        // not handling '\\' and handling \\u2028 or \\u2029 to unicode escape sequence\n        if ((ch & ~1) === 0x2028) {\n            return (previousIsBackslash ? \"u\" : \"\\\\u\") + (ch === 0x2028 ? \"2028\" : \"2029\");\n        } else if (ch === 10 || ch === 13) {\n            return (previousIsBackslash ? \"\" : \"\\\\\") + (ch === 10 ? \"n\" : \"r\");\n        }\n        return String.fromCharCode(ch);\n    }\n    function generateRegExp(reg) {\n        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;\n        result = reg.toString();\n        if (reg.source) {\n            // extract flag from toString result\n            match = result.match(/\\/([^/]*)$/);\n            if (!match) {\n                return result;\n            }\n            flags = match[1];\n            result = \"\";\n            characterInBrack = false;\n            previousIsBackslash = false;\n            for(i = 0, iz = reg.source.length; i < iz; ++i){\n                ch = reg.source.charCodeAt(i);\n                if (!previousIsBackslash) {\n                    if (characterInBrack) {\n                        if (ch === 93) {\n                            characterInBrack = false;\n                        }\n                    } else {\n                        if (ch === 47) {\n                            result += \"\\\\\";\n                        } else if (ch === 91) {\n                            characterInBrack = true;\n                        }\n                    }\n                    result += escapeRegExpCharacter(ch, previousIsBackslash);\n                    previousIsBackslash = ch === 92; // \\\n                } else {\n                    // if new RegExp(\"\\\\\\n') is provided, create /\\n/\n                    result += escapeRegExpCharacter(ch, previousIsBackslash);\n                    // prevent like /\\\\[/]/\n                    previousIsBackslash = false;\n                }\n            }\n            return \"/\" + result + \"/\" + flags;\n        }\n        return result;\n    }\n    function escapeAllowedCharacter(code, next) {\n        var hex;\n        if (code === 0x08 /* \\b */ ) {\n            return \"\\\\b\";\n        }\n        if (code === 0x0C /* \\f */ ) {\n            return \"\\\\f\";\n        }\n        if (code === 0x09 /* \\t */ ) {\n            return \"\\\\t\";\n        }\n        hex = code.toString(16).toUpperCase();\n        if (json || code > 0xFF) {\n            return \"\\\\u\" + \"0000\".slice(hex.length) + hex;\n        } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {\n            return \"\\\\0\";\n        } else if (code === 0x000B /* \\v */ ) {\n            return \"\\\\x0B\";\n        } else {\n            return \"\\\\x\" + \"00\".slice(hex.length) + hex;\n        }\n    }\n    function escapeDisallowedCharacter(code) {\n        if (code === 0x5C /* \\ */ ) {\n            return \"\\\\\\\\\";\n        }\n        if (code === 0x0A /* \\n */ ) {\n            return \"\\\\n\";\n        }\n        if (code === 0x0D /* \\r */ ) {\n            return \"\\\\r\";\n        }\n        if (code === 0x2028) {\n            return \"\\\\u2028\";\n        }\n        if (code === 0x2029) {\n            return \"\\\\u2029\";\n        }\n        throw new Error(\"Incorrectly classified character\");\n    }\n    function escapeDirective(str) {\n        var i, iz, code, quote;\n        quote = quotes === \"double\" ? '\"' : \"'\";\n        for(i = 0, iz = str.length; i < iz; ++i){\n            code = str.charCodeAt(i);\n            if (code === 0x27 /* ' */ ) {\n                quote = '\"';\n                break;\n            } else if (code === 0x22 /* \" */ ) {\n                quote = \"'\";\n                break;\n            } else if (code === 0x5C /* \\ */ ) {\n                ++i;\n            }\n        }\n        return quote + str + quote;\n    }\n    function escapeString(str) {\n        var result = \"\", i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;\n        for(i = 0, len = str.length; i < len; ++i){\n            code = str.charCodeAt(i);\n            if (code === 0x27 /* ' */ ) {\n                ++singleQuotes;\n            } else if (code === 0x22 /* \" */ ) {\n                ++doubleQuotes;\n            } else if (code === 0x2F /* / */  && json) {\n                result += \"\\\\\";\n            } else if (esutils.code.isLineTerminator(code) || code === 0x5C /* \\ */ ) {\n                result += escapeDisallowedCharacter(code);\n                continue;\n            } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 0x20 /* SP */  || !json && !escapeless && (code < 0x20 /* SP */  || code > 0x7E /* ~ */ ))) {\n                result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));\n                continue;\n            }\n            result += String.fromCharCode(code);\n        }\n        single = !(quotes === \"double\" || quotes === \"auto\" && doubleQuotes < singleQuotes);\n        quote = single ? \"'\" : '\"';\n        if (!(single ? singleQuotes : doubleQuotes)) {\n            return quote + result + quote;\n        }\n        str = result;\n        result = quote;\n        for(i = 0, len = str.length; i < len; ++i){\n            code = str.charCodeAt(i);\n            if (code === 0x27 /* ' */  && single || code === 0x22 /* \" */  && !single) {\n                result += \"\\\\\";\n            }\n            result += String.fromCharCode(code);\n        }\n        return result + quote;\n    }\n    /**\n     * flatten an array to a string, where the array can contain\n     * either strings or nested arrays\n     */ function flattenToString(arr) {\n        var i, iz, elem, result = \"\";\n        for(i = 0, iz = arr.length; i < iz; ++i){\n            elem = arr[i];\n            result += Array.isArray(elem) ? flattenToString(elem) : elem;\n        }\n        return result;\n    }\n    /**\n     * convert generated to a SourceNode when source maps are enabled.\n     */ function toSourceNodeWhenNeeded(generated, node) {\n        if (!sourceMap) {\n            // with no source maps, generated is either an\n            // array or a string.  if an array, flatten it.\n            // if a string, just return it\n            if (Array.isArray(generated)) {\n                return flattenToString(generated);\n            } else {\n                return generated;\n            }\n        }\n        if (node == null) {\n            if (generated instanceof SourceNode) {\n                return generated;\n            } else {\n                node = {};\n            }\n        }\n        if (node.loc == null) {\n            return new SourceNode(null, null, sourceMap, generated, node.name || null);\n        }\n        return new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated, node.name || null);\n    }\n    function noEmptySpace() {\n        return space ? space : \" \";\n    }\n    function join(left, right) {\n        var leftSource, rightSource, leftCharCode, rightCharCode;\n        leftSource = toSourceNodeWhenNeeded(left).toString();\n        if (leftSource.length === 0) {\n            return [\n                right\n            ];\n        }\n        rightSource = toSourceNodeWhenNeeded(right).toString();\n        if (rightSource.length === 0) {\n            return [\n                left\n            ];\n        }\n        leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n        rightCharCode = rightSource.charCodeAt(0);\n        if ((leftCharCode === 0x2B /* + */  || leftCharCode === 0x2D /* - */ ) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) || leftCharCode === 0x2F /* / */  && rightCharCode === 0x69 /* i */ ) {\n            return [\n                left,\n                noEmptySpace(),\n                right\n            ];\n        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {\n            return [\n                left,\n                right\n            ];\n        }\n        return [\n            left,\n            space,\n            right\n        ];\n    }\n    function addIndent(stmt) {\n        return [\n            base,\n            stmt\n        ];\n    }\n    function withIndent(fn) {\n        var previousBase;\n        previousBase = base;\n        base += indent;\n        fn(base);\n        base = previousBase;\n    }\n    function calculateSpaces(str) {\n        var i;\n        for(i = str.length - 1; i >= 0; --i){\n            if (esutils.code.isLineTerminator(str.charCodeAt(i))) {\n                break;\n            }\n        }\n        return str.length - 1 - i;\n    }\n    function adjustMultilineComment(value, specialBase) {\n        var array, i, len, line, j, spaces, previousBase, sn;\n        array = value.split(/\\r\\n|[\\r\\n]/);\n        spaces = Number.MAX_VALUE;\n        // first line doesn't have indentation\n        for(i = 1, len = array.length; i < len; ++i){\n            line = array[i];\n            j = 0;\n            while(j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))){\n                ++j;\n            }\n            if (spaces > j) {\n                spaces = j;\n            }\n        }\n        if (typeof specialBase !== \"undefined\") {\n            // pattern like\n            // {\n            //   var t = 20;  /*\n            //                 * this is comment\n            //                 */\n            // }\n            previousBase = base;\n            if (array[1][spaces] === \"*\") {\n                specialBase += \" \";\n            }\n            base = specialBase;\n        } else {\n            if (spaces & 1) {\n                // /*\n                //  *\n                //  */\n                // If spaces are odd number, above pattern is considered.\n                // We waste 1 space.\n                --spaces;\n            }\n            previousBase = base;\n        }\n        for(i = 1, len = array.length; i < len; ++i){\n            sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));\n            array[i] = sourceMap ? sn.join(\"\") : sn;\n        }\n        base = previousBase;\n        return array.join(\"\\n\");\n    }\n    function generateComment(comment, specialBase) {\n        if (comment.type === \"Line\") {\n            if (endsWithLineTerminator(comment.value)) {\n                return \"//\" + comment.value;\n            } else {\n                // Always use LineTerminator\n                var result = \"//\" + comment.value;\n                if (!preserveBlankLines) {\n                    result += \"\\n\";\n                }\n                return result;\n            }\n        }\n        if (extra.format.indent.adjustMultilineComment && /[\\n\\r]/.test(comment.value)) {\n            return adjustMultilineComment(\"/*\" + comment.value + \"*/\", specialBase);\n        }\n        return \"/*\" + comment.value + \"*/\";\n    }\n    function addComments(stmt, result) {\n        var i, len, comment, save, tailingToStatement, specialBase, fragment, extRange, range, prevRange, prefix, infix, suffix, count;\n        if (stmt.leadingComments && stmt.leadingComments.length > 0) {\n            save = result;\n            if (preserveBlankLines) {\n                comment = stmt.leadingComments[0];\n                result = [];\n                extRange = comment.extendedRange;\n                range = comment.range;\n                prefix = sourceCode.substring(extRange[0], range[0]);\n                count = (prefix.match(/\\n/g) || []).length;\n                if (count > 0) {\n                    result.push(stringRepeat(\"\\n\", count));\n                    result.push(addIndent(generateComment(comment)));\n                } else {\n                    result.push(prefix);\n                    result.push(generateComment(comment));\n                }\n                prevRange = range;\n                for(i = 1, len = stmt.leadingComments.length; i < len; i++){\n                    comment = stmt.leadingComments[i];\n                    range = comment.range;\n                    infix = sourceCode.substring(prevRange[1], range[0]);\n                    count = (infix.match(/\\n/g) || []).length;\n                    result.push(stringRepeat(\"\\n\", count));\n                    result.push(addIndent(generateComment(comment)));\n                    prevRange = range;\n                }\n                suffix = sourceCode.substring(range[1], extRange[1]);\n                count = (suffix.match(/\\n/g) || []).length;\n                result.push(stringRepeat(\"\\n\", count));\n            } else {\n                comment = stmt.leadingComments[0];\n                result = [];\n                if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {\n                    result.push(\"\\n\");\n                }\n                result.push(generateComment(comment));\n                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                    result.push(\"\\n\");\n                }\n                for(i = 1, len = stmt.leadingComments.length; i < len; ++i){\n                    comment = stmt.leadingComments[i];\n                    fragment = [\n                        generateComment(comment)\n                    ];\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                        fragment.push(\"\\n\");\n                    }\n                    result.push(addIndent(fragment));\n                }\n            }\n            result.push(addIndent(save));\n        }\n        if (stmt.trailingComments) {\n            if (preserveBlankLines) {\n                comment = stmt.trailingComments[0];\n                extRange = comment.extendedRange;\n                range = comment.range;\n                prefix = sourceCode.substring(extRange[0], range[0]);\n                count = (prefix.match(/\\n/g) || []).length;\n                if (count > 0) {\n                    result.push(stringRepeat(\"\\n\", count));\n                    result.push(addIndent(generateComment(comment)));\n                } else {\n                    result.push(prefix);\n                    result.push(generateComment(comment));\n                }\n            } else {\n                tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\n                specialBase = stringRepeat(\" \", calculateSpaces(toSourceNodeWhenNeeded([\n                    base,\n                    result,\n                    indent\n                ]).toString()));\n                for(i = 0, len = stmt.trailingComments.length; i < len; ++i){\n                    comment = stmt.trailingComments[i];\n                    if (tailingToStatement) {\n                        // We assume target like following script\n                        //\n                        // var t = 20;  /**\n                        //               * This is comment of t\n                        //               */\n                        if (i === 0) {\n                            // first case\n                            result = [\n                                result,\n                                indent\n                            ];\n                        } else {\n                            result = [\n                                result,\n                                specialBase\n                            ];\n                        }\n                        result.push(generateComment(comment, specialBase));\n                    } else {\n                        result = [\n                            result,\n                            addIndent(generateComment(comment))\n                        ];\n                    }\n                    if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                        result = [\n                            result,\n                            \"\\n\"\n                        ];\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    function generateBlankLines(start, end, result) {\n        var j, newlineCount = 0;\n        for(j = start; j < end; j++){\n            if (sourceCode[j] === \"\\n\") {\n                newlineCount++;\n            }\n        }\n        for(j = 1; j < newlineCount; j++){\n            result.push(newline);\n        }\n    }\n    function parenthesize(text, current, should) {\n        if (current < should) {\n            return [\n                \"(\",\n                text,\n                \")\"\n            ];\n        }\n        return text;\n    }\n    function generateVerbatimString(string) {\n        var i, iz, result;\n        result = string.split(/\\r\\n|\\n/);\n        for(i = 1, iz = result.length; i < iz; i++){\n            result[i] = newline + base + result[i];\n        }\n        return result;\n    }\n    function generateVerbatim(expr, precedence) {\n        var verbatim, result, prec;\n        verbatim = expr[extra.verbatim];\n        if (typeof verbatim === \"string\") {\n            result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);\n        } else {\n            // verbatim is object\n            result = generateVerbatimString(verbatim.content);\n            prec = verbatim.precedence != null ? verbatim.precedence : Precedence.Sequence;\n            result = parenthesize(result, prec, precedence);\n        }\n        return toSourceNodeWhenNeeded(result, expr);\n    }\n    function CodeGenerator() {}\n    // Helpers.\n    CodeGenerator.prototype.maybeBlock = function(stmt, flags) {\n        var result, noLeadingComment, that = this;\n        noLeadingComment = !extra.comment || !stmt.leadingComments;\n        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {\n            return [\n                space,\n                this.generateStatement(stmt, flags)\n            ];\n        }\n        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {\n            return \";\";\n        }\n        withIndent(function() {\n            result = [\n                newline,\n                addIndent(that.generateStatement(stmt, flags))\n            ];\n        });\n        return result;\n    };\n    CodeGenerator.prototype.maybeBlockSuffix = function(stmt, result) {\n        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\n        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {\n            return [\n                result,\n                space\n            ];\n        }\n        if (ends) {\n            return [\n                result,\n                base\n            ];\n        }\n        return [\n            result,\n            newline,\n            base\n        ];\n    };\n    function generateIdentifier(node) {\n        return toSourceNodeWhenNeeded(node.name, node);\n    }\n    function generateAsyncPrefix(node, spaceRequired) {\n        return node.async ? \"async\" + (spaceRequired ? noEmptySpace() : space) : \"\";\n    }\n    function generateStarSuffix(node) {\n        var isGenerator = node.generator && !extra.moz.starlessGenerator;\n        return isGenerator ? \"*\" + space : \"\";\n    }\n    function generateMethodPrefix(prop) {\n        var func = prop.value, prefix = \"\";\n        if (func.async) {\n            prefix += generateAsyncPrefix(func, !prop.computed);\n        }\n        if (func.generator) {\n            // avoid space before method name\n            prefix += generateStarSuffix(func) ? \"*\" : \"\";\n        }\n        return prefix;\n    }\n    CodeGenerator.prototype.generatePattern = function(node, precedence, flags) {\n        if (node.type === Syntax.Identifier) {\n            return generateIdentifier(node);\n        }\n        return this.generateExpression(node, precedence, flags);\n    };\n    CodeGenerator.prototype.generateFunctionParams = function(node) {\n        var i, iz, result, hasDefault;\n        hasDefault = false;\n        if (node.type === Syntax.ArrowFunctionExpression && !node.rest && (!node.defaults || node.defaults.length === 0) && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {\n            // arg => { } case\n            result = [\n                generateAsyncPrefix(node, true),\n                generateIdentifier(node.params[0])\n            ];\n        } else {\n            result = node.type === Syntax.ArrowFunctionExpression ? [\n                generateAsyncPrefix(node, false)\n            ] : [];\n            result.push(\"(\");\n            if (node.defaults) {\n                hasDefault = true;\n            }\n            for(i = 0, iz = node.params.length; i < iz; ++i){\n                if (hasDefault && node.defaults[i]) {\n                    // Handle default values.\n                    result.push(this.generateAssignment(node.params[i], node.defaults[i], \"=\", Precedence.Assignment, E_TTT));\n                } else {\n                    result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));\n                }\n                if (i + 1 < iz) {\n                    result.push(\",\" + space);\n                }\n            }\n            if (node.rest) {\n                if (node.params.length) {\n                    result.push(\",\" + space);\n                }\n                result.push(\"...\");\n                result.push(generateIdentifier(node.rest));\n            }\n            result.push(\")\");\n        }\n        return result;\n    };\n    CodeGenerator.prototype.generateFunctionBody = function(node) {\n        var result, expr;\n        result = this.generateFunctionParams(node);\n        if (node.type === Syntax.ArrowFunctionExpression) {\n            result.push(space);\n            result.push(\"=>\");\n        }\n        if (node.expression) {\n            result.push(space);\n            expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);\n            if (expr.toString().charAt(0) === \"{\") {\n                expr = [\n                    \"(\",\n                    expr,\n                    \")\"\n                ];\n            }\n            result.push(expr);\n        } else {\n            result.push(this.maybeBlock(node.body, S_TTFF));\n        }\n        return result;\n    };\n    CodeGenerator.prototype.generateIterationForStatement = function(operator, stmt, flags) {\n        var result = [\n            \"for\" + (stmt.await ? noEmptySpace() + \"await\" : \"\") + space + \"(\"\n        ], that = this;\n        withIndent(function() {\n            if (stmt.left.type === Syntax.VariableDeclaration) {\n                withIndent(function() {\n                    result.push(stmt.left.kind + noEmptySpace());\n                    result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));\n                });\n            } else {\n                result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));\n            }\n            result = join(result, operator);\n            result = [\n                join(result, that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)),\n                \")\"\n            ];\n        });\n        result.push(this.maybeBlock(stmt.body, flags));\n        return result;\n    };\n    CodeGenerator.prototype.generatePropertyKey = function(expr, computed) {\n        var result = [];\n        if (computed) {\n            result.push(\"[\");\n        }\n        result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT));\n        if (computed) {\n            result.push(\"]\");\n        }\n        return result;\n    };\n    CodeGenerator.prototype.generateAssignment = function(left, right, operator, precedence, flags) {\n        if (Precedence.Assignment < precedence) {\n            flags |= F_ALLOW_IN;\n        }\n        return parenthesize([\n            this.generateExpression(left, Precedence.Call, flags),\n            space + operator + space,\n            this.generateExpression(right, Precedence.Assignment, flags)\n        ], Precedence.Assignment, precedence);\n    };\n    CodeGenerator.prototype.semicolon = function(flags) {\n        if (!semicolons && flags & F_SEMICOLON_OPT) {\n            return \"\";\n        }\n        return \";\";\n    };\n    // Statements.\n    CodeGenerator.Statement = {\n        BlockStatement: function(stmt, flags) {\n            var range, content, result = [\n                \"{\",\n                newline\n            ], that = this;\n            withIndent(function() {\n                // handle functions without any code\n                if (stmt.body.length === 0 && preserveBlankLines) {\n                    range = stmt.range;\n                    if (range[1] - range[0] > 2) {\n                        content = sourceCode.substring(range[0] + 1, range[1] - 1);\n                        if (content[0] === \"\\n\") {\n                            result = [\n                                \"{\"\n                            ];\n                        }\n                        result.push(content);\n                    }\n                }\n                var i, iz, fragment, bodyFlags;\n                bodyFlags = S_TFFF;\n                if (flags & F_FUNC_BODY) {\n                    bodyFlags |= F_DIRECTIVE_CTX;\n                }\n                for(i = 0, iz = stmt.body.length; i < iz; ++i){\n                    if (preserveBlankLines) {\n                        // handle spaces before the first line\n                        if (i === 0) {\n                            if (stmt.body[0].leadingComments) {\n                                range = stmt.body[0].leadingComments[0].extendedRange;\n                                content = sourceCode.substring(range[0], range[1]);\n                                if (content[0] === \"\\n\") {\n                                    result = [\n                                        \"{\"\n                                    ];\n                                }\n                            }\n                            if (!stmt.body[0].leadingComments) {\n                                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);\n                            }\n                        }\n                        // handle spaces between lines\n                        if (i > 0) {\n                            if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {\n                                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);\n                            }\n                        }\n                    }\n                    if (i === iz - 1) {\n                        bodyFlags |= F_SEMICOLON_OPT;\n                    }\n                    if (stmt.body[i].leadingComments && preserveBlankLines) {\n                        fragment = that.generateStatement(stmt.body[i], bodyFlags);\n                    } else {\n                        fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));\n                    }\n                    result.push(fragment);\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                        if (preserveBlankLines && i < iz - 1) {\n                            // don't add a new line if there are leading coments\n                            // in the next statement\n                            if (!stmt.body[i + 1].leadingComments) {\n                                result.push(newline);\n                            }\n                        } else {\n                            result.push(newline);\n                        }\n                    }\n                    if (preserveBlankLines) {\n                        // handle spaces after the last line\n                        if (i === iz - 1) {\n                            if (!stmt.body[i].trailingComments) {\n                                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\n                            }\n                        }\n                    }\n                }\n            });\n            result.push(addIndent(\"}\"));\n            return result;\n        },\n        BreakStatement: function(stmt, flags) {\n            if (stmt.label) {\n                return \"break \" + stmt.label.name + this.semicolon(flags);\n            }\n            return \"break\" + this.semicolon(flags);\n        },\n        ContinueStatement: function(stmt, flags) {\n            if (stmt.label) {\n                return \"continue \" + stmt.label.name + this.semicolon(flags);\n            }\n            return \"continue\" + this.semicolon(flags);\n        },\n        ClassBody: function(stmt, flags) {\n            var result = [\n                \"{\",\n                newline\n            ], that = this;\n            withIndent(function(indent) {\n                var i, iz;\n                for(i = 0, iz = stmt.body.length; i < iz; ++i){\n                    result.push(indent);\n                    result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));\n                    if (i + 1 < iz) {\n                        result.push(newline);\n                    }\n                }\n            });\n            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n            }\n            result.push(base);\n            result.push(\"}\");\n            return result;\n        },\n        ClassDeclaration: function(stmt, flags) {\n            var result, fragment;\n            result = [\n                \"class\"\n            ];\n            if (stmt.id) {\n                result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));\n            }\n            if (stmt.superClass) {\n                fragment = join(\"extends\", this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));\n                result = join(result, fragment);\n            }\n            result.push(space);\n            result.push(this.generateStatement(stmt.body, S_TFFT));\n            return result;\n        },\n        DirectiveStatement: function(stmt, flags) {\n            if (extra.raw && stmt.raw) {\n                return stmt.raw + this.semicolon(flags);\n            }\n            return escapeDirective(stmt.directive) + this.semicolon(flags);\n        },\n        DoWhileStatement: function(stmt, flags) {\n            // Because `do 42 while (cond)` is Syntax Error. We need semicolon.\n            var result = join(\"do\", this.maybeBlock(stmt.body, S_TFFF));\n            result = this.maybeBlockSuffix(stmt.body, result);\n            return join(result, [\n                \"while\" + space + \"(\",\n                this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n                \")\" + this.semicolon(flags)\n            ]);\n        },\n        CatchClause: function(stmt, flags) {\n            var result, that = this;\n            withIndent(function() {\n                var guard;\n                if (stmt.param) {\n                    result = [\n                        \"catch\" + space + \"(\",\n                        that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),\n                        \")\"\n                    ];\n                    if (stmt.guard) {\n                        guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);\n                        result.splice(2, 0, \" if \", guard);\n                    }\n                } else {\n                    result = [\n                        \"catch\"\n                    ];\n                }\n            });\n            result.push(this.maybeBlock(stmt.body, S_TFFF));\n            return result;\n        },\n        DebuggerStatement: function(stmt, flags) {\n            return \"debugger\" + this.semicolon(flags);\n        },\n        EmptyStatement: function(stmt, flags) {\n            return \";\";\n        },\n        ExportDefaultDeclaration: function(stmt, flags) {\n            var result = [\n                \"export\"\n            ], bodyFlags;\n            bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;\n            // export default HoistableDeclaration[Default]\n            // export default AssignmentExpression[In] ;\n            result = join(result, \"default\");\n            if (isStatement(stmt.declaration)) {\n                result = join(result, this.generateStatement(stmt.declaration, bodyFlags));\n            } else {\n                result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));\n            }\n            return result;\n        },\n        ExportNamedDeclaration: function(stmt, flags) {\n            var result = [\n                \"export\"\n            ], bodyFlags, that = this;\n            bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;\n            // export VariableStatement\n            // export Declaration[Default]\n            if (stmt.declaration) {\n                return join(result, this.generateStatement(stmt.declaration, bodyFlags));\n            }\n            // export ExportClause[NoReference] FromClause ;\n            // export ExportClause ;\n            if (stmt.specifiers) {\n                if (stmt.specifiers.length === 0) {\n                    result = join(result, \"{\" + space + \"}\");\n                } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {\n                    result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));\n                } else {\n                    result = join(result, \"{\");\n                    withIndent(function(indent) {\n                        var i, iz;\n                        result.push(newline);\n                        for(i = 0, iz = stmt.specifiers.length; i < iz; ++i){\n                            result.push(indent);\n                            result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\n                            if (i + 1 < iz) {\n                                result.push(\",\" + newline);\n                            }\n                        }\n                    });\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                        result.push(newline);\n                    }\n                    result.push(base + \"}\");\n                }\n                if (stmt.source) {\n                    result = join(result, [\n                        \"from\" + space,\n                        // ModuleSpecifier\n                        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n                        this.semicolon(flags)\n                    ]);\n                } else {\n                    result.push(this.semicolon(flags));\n                }\n            }\n            return result;\n        },\n        ExportAllDeclaration: function(stmt, flags) {\n            // export * FromClause ;\n            return [\n                \"export\" + space,\n                \"*\" + space,\n                \"from\" + space,\n                // ModuleSpecifier\n                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n                this.semicolon(flags)\n            ];\n        },\n        ExpressionStatement: function(stmt, flags) {\n            var result, fragment;\n            function isClassPrefixed(fragment) {\n                var code;\n                if (fragment.slice(0, 5) !== \"class\") {\n                    return false;\n                }\n                code = fragment.charCodeAt(5);\n                return code === 0x7B /* '{' */  || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);\n            }\n            function isFunctionPrefixed(fragment) {\n                var code;\n                if (fragment.slice(0, 8) !== \"function\") {\n                    return false;\n                }\n                code = fragment.charCodeAt(8);\n                return code === 0x28 /* '(' */  || esutils.code.isWhiteSpace(code) || code === 0x2A /* '*' */  || esutils.code.isLineTerminator(code);\n            }\n            function isAsyncPrefixed(fragment) {\n                var code, i, iz;\n                if (fragment.slice(0, 5) !== \"async\") {\n                    return false;\n                }\n                if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {\n                    return false;\n                }\n                for(i = 6, iz = fragment.length; i < iz; ++i){\n                    if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {\n                        break;\n                    }\n                }\n                if (i === iz) {\n                    return false;\n                }\n                if (fragment.slice(i, i + 8) !== \"function\") {\n                    return false;\n                }\n                code = fragment.charCodeAt(i + 8);\n                return code === 0x28 /* '(' */  || esutils.code.isWhiteSpace(code) || code === 0x2A /* '*' */  || esutils.code.isLineTerminator(code);\n            }\n            result = [\n                this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)\n            ];\n            // 12.4 '{', 'function', 'class' is not allowed in this position.\n            // wrap expression with parentheses\n            fragment = toSourceNodeWhenNeeded(result).toString();\n            if (fragment.charCodeAt(0) === 0x7B /* '{' */  || // ObjectExpression\n            isClassPrefixed(fragment) || isFunctionPrefixed(fragment) || isAsyncPrefixed(fragment) || directive && flags & F_DIRECTIVE_CTX && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === \"string\") {\n                result = [\n                    \"(\",\n                    result,\n                    \")\" + this.semicolon(flags)\n                ];\n            } else {\n                result.push(this.semicolon(flags));\n            }\n            return result;\n        },\n        ImportDeclaration: function(stmt, flags) {\n            // ES6: 15.2.1 valid import declarations:\n            //     - import ImportClause FromClause ;\n            //     - import ModuleSpecifier ;\n            var result, cursor, that = this;\n            // If no ImportClause is present,\n            // this should be `import ModuleSpecifier` so skip `from`\n            // ModuleSpecifier is StringLiteral.\n            if (stmt.specifiers.length === 0) {\n                // import ModuleSpecifier ;\n                return [\n                    \"import\",\n                    space,\n                    // ModuleSpecifier\n                    this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n                    this.semicolon(flags)\n                ];\n            }\n            // import ImportClause FromClause ;\n            result = [\n                \"import\"\n            ];\n            cursor = 0;\n            // ImportedBinding\n            if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {\n                result = join(result, [\n                    this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)\n                ]);\n                ++cursor;\n            }\n            if (stmt.specifiers[cursor]) {\n                if (cursor !== 0) {\n                    result.push(\",\");\n                }\n                if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {\n                    // NameSpaceImport\n                    result = join(result, [\n                        space,\n                        this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)\n                    ]);\n                } else {\n                    // NamedImports\n                    result.push(space + \"{\");\n                    if (stmt.specifiers.length - cursor === 1) {\n                        // import { ... } from \"...\";\n                        result.push(space);\n                        result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));\n                        result.push(space + \"}\" + space);\n                    } else {\n                        // import {\n                        //    ...,\n                        //    ...,\n                        // } from \"...\";\n                        withIndent(function(indent) {\n                            var i, iz;\n                            result.push(newline);\n                            for(i = cursor, iz = stmt.specifiers.length; i < iz; ++i){\n                                result.push(indent);\n                                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\n                                if (i + 1 < iz) {\n                                    result.push(\",\" + newline);\n                                }\n                            }\n                        });\n                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                            result.push(newline);\n                        }\n                        result.push(base + \"}\" + space);\n                    }\n                }\n            }\n            result = join(result, [\n                \"from\" + space,\n                // ModuleSpecifier\n                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n                this.semicolon(flags)\n            ]);\n            return result;\n        },\n        VariableDeclarator: function(stmt, flags) {\n            var itemFlags = flags & F_ALLOW_IN ? E_TTT : E_FTT;\n            if (stmt.init) {\n                return [\n                    this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),\n                    space,\n                    \"=\",\n                    space,\n                    this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)\n                ];\n            }\n            return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);\n        },\n        VariableDeclaration: function(stmt, flags) {\n            // VariableDeclarator is typed as Statement,\n            // but joined with comma (not LineTerminator).\n            // So if comment is attached to target node, we should specialize.\n            var result, i, iz, node, bodyFlags, that = this;\n            result = [\n                stmt.kind\n            ];\n            bodyFlags = flags & F_ALLOW_IN ? S_TFFF : S_FFFF;\n            function block() {\n                node = stmt.declarations[0];\n                if (extra.comment && node.leadingComments) {\n                    result.push(\"\\n\");\n                    result.push(addIndent(that.generateStatement(node, bodyFlags)));\n                } else {\n                    result.push(noEmptySpace());\n                    result.push(that.generateStatement(node, bodyFlags));\n                }\n                for(i = 1, iz = stmt.declarations.length; i < iz; ++i){\n                    node = stmt.declarations[i];\n                    if (extra.comment && node.leadingComments) {\n                        result.push(\",\" + newline);\n                        result.push(addIndent(that.generateStatement(node, bodyFlags)));\n                    } else {\n                        result.push(\",\" + space);\n                        result.push(that.generateStatement(node, bodyFlags));\n                    }\n                }\n            }\n            if (stmt.declarations.length > 1) {\n                withIndent(block);\n            } else {\n                block();\n            }\n            result.push(this.semicolon(flags));\n            return result;\n        },\n        ThrowStatement: function(stmt, flags) {\n            return [\n                join(\"throw\", this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)),\n                this.semicolon(flags)\n            ];\n        },\n        TryStatement: function(stmt, flags) {\n            var result, i, iz, guardedHandlers;\n            result = [\n                \"try\",\n                this.maybeBlock(stmt.block, S_TFFF)\n            ];\n            result = this.maybeBlockSuffix(stmt.block, result);\n            if (stmt.handlers) {\n                // old interface\n                for(i = 0, iz = stmt.handlers.length; i < iz; ++i){\n                    result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));\n                    if (stmt.finalizer || i + 1 !== iz) {\n                        result = this.maybeBlockSuffix(stmt.handlers[i].body, result);\n                    }\n                }\n            } else {\n                guardedHandlers = stmt.guardedHandlers || [];\n                for(i = 0, iz = guardedHandlers.length; i < iz; ++i){\n                    result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));\n                    if (stmt.finalizer || i + 1 !== iz) {\n                        result = this.maybeBlockSuffix(guardedHandlers[i].body, result);\n                    }\n                }\n                // new interface\n                if (stmt.handler) {\n                    if (Array.isArray(stmt.handler)) {\n                        for(i = 0, iz = stmt.handler.length; i < iz; ++i){\n                            result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));\n                            if (stmt.finalizer || i + 1 !== iz) {\n                                result = this.maybeBlockSuffix(stmt.handler[i].body, result);\n                            }\n                        }\n                    } else {\n                        result = join(result, this.generateStatement(stmt.handler, S_TFFF));\n                        if (stmt.finalizer) {\n                            result = this.maybeBlockSuffix(stmt.handler.body, result);\n                        }\n                    }\n                }\n            }\n            if (stmt.finalizer) {\n                result = join(result, [\n                    \"finally\",\n                    this.maybeBlock(stmt.finalizer, S_TFFF)\n                ]);\n            }\n            return result;\n        },\n        SwitchStatement: function(stmt, flags) {\n            var result, fragment, i, iz, bodyFlags, that = this;\n            withIndent(function() {\n                result = [\n                    \"switch\" + space + \"(\",\n                    that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),\n                    \")\" + space + \"{\" + newline\n                ];\n            });\n            if (stmt.cases) {\n                bodyFlags = S_TFFF;\n                for(i = 0, iz = stmt.cases.length; i < iz; ++i){\n                    if (i === iz - 1) {\n                        bodyFlags |= F_SEMICOLON_OPT;\n                    }\n                    fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));\n                    result.push(fragment);\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                        result.push(newline);\n                    }\n                }\n            }\n            result.push(addIndent(\"}\"));\n            return result;\n        },\n        SwitchCase: function(stmt, flags) {\n            var result, fragment, i, iz, bodyFlags, that = this;\n            withIndent(function() {\n                if (stmt.test) {\n                    result = [\n                        join(\"case\", that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),\n                        \":\"\n                    ];\n                } else {\n                    result = [\n                        \"default:\"\n                    ];\n                }\n                i = 0;\n                iz = stmt.consequent.length;\n                if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {\n                    fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);\n                    result.push(fragment);\n                    i = 1;\n                }\n                if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                    result.push(newline);\n                }\n                bodyFlags = S_TFFF;\n                for(; i < iz; ++i){\n                    if (i === iz - 1 && flags & F_SEMICOLON_OPT) {\n                        bodyFlags |= F_SEMICOLON_OPT;\n                    }\n                    fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));\n                    result.push(fragment);\n                    if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                        result.push(newline);\n                    }\n                }\n            });\n            return result;\n        },\n        IfStatement: function(stmt, flags) {\n            var result, bodyFlags, semicolonOptional, that = this;\n            withIndent(function() {\n                result = [\n                    \"if\" + space + \"(\",\n                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n                    \")\"\n                ];\n            });\n            semicolonOptional = flags & F_SEMICOLON_OPT;\n            bodyFlags = S_TFFF;\n            if (semicolonOptional) {\n                bodyFlags |= F_SEMICOLON_OPT;\n            }\n            if (stmt.alternate) {\n                result.push(this.maybeBlock(stmt.consequent, S_TFFF));\n                result = this.maybeBlockSuffix(stmt.consequent, result);\n                if (stmt.alternate.type === Syntax.IfStatement) {\n                    result = join(result, [\n                        \"else \",\n                        this.generateStatement(stmt.alternate, bodyFlags)\n                    ]);\n                } else {\n                    result = join(result, join(\"else\", this.maybeBlock(stmt.alternate, bodyFlags)));\n                }\n            } else {\n                result.push(this.maybeBlock(stmt.consequent, bodyFlags));\n            }\n            return result;\n        },\n        ForStatement: function(stmt, flags) {\n            var result, that = this;\n            withIndent(function() {\n                result = [\n                    \"for\" + space + \"(\"\n                ];\n                if (stmt.init) {\n                    if (stmt.init.type === Syntax.VariableDeclaration) {\n                        result.push(that.generateStatement(stmt.init, S_FFFF));\n                    } else {\n                        // F_ALLOW_IN becomes false.\n                        result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));\n                        result.push(\";\");\n                    }\n                } else {\n                    result.push(\";\");\n                }\n                if (stmt.test) {\n                    result.push(space);\n                    result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));\n                    result.push(\";\");\n                } else {\n                    result.push(\";\");\n                }\n                if (stmt.update) {\n                    result.push(space);\n                    result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));\n                    result.push(\")\");\n                } else {\n                    result.push(\")\");\n                }\n            });\n            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n            return result;\n        },\n        ForInStatement: function(stmt, flags) {\n            return this.generateIterationForStatement(\"in\", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\n        },\n        ForOfStatement: function(stmt, flags) {\n            return this.generateIterationForStatement(\"of\", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\n        },\n        LabeledStatement: function(stmt, flags) {\n            return [\n                stmt.label.name + \":\",\n                this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)\n            ];\n        },\n        Program: function(stmt, flags) {\n            var result, fragment, i, iz, bodyFlags;\n            iz = stmt.body.length;\n            result = [\n                safeConcatenation && iz > 0 ? \"\\n\" : \"\"\n            ];\n            bodyFlags = S_TFTF;\n            for(i = 0; i < iz; ++i){\n                if (!safeConcatenation && i === iz - 1) {\n                    bodyFlags |= F_SEMICOLON_OPT;\n                }\n                if (preserveBlankLines) {\n                    // handle spaces before the first line\n                    if (i === 0) {\n                        if (!stmt.body[0].leadingComments) {\n                            generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);\n                        }\n                    }\n                    // handle spaces between lines\n                    if (i > 0) {\n                        if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {\n                            generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);\n                        }\n                    }\n                }\n                fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));\n                result.push(fragment);\n                if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                    if (preserveBlankLines) {\n                        if (!stmt.body[i + 1].leadingComments) {\n                            result.push(newline);\n                        }\n                    } else {\n                        result.push(newline);\n                    }\n                }\n                if (preserveBlankLines) {\n                    // handle spaces after the last line\n                    if (i === iz - 1) {\n                        if (!stmt.body[i].trailingComments) {\n                            generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\n                        }\n                    }\n                }\n            }\n            return result;\n        },\n        FunctionDeclaration: function(stmt, flags) {\n            return [\n                generateAsyncPrefix(stmt, true),\n                \"function\",\n                generateStarSuffix(stmt) || noEmptySpace(),\n                stmt.id ? generateIdentifier(stmt.id) : \"\",\n                this.generateFunctionBody(stmt)\n            ];\n        },\n        ReturnStatement: function(stmt, flags) {\n            if (stmt.argument) {\n                return [\n                    join(\"return\", this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)),\n                    this.semicolon(flags)\n                ];\n            }\n            return [\n                \"return\" + this.semicolon(flags)\n            ];\n        },\n        WhileStatement: function(stmt, flags) {\n            var result, that = this;\n            withIndent(function() {\n                result = [\n                    \"while\" + space + \"(\",\n                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n                    \")\"\n                ];\n            });\n            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n            return result;\n        },\n        WithStatement: function(stmt, flags) {\n            var result, that = this;\n            withIndent(function() {\n                result = [\n                    \"with\" + space + \"(\",\n                    that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),\n                    \")\"\n                ];\n            });\n            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n            return result;\n        }\n    };\n    merge(CodeGenerator.prototype, CodeGenerator.Statement);\n    // Expressions.\n    CodeGenerator.Expression = {\n        SequenceExpression: function(expr, precedence, flags) {\n            var result, i, iz;\n            if (Precedence.Sequence < precedence) {\n                flags |= F_ALLOW_IN;\n            }\n            result = [];\n            for(i = 0, iz = expr.expressions.length; i < iz; ++i){\n                result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));\n                if (i + 1 < iz) {\n                    result.push(\",\" + space);\n                }\n            }\n            return parenthesize(result, Precedence.Sequence, precedence);\n        },\n        AssignmentExpression: function(expr, precedence, flags) {\n            return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);\n        },\n        ArrowFunctionExpression: function(expr, precedence, flags) {\n            return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);\n        },\n        ConditionalExpression: function(expr, precedence, flags) {\n            if (Precedence.Conditional < precedence) {\n                flags |= F_ALLOW_IN;\n            }\n            return parenthesize([\n                this.generateExpression(expr.test, Precedence.Coalesce, flags),\n                space + \"?\" + space,\n                this.generateExpression(expr.consequent, Precedence.Assignment, flags),\n                space + \":\" + space,\n                this.generateExpression(expr.alternate, Precedence.Assignment, flags)\n            ], Precedence.Conditional, precedence);\n        },\n        LogicalExpression: function(expr, precedence, flags) {\n            if (expr.operator === \"??\") {\n                flags |= F_FOUND_COALESCE;\n            }\n            return this.BinaryExpression(expr, precedence, flags);\n        },\n        BinaryExpression: function(expr, precedence, flags) {\n            var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;\n            currentPrecedence = BinaryPrecedence[expr.operator];\n            leftPrecedence = expr.operator === \"**\" ? Precedence.Postfix : currentPrecedence;\n            rightPrecedence = expr.operator === \"**\" ? currentPrecedence : currentPrecedence + 1;\n            if (currentPrecedence < precedence) {\n                flags |= F_ALLOW_IN;\n            }\n            fragment = this.generateExpression(expr.left, leftPrecedence, flags);\n            leftSource = fragment.toString();\n            if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F /* / */  && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {\n                result = [\n                    fragment,\n                    noEmptySpace(),\n                    expr.operator\n                ];\n            } else {\n                result = join(fragment, expr.operator);\n            }\n            fragment = this.generateExpression(expr.right, rightPrecedence, flags);\n            if (expr.operator === \"/\" && fragment.toString().charAt(0) === \"/\" || expr.operator.slice(-1) === \"<\" && fragment.toString().slice(0, 3) === \"!--\") {\n                // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start\n                result.push(noEmptySpace());\n                result.push(fragment);\n            } else {\n                result = join(result, fragment);\n            }\n            if (expr.operator === \"in\" && !(flags & F_ALLOW_IN)) {\n                return [\n                    \"(\",\n                    result,\n                    \")\"\n                ];\n            }\n            if ((expr.operator === \"||\" || expr.operator === \"&&\") && flags & F_FOUND_COALESCE) {\n                return [\n                    \"(\",\n                    result,\n                    \")\"\n                ];\n            }\n            return parenthesize(result, currentPrecedence, precedence);\n        },\n        CallExpression: function(expr, precedence, flags) {\n            var result, i, iz;\n            // F_ALLOW_UNPARATH_NEW becomes false.\n            result = [\n                this.generateExpression(expr.callee, Precedence.Call, E_TTF)\n            ];\n            if (expr.optional) {\n                result.push(\"?.\");\n            }\n            result.push(\"(\");\n            for(i = 0, iz = expr[\"arguments\"].length; i < iz; ++i){\n                result.push(this.generateExpression(expr[\"arguments\"][i], Precedence.Assignment, E_TTT));\n                if (i + 1 < iz) {\n                    result.push(\",\" + space);\n                }\n            }\n            result.push(\")\");\n            if (!(flags & F_ALLOW_CALL)) {\n                return [\n                    \"(\",\n                    result,\n                    \")\"\n                ];\n            }\n            return parenthesize(result, Precedence.Call, precedence);\n        },\n        ChainExpression: function(expr, precedence, flags) {\n            if (Precedence.OptionalChaining < precedence) {\n                flags |= F_ALLOW_CALL;\n            }\n            var result = this.generateExpression(expr.expression, Precedence.OptionalChaining, flags);\n            return parenthesize(result, Precedence.OptionalChaining, precedence);\n        },\n        NewExpression: function(expr, precedence, flags) {\n            var result, length, i, iz, itemFlags;\n            length = expr[\"arguments\"].length;\n            // F_ALLOW_CALL becomes false.\n            // F_ALLOW_UNPARATH_NEW may become false.\n            itemFlags = flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0 ? E_TFT : E_TFF;\n            result = join(\"new\", this.generateExpression(expr.callee, Precedence.New, itemFlags));\n            if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {\n                result.push(\"(\");\n                for(i = 0, iz = length; i < iz; ++i){\n                    result.push(this.generateExpression(expr[\"arguments\"][i], Precedence.Assignment, E_TTT));\n                    if (i + 1 < iz) {\n                        result.push(\",\" + space);\n                    }\n                }\n                result.push(\")\");\n            }\n            return parenthesize(result, Precedence.New, precedence);\n        },\n        MemberExpression: function(expr, precedence, flags) {\n            var result, fragment;\n            // F_ALLOW_UNPARATH_NEW becomes false.\n            result = [\n                this.generateExpression(expr.object, Precedence.Call, flags & F_ALLOW_CALL ? E_TTF : E_TFF)\n            ];\n            if (expr.computed) {\n                if (expr.optional) {\n                    result.push(\"?.\");\n                }\n                result.push(\"[\");\n                result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));\n                result.push(\"]\");\n            } else {\n                if (!expr.optional && expr.object.type === Syntax.Literal && typeof expr.object.value === \"number\") {\n                    fragment = toSourceNodeWhenNeeded(result).toString();\n                    // When the following conditions are all true,\n                    //   1. No floating point\n                    //   2. Don't have exponents\n                    //   3. The last character is a decimal digit\n                    //   4. Not hexadecimal OR octal number literal\n                    // we should add a floating point.\n                    if (fragment.indexOf(\".\") < 0 && !/[eExX]/.test(fragment) && esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48 // '0'\n                    )) {\n                        result.push(\" \");\n                    }\n                }\n                result.push(expr.optional ? \"?.\" : \".\");\n                result.push(generateIdentifier(expr.property));\n            }\n            return parenthesize(result, Precedence.Member, precedence);\n        },\n        MetaProperty: function(expr, precedence, flags) {\n            var result;\n            result = [];\n            result.push(typeof expr.meta === \"string\" ? expr.meta : generateIdentifier(expr.meta));\n            result.push(\".\");\n            result.push(typeof expr.property === \"string\" ? expr.property : generateIdentifier(expr.property));\n            return parenthesize(result, Precedence.Member, precedence);\n        },\n        UnaryExpression: function(expr, precedence, flags) {\n            var result, fragment, rightCharCode, leftSource, leftCharCode;\n            fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);\n            if (space === \"\") {\n                result = join(expr.operator, fragment);\n            } else {\n                result = [\n                    expr.operator\n                ];\n                if (expr.operator.length > 2) {\n                    // delete, void, typeof\n                    // get `typeof []`, not `typeof[]`\n                    result = join(result, fragment);\n                } else {\n                    // Prevent inserting spaces between operator and argument if it is unnecessary\n                    // like, `!cond`\n                    leftSource = toSourceNodeWhenNeeded(result).toString();\n                    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n                    rightCharCode = fragment.toString().charCodeAt(0);\n                    if ((leftCharCode === 0x2B /* + */  || leftCharCode === 0x2D /* - */ ) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode)) {\n                        result.push(noEmptySpace());\n                        result.push(fragment);\n                    } else {\n                        result.push(fragment);\n                    }\n                }\n            }\n            return parenthesize(result, Precedence.Unary, precedence);\n        },\n        YieldExpression: function(expr, precedence, flags) {\n            var result;\n            if (expr.delegate) {\n                result = \"yield*\";\n            } else {\n                result = \"yield\";\n            }\n            if (expr.argument) {\n                result = join(result, this.generateExpression(expr.argument, Precedence.Yield, E_TTT));\n            }\n            return parenthesize(result, Precedence.Yield, precedence);\n        },\n        AwaitExpression: function(expr, precedence, flags) {\n            var result = join(expr.all ? \"await*\" : \"await\", this.generateExpression(expr.argument, Precedence.Await, E_TTT));\n            return parenthesize(result, Precedence.Await, precedence);\n        },\n        UpdateExpression: function(expr, precedence, flags) {\n            if (expr.prefix) {\n                return parenthesize([\n                    expr.operator,\n                    this.generateExpression(expr.argument, Precedence.Unary, E_TTT)\n                ], Precedence.Unary, precedence);\n            }\n            return parenthesize([\n                this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),\n                expr.operator\n            ], Precedence.Postfix, precedence);\n        },\n        FunctionExpression: function(expr, precedence, flags) {\n            var result = [\n                generateAsyncPrefix(expr, true),\n                \"function\"\n            ];\n            if (expr.id) {\n                result.push(generateStarSuffix(expr) || noEmptySpace());\n                result.push(generateIdentifier(expr.id));\n            } else {\n                result.push(generateStarSuffix(expr) || space);\n            }\n            result.push(this.generateFunctionBody(expr));\n            return result;\n        },\n        ArrayPattern: function(expr, precedence, flags) {\n            return this.ArrayExpression(expr, precedence, flags, true);\n        },\n        ArrayExpression: function(expr, precedence, flags, isPattern) {\n            var result, multiline, that = this;\n            if (!expr.elements.length) {\n                return \"[]\";\n            }\n            multiline = isPattern ? false : expr.elements.length > 1;\n            result = [\n                \"[\",\n                multiline ? newline : \"\"\n            ];\n            withIndent(function(indent) {\n                var i, iz;\n                for(i = 0, iz = expr.elements.length; i < iz; ++i){\n                    if (!expr.elements[i]) {\n                        if (multiline) {\n                            result.push(indent);\n                        }\n                        if (i + 1 === iz) {\n                            result.push(\",\");\n                        }\n                    } else {\n                        result.push(multiline ? indent : \"\");\n                        result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));\n                    }\n                    if (i + 1 < iz) {\n                        result.push(\",\" + (multiline ? newline : space));\n                    }\n                }\n            });\n            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n            }\n            result.push(multiline ? base : \"\");\n            result.push(\"]\");\n            return result;\n        },\n        RestElement: function(expr, precedence, flags) {\n            return \"...\" + this.generatePattern(expr.argument);\n        },\n        ClassExpression: function(expr, precedence, flags) {\n            var result, fragment;\n            result = [\n                \"class\"\n            ];\n            if (expr.id) {\n                result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));\n            }\n            if (expr.superClass) {\n                fragment = join(\"extends\", this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));\n                result = join(result, fragment);\n            }\n            result.push(space);\n            result.push(this.generateStatement(expr.body, S_TFFT));\n            return result;\n        },\n        MethodDefinition: function(expr, precedence, flags) {\n            var result, fragment;\n            if (expr[\"static\"]) {\n                result = [\n                    \"static\" + space\n                ];\n            } else {\n                result = [];\n            }\n            if (expr.kind === \"get\" || expr.kind === \"set\") {\n                fragment = [\n                    join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),\n                    this.generateFunctionBody(expr.value)\n                ];\n            } else {\n                fragment = [\n                    generateMethodPrefix(expr),\n                    this.generatePropertyKey(expr.key, expr.computed),\n                    this.generateFunctionBody(expr.value)\n                ];\n            }\n            return join(result, fragment);\n        },\n        Property: function(expr, precedence, flags) {\n            if (expr.kind === \"get\" || expr.kind === \"set\") {\n                return [\n                    expr.kind,\n                    noEmptySpace(),\n                    this.generatePropertyKey(expr.key, expr.computed),\n                    this.generateFunctionBody(expr.value)\n                ];\n            }\n            if (expr.shorthand) {\n                if (expr.value.type === \"AssignmentPattern\") {\n                    return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);\n                }\n                return this.generatePropertyKey(expr.key, expr.computed);\n            }\n            if (expr.method) {\n                return [\n                    generateMethodPrefix(expr),\n                    this.generatePropertyKey(expr.key, expr.computed),\n                    this.generateFunctionBody(expr.value)\n                ];\n            }\n            return [\n                this.generatePropertyKey(expr.key, expr.computed),\n                \":\" + space,\n                this.generateExpression(expr.value, Precedence.Assignment, E_TTT)\n            ];\n        },\n        ObjectExpression: function(expr, precedence, flags) {\n            var multiline, result, fragment, that = this;\n            if (!expr.properties.length) {\n                return \"{}\";\n            }\n            multiline = expr.properties.length > 1;\n            withIndent(function() {\n                fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);\n            });\n            if (!multiline) {\n                // issues 4\n                // Do not transform from\n                //   dejavu.Class.declare({\n                //       method2: function () {}\n                //   });\n                // to\n                //   dejavu.Class.declare({method2: function () {\n                //       }});\n                if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                    return [\n                        \"{\",\n                        space,\n                        fragment,\n                        space,\n                        \"}\"\n                    ];\n                }\n            }\n            withIndent(function(indent) {\n                var i, iz;\n                result = [\n                    \"{\",\n                    newline,\n                    indent,\n                    fragment\n                ];\n                if (multiline) {\n                    result.push(\",\" + newline);\n                    for(i = 1, iz = expr.properties.length; i < iz; ++i){\n                        result.push(indent);\n                        result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\n                        if (i + 1 < iz) {\n                            result.push(\",\" + newline);\n                        }\n                    }\n                }\n            });\n            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n            }\n            result.push(base);\n            result.push(\"}\");\n            return result;\n        },\n        AssignmentPattern: function(expr, precedence, flags) {\n            return this.generateAssignment(expr.left, expr.right, \"=\", precedence, flags);\n        },\n        ObjectPattern: function(expr, precedence, flags) {\n            var result, i, iz, multiline, property, that = this;\n            if (!expr.properties.length) {\n                return \"{}\";\n            }\n            multiline = false;\n            if (expr.properties.length === 1) {\n                property = expr.properties[0];\n                if (property.type === Syntax.Property && property.value.type !== Syntax.Identifier) {\n                    multiline = true;\n                }\n            } else {\n                for(i = 0, iz = expr.properties.length; i < iz; ++i){\n                    property = expr.properties[i];\n                    if (property.type === Syntax.Property && !property.shorthand) {\n                        multiline = true;\n                        break;\n                    }\n                }\n            }\n            result = [\n                \"{\",\n                multiline ? newline : \"\"\n            ];\n            withIndent(function(indent) {\n                var i, iz;\n                for(i = 0, iz = expr.properties.length; i < iz; ++i){\n                    result.push(multiline ? indent : \"\");\n                    result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\n                    if (i + 1 < iz) {\n                        result.push(\",\" + (multiline ? newline : space));\n                    }\n                }\n            });\n            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n            }\n            result.push(multiline ? base : \"\");\n            result.push(\"}\");\n            return result;\n        },\n        ThisExpression: function(expr, precedence, flags) {\n            return \"this\";\n        },\n        Super: function(expr, precedence, flags) {\n            return \"super\";\n        },\n        Identifier: function(expr, precedence, flags) {\n            return generateIdentifier(expr);\n        },\n        ImportDefaultSpecifier: function(expr, precedence, flags) {\n            return generateIdentifier(expr.id || expr.local);\n        },\n        ImportNamespaceSpecifier: function(expr, precedence, flags) {\n            var result = [\n                \"*\"\n            ];\n            var id = expr.id || expr.local;\n            if (id) {\n                result.push(space + \"as\" + noEmptySpace() + generateIdentifier(id));\n            }\n            return result;\n        },\n        ImportSpecifier: function(expr, precedence, flags) {\n            var imported = expr.imported;\n            var result = [\n                imported.name\n            ];\n            var local = expr.local;\n            if (local && local.name !== imported.name) {\n                result.push(noEmptySpace() + \"as\" + noEmptySpace() + generateIdentifier(local));\n            }\n            return result;\n        },\n        ExportSpecifier: function(expr, precedence, flags) {\n            var local = expr.local;\n            var result = [\n                local.name\n            ];\n            var exported = expr.exported;\n            if (exported && exported.name !== local.name) {\n                result.push(noEmptySpace() + \"as\" + noEmptySpace() + generateIdentifier(exported));\n            }\n            return result;\n        },\n        Literal: function(expr, precedence, flags) {\n            var raw;\n            if (expr.hasOwnProperty(\"raw\") && parse && extra.raw) {\n                try {\n                    raw = parse(expr.raw).body[0].expression;\n                    if (raw.type === Syntax.Literal) {\n                        if (raw.value === expr.value) {\n                            return expr.raw;\n                        }\n                    }\n                } catch (e) {\n                // not use raw property\n                }\n            }\n            if (expr.regex) {\n                return \"/\" + expr.regex.pattern + \"/\" + expr.regex.flags;\n            }\n            if (typeof expr.value === \"bigint\") {\n                return expr.value.toString() + \"n\";\n            }\n            // `expr.value` can be null if `expr.bigint` exists. We need to check\n            // `expr.bigint` first.\n            if (expr.bigint) {\n                return expr.bigint + \"n\";\n            }\n            if (expr.value === null) {\n                return \"null\";\n            }\n            if (typeof expr.value === \"string\") {\n                return escapeString(expr.value);\n            }\n            if (typeof expr.value === \"number\") {\n                return generateNumber(expr.value);\n            }\n            if (typeof expr.value === \"boolean\") {\n                return expr.value ? \"true\" : \"false\";\n            }\n            return generateRegExp(expr.value);\n        },\n        GeneratorExpression: function(expr, precedence, flags) {\n            return this.ComprehensionExpression(expr, precedence, flags);\n        },\n        ComprehensionExpression: function(expr, precedence, flags) {\n            // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]\n            // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6\n            var result, i, iz, fragment, that = this;\n            result = expr.type === Syntax.GeneratorExpression ? [\n                \"(\"\n            ] : [\n                \"[\"\n            ];\n            if (extra.moz.comprehensionExpressionStartsWithAssignment) {\n                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\n                result.push(fragment);\n            }\n            if (expr.blocks) {\n                withIndent(function() {\n                    for(i = 0, iz = expr.blocks.length; i < iz; ++i){\n                        fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);\n                        if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {\n                            result = join(result, fragment);\n                        } else {\n                            result.push(fragment);\n                        }\n                    }\n                });\n            }\n            if (expr.filter) {\n                result = join(result, \"if\" + space);\n                fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);\n                result = join(result, [\n                    \"(\",\n                    fragment,\n                    \")\"\n                ]);\n            }\n            if (!extra.moz.comprehensionExpressionStartsWithAssignment) {\n                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\n                result = join(result, fragment);\n            }\n            result.push(expr.type === Syntax.GeneratorExpression ? \")\" : \"]\");\n            return result;\n        },\n        ComprehensionBlock: function(expr, precedence, flags) {\n            var fragment;\n            if (expr.left.type === Syntax.VariableDeclaration) {\n                fragment = [\n                    expr.left.kind,\n                    noEmptySpace(),\n                    this.generateStatement(expr.left.declarations[0], S_FFFF)\n                ];\n            } else {\n                fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);\n            }\n            fragment = join(fragment, expr.of ? \"of\" : \"in\");\n            fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));\n            return [\n                \"for\" + space + \"(\",\n                fragment,\n                \")\"\n            ];\n        },\n        SpreadElement: function(expr, precedence, flags) {\n            return [\n                \"...\",\n                this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)\n            ];\n        },\n        TaggedTemplateExpression: function(expr, precedence, flags) {\n            var itemFlags = E_TTF;\n            if (!(flags & F_ALLOW_CALL)) {\n                itemFlags = E_TFF;\n            }\n            var result = [\n                this.generateExpression(expr.tag, Precedence.Call, itemFlags),\n                this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)\n            ];\n            return parenthesize(result, Precedence.TaggedTemplate, precedence);\n        },\n        TemplateElement: function(expr, precedence, flags) {\n            // Don't use \"cooked\". Since tagged template can use raw template\n            // representation. So if we do so, it breaks the script semantics.\n            return expr.value.raw;\n        },\n        TemplateLiteral: function(expr, precedence, flags) {\n            var result, i, iz;\n            result = [\n                \"`\"\n            ];\n            for(i = 0, iz = expr.quasis.length; i < iz; ++i){\n                result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));\n                if (i + 1 < iz) {\n                    result.push(\"${\" + space);\n                    result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));\n                    result.push(space + \"}\");\n                }\n            }\n            result.push(\"`\");\n            return result;\n        },\n        ModuleSpecifier: function(expr, precedence, flags) {\n            return this.Literal(expr, precedence, flags);\n        },\n        ImportExpression: function(expr, precedence, flag) {\n            return parenthesize([\n                \"import(\",\n                this.generateExpression(expr.source, Precedence.Assignment, E_TTT),\n                \")\"\n            ], Precedence.Call, precedence);\n        }\n    };\n    merge(CodeGenerator.prototype, CodeGenerator.Expression);\n    CodeGenerator.prototype.generateExpression = function(expr, precedence, flags) {\n        var result, type;\n        type = expr.type || Syntax.Property;\n        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {\n            return generateVerbatim(expr, precedence);\n        }\n        result = this[type](expr, precedence, flags);\n        if (extra.comment) {\n            result = addComments(expr, result);\n        }\n        return toSourceNodeWhenNeeded(result, expr);\n    };\n    CodeGenerator.prototype.generateStatement = function(stmt, flags) {\n        var result, fragment;\n        result = this[stmt.type](stmt, flags);\n        // Attach comments\n        if (extra.comment) {\n            result = addComments(stmt, result);\n        }\n        fragment = toSourceNodeWhenNeeded(result).toString();\n        if (stmt.type === Syntax.Program && !safeConcatenation && newline === \"\" && fragment.charAt(fragment.length - 1) === \"\\n\") {\n            result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\\s+$/, \"\") : fragment.replace(/\\s+$/, \"\");\n        }\n        return toSourceNodeWhenNeeded(result, stmt);\n    };\n    function generateInternal(node) {\n        var codegen;\n        codegen = new CodeGenerator();\n        if (isStatement(node)) {\n            return codegen.generateStatement(node, S_TFFF);\n        }\n        if (isExpression(node)) {\n            return codegen.generateExpression(node, Precedence.Sequence, E_TTT);\n        }\n        throw new Error(\"Unknown node type: \" + node.type);\n    }\n    function generate(node, options) {\n        var defaultOptions = getDefaultOptions(), result, pair;\n        if (options != null) {\n            // Obsolete options\n            //\n            //   `options.indent`\n            //   `options.base`\n            //\n            // Instead of them, we can use `option.format.indent`.\n            if (typeof options.indent === \"string\") {\n                defaultOptions.format.indent.style = options.indent;\n            }\n            if (typeof options.base === \"number\") {\n                defaultOptions.format.indent.base = options.base;\n            }\n            options = updateDeeply(defaultOptions, options);\n            indent = options.format.indent.style;\n            if (typeof options.base === \"string\") {\n                base = options.base;\n            } else {\n                base = stringRepeat(indent, options.format.indent.base);\n            }\n        } else {\n            options = defaultOptions;\n            indent = options.format.indent.style;\n            base = stringRepeat(indent, options.format.indent.base);\n        }\n        json = options.format.json;\n        renumber = options.format.renumber;\n        hexadecimal = json ? false : options.format.hexadecimal;\n        quotes = json ? \"double\" : options.format.quotes;\n        escapeless = options.format.escapeless;\n        newline = options.format.newline;\n        space = options.format.space;\n        if (options.format.compact) {\n            newline = space = indent = base = \"\";\n        }\n        parentheses = options.format.parentheses;\n        semicolons = options.format.semicolons;\n        safeConcatenation = options.format.safeConcatenation;\n        directive = options.directive;\n        parse = json ? null : options.parse;\n        sourceMap = options.sourceMap;\n        sourceCode = options.sourceCode;\n        preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;\n        extra = options;\n        if (sourceMap) {\n            if (!exports.browser) {\n                // We assume environment is node.js\n                // And prevent from including source-map by browserify\n                SourceNode = (__webpack_require__(/*! source-map */ \"(rsc)/../../node_modules/source-map/source-map.js\").SourceNode);\n            } else {\n                SourceNode = global.sourceMap.SourceNode;\n            }\n        }\n        result = generateInternal(node);\n        if (!sourceMap) {\n            pair = {\n                code: result.toString(),\n                map: null\n            };\n            return options.sourceMapWithCode ? pair : pair.code;\n        }\n        pair = result.toStringWithSourceMap({\n            file: options.file,\n            sourceRoot: options.sourceMapRoot\n        });\n        if (options.sourceContent) {\n            pair.map.setSourceContent(options.sourceMap, options.sourceContent);\n        }\n        if (options.sourceMapWithCode) {\n            return pair;\n        }\n        return pair.map.toString();\n    }\n    FORMAT_MINIFY = {\n        indent: {\n            style: \"\",\n            base: 0\n        },\n        renumber: true,\n        hexadecimal: true,\n        quotes: \"auto\",\n        escapeless: true,\n        compact: true,\n        parentheses: false,\n        semicolons: false\n    };\n    FORMAT_DEFAULTS = getDefaultOptions().format;\n    exports.version = __webpack_require__(/*! ./package.json */ \"(rsc)/../../node_modules/escodegen/package.json\").version;\n    exports.generate = generate;\n    exports.attachComments = estraverse.attachComments;\n    exports.Precedence = updateDeeply({}, Precedence);\n    exports.browser = false;\n    exports.FORMAT_MINIFY = FORMAT_MINIFY;\n    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;\n})(); /* vim: set sw=4 ts=4 et tw=80 : */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2VzY29kZWdlbi9lc2NvZGVnZW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ0EsR0FFQSxnREFBZ0QsR0FDL0M7SUFDRztJQUVBLElBQUlBLFFBQ0FDLFlBQ0FDLGtCQUNBQyxZQUNBQyxZQUNBQyxTQUNBQyxNQUNBQyxRQUNBQyxNQUNBQyxVQUNBQyxhQUNBQyxRQUNBQyxZQUNBQyxTQUNBQyxPQUNBQyxhQUNBQyxZQUNBQyxtQkFDQUMsV0FDQUMsT0FDQUMsT0FDQUMsV0FDQUMsWUFDQUMsb0JBQ0FDLGVBQ0FDO0lBRUpyQixhQUFhc0IsbUJBQU9BLENBQUM7SUFDckJyQixVQUFVcUIsbUJBQU9BLENBQUM7SUFFbEIxQixTQUFTSSxXQUFXSixNQUFNO0lBRTFCLDRDQUE0QztJQUM1QyxTQUFTMkIsYUFBYUMsSUFBSTtRQUN0QixPQUFPQyxjQUFjQyxVQUFVLENBQUNDLGNBQWMsQ0FBQ0gsS0FBS0ksSUFBSTtJQUM1RDtJQUVBLDJDQUEyQztJQUMzQyxTQUFTQyxZQUFZTCxJQUFJO1FBQ3JCLE9BQU9DLGNBQWNLLFNBQVMsQ0FBQ0gsY0FBYyxDQUFDSCxLQUFLSSxJQUFJO0lBQzNEO0lBRUEvQixhQUFhO1FBQ1RrQyxVQUFVO1FBQ1ZDLE9BQU87UUFDUEMsWUFBWTtRQUNaQyxhQUFhO1FBQ2JDLGVBQWU7UUFDZkMsVUFBVTtRQUNWQyxXQUFXO1FBQ1hDLFlBQVk7UUFDWkMsV0FBVztRQUNYQyxZQUFZO1FBQ1pDLFlBQVk7UUFDWkMsVUFBVTtRQUNWQyxZQUFZO1FBQ1pDLGNBQWM7UUFDZEMsVUFBVTtRQUNWQyxnQkFBZ0I7UUFDaEJDLGdCQUFnQjtRQUNoQkMsT0FBTztRQUNQQyxPQUFPO1FBQ1BDLFNBQVM7UUFDVEMsa0JBQWtCO1FBQ2xCQyxNQUFNO1FBQ05DLEtBQUs7UUFDTEMsZ0JBQWdCO1FBQ2hCQyxRQUFRO1FBQ1JDLFNBQVM7SUFDYjtJQUVBMUQs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LElBQUkrUyxRQUFRVSxhQUFhLEVBQUU7WUFDdkJSLEtBQUtJLEdBQUcsQ0FBQ0ssZ0JBQWdCLENBQUNYLFFBQVFsWCxTQUFTLEVBQ2pCa1gsUUFBUVUsYUFBYTtRQUNuRDtRQUVBLElBQUlWLFFBQVE5UyxpQkFBaUIsRUFBRTtZQUMzQixPQUFPZ1Q7UUFDWDtRQUVBLE9BQU9BLEtBQUtJLEdBQUcsQ0FBQ2hSLFFBQVE7SUFDNUI7SUFFQXJHLGdCQUFnQjtRQUNaakIsUUFBUTtZQUNKMkUsT0FBTztZQUNQNUUsTUFBTTtRQUNWO1FBQ0FHLFVBQVU7UUFDVkMsYUFBYTtRQUNiQyxRQUFRO1FBQ1JDLFlBQVk7UUFDWndFLFNBQVM7UUFDVHJFLGFBQWE7UUFDYkMsWUFBWTtJQUNoQjtJQUVBUyxrQkFBa0JzRCxvQkFBb0JFLE1BQU07SUFFNUN5VCxzSEFBbUQ7SUFDbkRBLGdCQUFnQixHQUFHSjtJQUNuQkksc0JBQXNCLEdBQUd0WSxXQUFXZ1osY0FBYztJQUNsRFYsa0JBQWtCLEdBQUc5UixhQUFhLENBQUMsR0FBRzNHO0lBQ3RDeVksZUFBZSxHQUFHO0lBQ2xCQSxxQkFBcUIsR0FBR2xYO0lBQ3hCa1gsdUJBQXVCLEdBQUdqWDtBQUM5QixNQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvZXNjb2RlZ2VuL2VzY29kZWdlbi5qcz85ODZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDE0IFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDE1IEluZ3ZhciBTdGVwYW55YW4gPG1lQHJyZXZlcnNlci5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxNCBJdmFuIE5pa3VsaW4gPGlmYWFhbkBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDEzIE1pY2hhZWwgRmljYXJyYSA8ZXNjb2RlZ2VuLmNvcHlyaWdodEBtaWNoYWVsLmZpY2FycmEubWU+XG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDEzIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XG4gIENvcHlyaWdodCAoQykgMjAxMyBJcmFrbGkgR296YWxpc2h2aWxpIDxyZm9iaWNAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgUm9iZXJ0IEd1c3QtQmFyZG9uIDxkb25hdGVAcm9iZXJ0Lmd1c3QtYmFyZG9uLm9yZz5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEpvaG4gRnJlZW1hbiA8amZyZWVtYW4wOEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMS0yMDEyIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgSm9vc3QtV2ltIEJvZWtlc3RlaWpuIDxqb29zdC13aW1AYm9la2VzdGVpam4ubmw+XG4gIENvcHlyaWdodCAoQykgMjAxMiBLcmlzIEtvd2FsIDxrcmlzLmtvd2FsQGNpeGFyLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFycGFkIEJvcnNvcyA8YXJwYWQuYm9yc29zQGdvb2dsZW1haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMjAgQXBwbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbi8qZ2xvYmFsIGV4cG9ydHM6dHJ1ZSwgcmVxdWlyZTp0cnVlLCBnbG9iYWw6dHJ1ZSovXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBTeW50YXgsXG4gICAgICAgIFByZWNlZGVuY2UsXG4gICAgICAgIEJpbmFyeVByZWNlZGVuY2UsXG4gICAgICAgIFNvdXJjZU5vZGUsXG4gICAgICAgIGVzdHJhdmVyc2UsXG4gICAgICAgIGVzdXRpbHMsXG4gICAgICAgIGJhc2UsXG4gICAgICAgIGluZGVudCxcbiAgICAgICAganNvbixcbiAgICAgICAgcmVudW1iZXIsXG4gICAgICAgIGhleGFkZWNpbWFsLFxuICAgICAgICBxdW90ZXMsXG4gICAgICAgIGVzY2FwZWxlc3MsXG4gICAgICAgIG5ld2xpbmUsXG4gICAgICAgIHNwYWNlLFxuICAgICAgICBwYXJlbnRoZXNlcyxcbiAgICAgICAgc2VtaWNvbG9ucyxcbiAgICAgICAgc2FmZUNvbmNhdGVuYXRpb24sXG4gICAgICAgIGRpcmVjdGl2ZSxcbiAgICAgICAgZXh0cmEsXG4gICAgICAgIHBhcnNlLFxuICAgICAgICBzb3VyY2VNYXAsXG4gICAgICAgIHNvdXJjZUNvZGUsXG4gICAgICAgIHByZXNlcnZlQmxhbmtMaW5lcyxcbiAgICAgICAgRk9STUFUX01JTklGWSxcbiAgICAgICAgRk9STUFUX0RFRkFVTFRTO1xuXG4gICAgZXN0cmF2ZXJzZSA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKTtcbiAgICBlc3V0aWxzID0gcmVxdWlyZSgnZXN1dGlscycpO1xuXG4gICAgU3ludGF4ID0gZXN0cmF2ZXJzZS5TeW50YXg7XG5cbiAgICAvLyBHZW5lcmF0aW9uIGlzIGRvbmUgYnkgZ2VuZXJhdGVFeHByZXNzaW9uLlxuICAgIGZ1bmN0aW9uIGlzRXhwcmVzc2lvbihub2RlKSB7XG4gICAgICAgIHJldHVybiBDb2RlR2VuZXJhdG9yLkV4cHJlc3Npb24uaGFzT3duUHJvcGVydHkobm9kZS50eXBlKTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0aW9uIGlzIGRvbmUgYnkgZ2VuZXJhdGVTdGF0ZW1lbnQuXG4gICAgZnVuY3Rpb24gaXNTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICByZXR1cm4gQ29kZUdlbmVyYXRvci5TdGF0ZW1lbnQuaGFzT3duUHJvcGVydHkobm9kZS50eXBlKTtcbiAgICB9XG5cbiAgICBQcmVjZWRlbmNlID0ge1xuICAgICAgICBTZXF1ZW5jZTogMCxcbiAgICAgICAgWWllbGQ6IDEsXG4gICAgICAgIEFzc2lnbm1lbnQ6IDEsXG4gICAgICAgIENvbmRpdGlvbmFsOiAyLFxuICAgICAgICBBcnJvd0Z1bmN0aW9uOiAyLFxuICAgICAgICBDb2FsZXNjZTogMyxcbiAgICAgICAgTG9naWNhbE9SOiA0LFxuICAgICAgICBMb2dpY2FsQU5EOiA1LFxuICAgICAgICBCaXR3aXNlT1I6IDYsXG4gICAgICAgIEJpdHdpc2VYT1I6IDcsXG4gICAgICAgIEJpdHdpc2VBTkQ6IDgsXG4gICAgICAgIEVxdWFsaXR5OiA5LFxuICAgICAgICBSZWxhdGlvbmFsOiAxMCxcbiAgICAgICAgQml0d2lzZVNISUZUOiAxMSxcbiAgICAgICAgQWRkaXRpdmU6IDEyLFxuICAgICAgICBNdWx0aXBsaWNhdGl2ZTogMTMsXG4gICAgICAgIEV4cG9uZW50aWF0aW9uOiAxNCxcbiAgICAgICAgQXdhaXQ6IDE1LFxuICAgICAgICBVbmFyeTogMTUsXG4gICAgICAgIFBvc3RmaXg6IDE2LFxuICAgICAgICBPcHRpb25hbENoYWluaW5nOiAxNyxcbiAgICAgICAgQ2FsbDogMTgsXG4gICAgICAgIE5ldzogMTksXG4gICAgICAgIFRhZ2dlZFRlbXBsYXRlOiAyMCxcbiAgICAgICAgTWVtYmVyOiAyMSxcbiAgICAgICAgUHJpbWFyeTogMjJcbiAgICB9O1xuXG4gICAgQmluYXJ5UHJlY2VkZW5jZSA9IHtcbiAgICAgICAgJz8/JzogUHJlY2VkZW5jZS5Db2FsZXNjZSxcbiAgICAgICAgJ3x8JzogUHJlY2VkZW5jZS5Mb2dpY2FsT1IsXG4gICAgICAgICcmJic6IFByZWNlZGVuY2UuTG9naWNhbEFORCxcbiAgICAgICAgJ3wnOiBQcmVjZWRlbmNlLkJpdHdpc2VPUixcbiAgICAgICAgJ14nOiBQcmVjZWRlbmNlLkJpdHdpc2VYT1IsXG4gICAgICAgICcmJzogUHJlY2VkZW5jZS5CaXR3aXNlQU5ELFxuICAgICAgICAnPT0nOiBQcmVjZWRlbmNlLkVxdWFsaXR5LFxuICAgICAgICAnIT0nOiBQcmVjZWRlbmNlLkVxdWFsaXR5LFxuICAgICAgICAnPT09JzogUHJlY2VkZW5jZS5FcXVhbGl0eSxcbiAgICAgICAgJyE9PSc6IFByZWNlZGVuY2UuRXF1YWxpdHksXG4gICAgICAgICdpcyc6IFByZWNlZGVuY2UuRXF1YWxpdHksXG4gICAgICAgICdpc250JzogUHJlY2VkZW5jZS5FcXVhbGl0eSxcbiAgICAgICAgJzwnOiBQcmVjZWRlbmNlLlJlbGF0aW9uYWwsXG4gICAgICAgICc+JzogUHJlY2VkZW5jZS5SZWxhdGlvbmFsLFxuICAgICAgICAnPD0nOiBQcmVjZWRlbmNlLlJlbGF0aW9uYWwsXG4gICAgICAgICc+PSc6IFByZWNlZGVuY2UuUmVsYXRpb25hbCxcbiAgICAgICAgJ2luJzogUHJlY2VkZW5jZS5SZWxhdGlvbmFsLFxuICAgICAgICAnaW5zdGFuY2VvZic6IFByZWNlZGVuY2UuUmVsYXRpb25hbCxcbiAgICAgICAgJzw8JzogUHJlY2VkZW5jZS5CaXR3aXNlU0hJRlQsXG4gICAgICAgICc+Pic6IFByZWNlZGVuY2UuQml0d2lzZVNISUZULFxuICAgICAgICAnPj4+JzogUHJlY2VkZW5jZS5CaXR3aXNlU0hJRlQsXG4gICAgICAgICcrJzogUHJlY2VkZW5jZS5BZGRpdGl2ZSxcbiAgICAgICAgJy0nOiBQcmVjZWRlbmNlLkFkZGl0aXZlLFxuICAgICAgICAnKic6IFByZWNlZGVuY2UuTXVsdGlwbGljYXRpdmUsXG4gICAgICAgICclJzogUHJlY2VkZW5jZS5NdWx0aXBsaWNhdGl2ZSxcbiAgICAgICAgJy8nOiBQcmVjZWRlbmNlLk11bHRpcGxpY2F0aXZlLFxuICAgICAgICAnKionOiBQcmVjZWRlbmNlLkV4cG9uZW50aWF0aW9uXG4gICAgfTtcblxuICAgIC8vRmxhZ3NcbiAgICB2YXIgRl9BTExPV19JTiA9IDEsXG4gICAgICAgIEZfQUxMT1dfQ0FMTCA9IDEgPDwgMSxcbiAgICAgICAgRl9BTExPV19VTlBBUkFUSF9ORVcgPSAxIDw8IDIsXG4gICAgICAgIEZfRlVOQ19CT0RZID0gMSA8PCAzLFxuICAgICAgICBGX0RJUkVDVElWRV9DVFggPSAxIDw8IDQsXG4gICAgICAgIEZfU0VNSUNPTE9OX09QVCA9IDEgPDwgNSxcbiAgICAgICAgRl9GT1VORF9DT0FMRVNDRSA9IDEgPDwgNjtcblxuICAgIC8vRXhwcmVzc2lvbiBmbGFnIHNldHNcbiAgICAvL05PVEU6IEZsYWcgb3JkZXI6XG4gICAgLy8gRl9BTExPV19JTlxuICAgIC8vIEZfQUxMT1dfQ0FMTFxuICAgIC8vIEZfQUxMT1dfVU5QQVJBVEhfTkVXXG4gICAgdmFyIEVfRlRUID0gRl9BTExPV19DQUxMIHwgRl9BTExPV19VTlBBUkFUSF9ORVcsXG4gICAgICAgIEVfVFRGID0gRl9BTExPV19JTiB8IEZfQUxMT1dfQ0FMTCxcbiAgICAgICAgRV9UVFQgPSBGX0FMTE9XX0lOIHwgRl9BTExPV19DQUxMIHwgRl9BTExPV19VTlBBUkFUSF9ORVcsXG4gICAgICAgIEVfVEZGID0gRl9BTExPV19JTixcbiAgICAgICAgRV9GRlQgPSBGX0FMTE9XX1VOUEFSQVRIX05FVyxcbiAgICAgICAgRV9URlQgPSBGX0FMTE9XX0lOIHwgRl9BTExPV19VTlBBUkFUSF9ORVc7XG5cbiAgICAvL1N0YXRlbWVudCBmbGFnIHNldHNcbiAgICAvL05PVEU6IEZsYWcgb3JkZXI6XG4gICAgLy8gRl9BTExPV19JTlxuICAgIC8vIEZfRlVOQ19CT0RZXG4gICAgLy8gRl9ESVJFQ1RJVkVfQ1RYXG4gICAgLy8gRl9TRU1JQ09MT05fT1BUXG4gICAgdmFyIFNfVEZGRiA9IEZfQUxMT1dfSU4sXG4gICAgICAgIFNfVEZGVCA9IEZfQUxMT1dfSU4gfCBGX1NFTUlDT0xPTl9PUFQsXG4gICAgICAgIFNfRkZGRiA9IDB4MDAsXG4gICAgICAgIFNfVEZURiA9IEZfQUxMT1dfSU4gfCBGX0RJUkVDVElWRV9DVFgsXG4gICAgICAgIFNfVFRGRiA9IEZfQUxMT1dfSU4gfCBGX0ZVTkNfQk9EWTtcblxuICAgIGZ1bmN0aW9uIGdldERlZmF1bHRPcHRpb25zKCkge1xuICAgICAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluZGVudDogbnVsbCxcbiAgICAgICAgICAgIGJhc2U6IG51bGwsXG4gICAgICAgICAgICBwYXJzZTogbnVsbCxcbiAgICAgICAgICAgIGNvbW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgICAgICAgaW5kZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnICAgICcsXG4gICAgICAgICAgICAgICAgICAgIGJhc2U6IDAsXG4gICAgICAgICAgICAgICAgICAgIGFkanVzdE11bHRpbGluZUNvbW1lbnQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBuZXdsaW5lOiAnXFxuJyxcbiAgICAgICAgICAgICAgICBzcGFjZTogJyAnLFxuICAgICAgICAgICAgICAgIGpzb246IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlbnVtYmVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBoZXhhZGVjaW1hbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcXVvdGVzOiAnc2luZ2xlJyxcbiAgICAgICAgICAgICAgICBlc2NhcGVsZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb21wYWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRoZXNlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZW1pY29sb25zOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNhZmVDb25jYXRlbmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZUJsYW5rTGluZXM6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW96OiB7XG4gICAgICAgICAgICAgICAgY29tcHJlaGVuc2lvbkV4cHJlc3Npb25TdGFydHNXaXRoQXNzaWdubWVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc3Rhcmxlc3NHZW5lcmF0b3I6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc291cmNlTWFwOiBudWxsLFxuICAgICAgICAgICAgc291cmNlTWFwUm9vdDogbnVsbCxcbiAgICAgICAgICAgIHNvdXJjZU1hcFdpdGhDb2RlOiBmYWxzZSxcbiAgICAgICAgICAgIGRpcmVjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICByYXc6IHRydWUsXG4gICAgICAgICAgICB2ZXJiYXRpbTogbnVsbCxcbiAgICAgICAgICAgIHNvdXJjZUNvZGU6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJpbmdSZXBlYXQoc3RyLCBudW0pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gICAgICAgIGZvciAobnVtIHw9IDA7IG51bSA+IDA7IG51bSA+Pj49IDEsIHN0ciArPSBzdHIpIHtcbiAgICAgICAgICAgIGlmIChudW0gJiAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzTGluZVRlcm1pbmF0b3Ioc3RyKSB7XG4gICAgICAgIHJldHVybiAoL1tcXHJcXG5dL2cpLnRlc3Qoc3RyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHN0cikge1xuICAgICAgICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGxlbiAmJiBlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihzdHIuY2hhckNvZGVBdChsZW4gLSAxKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBvdmVycmlkZSkge1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGtleSBpbiBvdmVycmlkZSkge1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG92ZXJyaWRlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVEZWVwbHkodGFyZ2V0LCBvdmVycmlkZSkge1xuICAgICAgICB2YXIga2V5LCB2YWw7XG5cbiAgICAgICAgZnVuY3Rpb24gaXNIYXNoT2JqZWN0KHRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmIHRhcmdldCBpbnN0YW5jZW9mIE9iamVjdCAmJiAhKHRhcmdldCBpbnN0YW5jZW9mIFJlZ0V4cCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGtleSBpbiBvdmVycmlkZSkge1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBvdmVycmlkZVtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChpc0hhc2hPYmplY3QodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNIYXNoT2JqZWN0KHRhcmdldFtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlRGVlcGx5KHRhcmdldFtrZXldLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB1cGRhdGVEZWVwbHkoe30sIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZU51bWJlcih2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0LCBwb2ludCwgdGVtcCwgZXhwb25lbnQsIHBvcztcblxuICAgICAgICBpZiAodmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWVyaWMgbGl0ZXJhbCB3aG9zZSB2YWx1ZSBpcyBOYU4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1lcmljIGxpdGVyYWwgd2hvc2UgdmFsdWUgaXMgbmVnYXRpdmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMSAvIDApIHtcbiAgICAgICAgICAgIHJldHVybiBqc29uID8gJ251bGwnIDogcmVudW1iZXIgPyAnMWU0MDAnIDogJzFlKzQwMCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSAnJyArIHZhbHVlO1xuICAgICAgICBpZiAoIXJlbnVtYmVyIHx8IHJlc3VsdC5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcG9pbnQgPSByZXN1bHQuaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoIWpzb24gJiYgcmVzdWx0LmNoYXJDb2RlQXQoMCkgPT09IDB4MzAgIC8qIDAgKi8gJiYgcG9pbnQgPT09IDEpIHtcbiAgICAgICAgICAgIHBvaW50ID0gMDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wID0gcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgnZSsnLCAnZScpO1xuICAgICAgICBleHBvbmVudCA9IDA7XG4gICAgICAgIGlmICgocG9zID0gdGVtcC5pbmRleE9mKCdlJykpID4gMCkge1xuICAgICAgICAgICAgZXhwb25lbnQgPSArdGVtcC5zbGljZShwb3MgKyAxKTtcbiAgICAgICAgICAgIHRlbXAgPSB0ZW1wLnNsaWNlKDAsIHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvaW50ID49IDApIHtcbiAgICAgICAgICAgIGV4cG9uZW50IC09IHRlbXAubGVuZ3RoIC0gcG9pbnQgLSAxO1xuICAgICAgICAgICAgdGVtcCA9ICsodGVtcC5zbGljZSgwLCBwb2ludCkgKyB0ZW1wLnNsaWNlKHBvaW50ICsgMSkpICsgJyc7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gMDtcbiAgICAgICAgd2hpbGUgKHRlbXAuY2hhckNvZGVBdCh0ZW1wLmxlbmd0aCArIHBvcyAtIDEpID09PSAweDMwICAvKiAwICovKSB7XG4gICAgICAgICAgICAtLXBvcztcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zICE9PSAwKSB7XG4gICAgICAgICAgICBleHBvbmVudCAtPSBwb3M7XG4gICAgICAgICAgICB0ZW1wID0gdGVtcC5zbGljZSgwLCBwb3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvbmVudCAhPT0gMCkge1xuICAgICAgICAgICAgdGVtcCArPSAnZScgKyBleHBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRlbXAubGVuZ3RoIDwgcmVzdWx0Lmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICAgICAoaGV4YWRlY2ltYWwgJiYgdmFsdWUgPiAxZTEyICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSAmJiAodGVtcCA9ICcweCcgKyB2YWx1ZS50b1N0cmluZygxNikpLmxlbmd0aCA8IHJlc3VsdC5sZW5ndGgpKSAmJlxuICAgICAgICAgICAgICAgICt0ZW1wID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgdmFsaWQgUmVnRXhwIGV4cHJlc3Npb24uXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vQ29uc3RlbGxhdGlvbi9pdiBFbmdpbmVcblxuICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cENoYXJhY3RlcihjaCwgcHJldmlvdXNJc0JhY2tzbGFzaCkge1xuICAgICAgICAvLyBub3QgaGFuZGxpbmcgJ1xcJyBhbmQgaGFuZGxpbmcgXFx1MjAyOCBvciBcXHUyMDI5IHRvIHVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgIGlmICgoY2ggJiB+MSkgPT09IDB4MjAyOCkge1xuICAgICAgICAgICAgcmV0dXJuIChwcmV2aW91c0lzQmFja3NsYXNoID8gJ3UnIDogJ1xcXFx1JykgKyAoKGNoID09PSAweDIwMjgpID8gJzIwMjgnIDogJzIwMjknKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMTAgfHwgY2ggPT09IDEzKSB7ICAvLyBcXG4sIFxcclxuICAgICAgICAgICAgcmV0dXJuIChwcmV2aW91c0lzQmFja3NsYXNoID8gJycgOiAnXFxcXCcpICsgKChjaCA9PT0gMTApID8gJ24nIDogJ3InKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVSZWdFeHAocmVnKSB7XG4gICAgICAgIHZhciBtYXRjaCwgcmVzdWx0LCBmbGFncywgaSwgaXosIGNoLCBjaGFyYWN0ZXJJbkJyYWNrLCBwcmV2aW91c0lzQmFja3NsYXNoO1xuXG4gICAgICAgIHJlc3VsdCA9IHJlZy50b1N0cmluZygpO1xuXG4gICAgICAgIGlmIChyZWcuc291cmNlKSB7XG4gICAgICAgICAgICAvLyBleHRyYWN0IGZsYWcgZnJvbSB0b1N0cmluZyByZXN1bHRcbiAgICAgICAgICAgIG1hdGNoID0gcmVzdWx0Lm1hdGNoKC9cXC8oW14vXSopJC8pO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZsYWdzID0gbWF0Y2hbMV07XG4gICAgICAgICAgICByZXN1bHQgPSAnJztcblxuICAgICAgICAgICAgY2hhcmFjdGVySW5CcmFjayA9IGZhbHNlO1xuICAgICAgICAgICAgcHJldmlvdXNJc0JhY2tzbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSByZWcuc291cmNlLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHJlZy5zb3VyY2UuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAgICAgICAgIGlmICghcHJldmlvdXNJc0JhY2tzbGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcmFjdGVySW5CcmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA5MykgeyAgLy8gXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlckluQnJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gNDcpIHsgIC8vIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gOTEpIHsgIC8vIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXJJbkJyYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gZXNjYXBlUmVnRXhwQ2hhcmFjdGVyKGNoLCBwcmV2aW91c0lzQmFja3NsYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNJc0JhY2tzbGFzaCA9IGNoID09PSA5MjsgIC8vIFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbmV3IFJlZ0V4cChcIlxcXFxcXG4nKSBpcyBwcm92aWRlZCwgY3JlYXRlIC9cXG4vXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVSZWdFeHBDaGFyYWN0ZXIoY2gsIHByZXZpb3VzSXNCYWNrc2xhc2gpO1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IGxpa2UgL1xcXFxbL10vXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzSXNCYWNrc2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAnLycgKyByZXN1bHQgKyAnLycgKyBmbGFncztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXNjYXBlQWxsb3dlZENoYXJhY3Rlcihjb2RlLCBuZXh0KSB7XG4gICAgICAgIHZhciBoZXg7XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MDggIC8qIFxcYiAqLykge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcYic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA9PT0gMHgwQyAgLyogXFxmICovKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFxmJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSAweDA5ICAvKiBcXHQgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaGV4ID0gY29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKGpzb24gfHwgY29kZSA+IDB4RkYpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHUnICsgJzAwMDAnLnNsaWNlKGhleC5sZW5ndGgpICsgaGV4O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAwMCAmJiAhZXN1dGlscy5jb2RlLmlzRGVjaW1hbERpZ2l0KG5leHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFwwJztcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMEIgIC8qIFxcdiAqLykgeyAvLyAnXFx2J1xuICAgICAgICAgICAgcmV0dXJuICdcXFxceDBCJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHgnICsgJzAwJy5zbGljZShoZXgubGVuZ3RoKSArIGhleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzY2FwZURpc2FsbG93ZWRDaGFyYWN0ZXIoY29kZSkge1xuICAgICAgICBpZiAoY29kZSA9PT0gMHg1QyAgLyogXFwgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXFxcXFwnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MEEgIC8qIFxcbiAqLykge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcbic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA9PT0gMHgwRCAgLyogXFxyICovKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFxyJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSAweDIwMjgpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHUyMDI4JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSAweDIwMjkpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHUyMDI5JztcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0bHkgY2xhc3NpZmllZCBjaGFyYWN0ZXInKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc2NhcGVEaXJlY3RpdmUoc3RyKSB7XG4gICAgICAgIHZhciBpLCBpeiwgY29kZSwgcXVvdGU7XG5cbiAgICAgICAgcXVvdGUgPSBxdW90ZXMgPT09ICdkb3VibGUnID8gJ1wiJyA6ICdcXCcnO1xuICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IHN0ci5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gMHgyNyAgLyogJyAqLykge1xuICAgICAgICAgICAgICAgIHF1b3RlID0gJ1wiJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAgLyogXCIgKi8pIHtcbiAgICAgICAgICAgICAgICBxdW90ZSA9ICdcXCcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDVDICAvKiBcXCAqLykge1xuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBxdW90ZSArIHN0ciArIHF1b3RlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzdHIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnLCBpLCBsZW4sIGNvZGUsIHNpbmdsZVF1b3RlcyA9IDAsIGRvdWJsZVF1b3RlcyA9IDAsIHNpbmdsZSwgcXVvdGU7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gMHgyNyAgLyogJyAqLykge1xuICAgICAgICAgICAgICAgICsrc2luZ2xlUXVvdGVzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyICAvKiBcIiAqLykge1xuICAgICAgICAgICAgICAgICsrZG91YmxlUXVvdGVzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDJGICAvKiAvICovICYmIGpzb24pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihjb2RlKSB8fCBjb2RlID09PSAweDVDICAvKiBcXCAqLykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVEaXNhbGxvd2VkQ2hhcmFjdGVyKGNvZGUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZXN1dGlscy5jb2RlLmlzSWRlbnRpZmllclBhcnRFUzUoY29kZSkgJiYgKGpzb24gJiYgY29kZSA8IDB4MjAgIC8qIFNQICovIHx8ICFqc29uICYmICFlc2NhcGVsZXNzICYmIChjb2RlIDwgMHgyMCAgLyogU1AgKi8gfHwgY29kZSA+IDB4N0UgIC8qIH4gKi8pKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVBbGxvd2VkQ2hhcmFjdGVyKGNvZGUsIHN0ci5jaGFyQ29kZUF0KGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNpbmdsZSA9ICEocXVvdGVzID09PSAnZG91YmxlJyB8fCAocXVvdGVzID09PSAnYXV0bycgJiYgZG91YmxlUXVvdGVzIDwgc2luZ2xlUXVvdGVzKSk7XG4gICAgICAgIHF1b3RlID0gc2luZ2xlID8gJ1xcJycgOiAnXCInO1xuXG4gICAgICAgIGlmICghKHNpbmdsZSA/IHNpbmdsZVF1b3RlcyA6IGRvdWJsZVF1b3RlcykpIHtcbiAgICAgICAgICAgIHJldHVybiBxdW90ZSArIHJlc3VsdCArIHF1b3RlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyID0gcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSBxdW90ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmICgoY29kZSA9PT0gMHgyNyAgLyogJyAqLyAmJiBzaW5nbGUpIHx8IChjb2RlID09PSAweDIyICAvKiBcIiAqLyAmJiAhc2luZ2xlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxcXCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQgKyBxdW90ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmbGF0dGVuIGFuIGFycmF5IHRvIGEgc3RyaW5nLCB3aGVyZSB0aGUgYXJyYXkgY2FuIGNvbnRhaW5cbiAgICAgKiBlaXRoZXIgc3RyaW5ncyBvciBuZXN0ZWQgYXJyYXlzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlblRvU3RyaW5nKGFycikge1xuICAgICAgICB2YXIgaSwgaXosIGVsZW0sIHJlc3VsdCA9ICcnO1xuICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGFyci5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICBlbGVtID0gYXJyW2ldO1xuICAgICAgICAgICAgcmVzdWx0ICs9IEFycmF5LmlzQXJyYXkoZWxlbSkgPyBmbGF0dGVuVG9TdHJpbmcoZWxlbSkgOiBlbGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBnZW5lcmF0ZWQgdG8gYSBTb3VyY2VOb2RlIHdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChnZW5lcmF0ZWQsIG5vZGUpIHtcbiAgICAgICAgaWYgKCFzb3VyY2VNYXApIHtcbiAgICAgICAgICAgIC8vIHdpdGggbm8gc291cmNlIG1hcHMsIGdlbmVyYXRlZCBpcyBlaXRoZXIgYW5cbiAgICAgICAgICAgIC8vIGFycmF5IG9yIGEgc3RyaW5nLiAgaWYgYW4gYXJyYXksIGZsYXR0ZW4gaXQuXG4gICAgICAgICAgICAvLyBpZiBhIHN0cmluZywganVzdCByZXR1cm4gaXRcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGdlbmVyYXRlZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlblRvU3RyaW5nKGdlbmVyYXRlZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRlZCBpbnN0YW5jZW9mIFNvdXJjZU5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubG9jID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU291cmNlTm9kZShudWxsLCBudWxsLCBzb3VyY2VNYXAsIGdlbmVyYXRlZCwgbm9kZS5uYW1lIHx8IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU291cmNlTm9kZShub2RlLmxvYy5zdGFydC5saW5lLCBub2RlLmxvYy5zdGFydC5jb2x1bW4sIChzb3VyY2VNYXAgPT09IHRydWUgPyBub2RlLmxvYy5zb3VyY2UgfHwgbnVsbCA6IHNvdXJjZU1hcCksIGdlbmVyYXRlZCwgbm9kZS5uYW1lIHx8IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vRW1wdHlTcGFjZSgpIHtcbiAgICAgICAgcmV0dXJuIChzcGFjZSkgPyBzcGFjZSA6ICcgJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBqb2luKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBsZWZ0U291cmNlLFxuICAgICAgICAgICAgcmlnaHRTb3VyY2UsXG4gICAgICAgICAgICBsZWZ0Q2hhckNvZGUsXG4gICAgICAgICAgICByaWdodENoYXJDb2RlO1xuXG4gICAgICAgIGxlZnRTb3VyY2UgPSB0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKGxlZnQpLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChsZWZ0U291cmNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtyaWdodF07XG4gICAgICAgIH1cblxuICAgICAgICByaWdodFNvdXJjZSA9IHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmlnaHQpLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChyaWdodFNvdXJjZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbbGVmdF07XG4gICAgICAgIH1cblxuICAgICAgICBsZWZ0Q2hhckNvZGUgPSBsZWZ0U291cmNlLmNoYXJDb2RlQXQobGVmdFNvdXJjZS5sZW5ndGggLSAxKTtcbiAgICAgICAgcmlnaHRDaGFyQ29kZSA9IHJpZ2h0U291cmNlLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgaWYgKChsZWZ0Q2hhckNvZGUgPT09IDB4MkIgIC8qICsgKi8gfHwgbGVmdENoYXJDb2RlID09PSAweDJEICAvKiAtICovKSAmJiBsZWZ0Q2hhckNvZGUgPT09IHJpZ2h0Q2hhckNvZGUgfHxcbiAgICAgICAgICAgIGVzdXRpbHMuY29kZS5pc0lkZW50aWZpZXJQYXJ0RVM1KGxlZnRDaGFyQ29kZSkgJiYgZXN1dGlscy5jb2RlLmlzSWRlbnRpZmllclBhcnRFUzUocmlnaHRDaGFyQ29kZSkgfHxcbiAgICAgICAgICAgIGxlZnRDaGFyQ29kZSA9PT0gMHgyRiAgLyogLyAqLyAmJiByaWdodENoYXJDb2RlID09PSAweDY5ICAvKiBpICovKSB7IC8vIGluZml4IHdvcmQgb3BlcmF0b3JzIGFsbCBzdGFydCB3aXRoIGBpYFxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCBub0VtcHR5U3BhY2UoKSwgcmlnaHRdO1xuICAgICAgICB9IGVsc2UgaWYgKGVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2UobGVmdENoYXJDb2RlKSB8fCBlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihsZWZ0Q2hhckNvZGUpIHx8XG4gICAgICAgICAgICAgICAgZXN1dGlscy5jb2RlLmlzV2hpdGVTcGFjZShyaWdodENoYXJDb2RlKSB8fCBlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihyaWdodENoYXJDb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtsZWZ0LCBzcGFjZSwgcmlnaHRdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEluZGVudChzdG10KSB7XG4gICAgICAgIHJldHVybiBbYmFzZSwgc3RtdF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2l0aEluZGVudChmbikge1xuICAgICAgICB2YXIgcHJldmlvdXNCYXNlO1xuICAgICAgICBwcmV2aW91c0Jhc2UgPSBiYXNlO1xuICAgICAgICBiYXNlICs9IGluZGVudDtcbiAgICAgICAgZm4oYmFzZSk7XG4gICAgICAgIGJhc2UgPSBwcmV2aW91c0Jhc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlU3BhY2VzKHN0cikge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gc3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBpZiAoZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3Ioc3RyLmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChzdHIubGVuZ3RoIC0gMSkgLSBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkanVzdE11bHRpbGluZUNvbW1lbnQodmFsdWUsIHNwZWNpYWxCYXNlKSB7XG4gICAgICAgIHZhciBhcnJheSwgaSwgbGVuLCBsaW5lLCBqLCBzcGFjZXMsIHByZXZpb3VzQmFzZSwgc247XG5cbiAgICAgICAgYXJyYXkgPSB2YWx1ZS5zcGxpdCgvXFxyXFxufFtcXHJcXG5dLyk7XG4gICAgICAgIHNwYWNlcyA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgLy8gZmlyc3QgbGluZSBkb2Vzbid0IGhhdmUgaW5kZW50YXRpb25cbiAgICAgICAgZm9yIChpID0gMSwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGxpbmUgPSBhcnJheVtpXTtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBsaW5lLmxlbmd0aCAmJiBlc3V0aWxzLmNvZGUuaXNXaGl0ZVNwYWNlKGxpbmUuY2hhckNvZGVBdChqKSkpIHtcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BhY2VzID4gaikge1xuICAgICAgICAgICAgICAgIHNwYWNlcyA9IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNwZWNpYWxCYXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gcGF0dGVybiBsaWtlXG4gICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAvLyAgIHZhciB0ID0gMjA7ICAvKlxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICogdGhpcyBpcyBjb21tZW50XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIHByZXZpb3VzQmFzZSA9IGJhc2U7XG4gICAgICAgICAgICBpZiAoYXJyYXlbMV1bc3BhY2VzXSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lhbEJhc2UgKz0gJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFzZSA9IHNwZWNpYWxCYXNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNwYWNlcyAmIDEpIHtcbiAgICAgICAgICAgICAgICAvLyAvKlxuICAgICAgICAgICAgICAgIC8vICAqXG4gICAgICAgICAgICAgICAgLy8gICovXG4gICAgICAgICAgICAgICAgLy8gSWYgc3BhY2VzIGFyZSBvZGQgbnVtYmVyLCBhYm92ZSBwYXR0ZXJuIGlzIGNvbnNpZGVyZWQuXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FzdGUgMSBzcGFjZS5cbiAgICAgICAgICAgICAgICAtLXNwYWNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzQmFzZSA9IGJhc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgc24gPSB0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKGFkZEluZGVudChhcnJheVtpXS5zbGljZShzcGFjZXMpKSk7XG4gICAgICAgICAgICBhcnJheVtpXSA9IHNvdXJjZU1hcCA/IHNuLmpvaW4oJycpIDogc247XG4gICAgICAgIH1cblxuICAgICAgICBiYXNlID0gcHJldmlvdXNCYXNlO1xuXG4gICAgICAgIHJldHVybiBhcnJheS5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCwgc3BlY2lhbEJhc2UpIHtcbiAgICAgICAgaWYgKGNvbW1lbnQudHlwZSA9PT0gJ0xpbmUnKSB7XG4gICAgICAgICAgICBpZiAoZW5kc1dpdGhMaW5lVGVybWluYXRvcihjb21tZW50LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnLy8nICsgY29tbWVudC52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIHVzZSBMaW5lVGVybWluYXRvclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAnLy8nICsgY29tbWVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhLmZvcm1hdC5pbmRlbnQuYWRqdXN0TXVsdGlsaW5lQ29tbWVudCAmJiAvW1xcblxccl0vLnRlc3QoY29tbWVudC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGp1c3RNdWx0aWxpbmVDb21tZW50KCcvKicgKyBjb21tZW50LnZhbHVlICsgJyovJywgc3BlY2lhbEJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnLyonICsgY29tbWVudC52YWx1ZSArICcqLyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQ29tbWVudHMoc3RtdCwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBpLCBsZW4sIGNvbW1lbnQsIHNhdmUsIHRhaWxpbmdUb1N0YXRlbWVudCwgc3BlY2lhbEJhc2UsIGZyYWdtZW50LFxuICAgICAgICAgICAgZXh0UmFuZ2UsIHJhbmdlLCBwcmV2UmFuZ2UsIHByZWZpeCwgaW5maXgsIHN1ZmZpeCwgY291bnQ7XG5cbiAgICAgICAgaWYgKHN0bXQubGVhZGluZ0NvbW1lbnRzICYmIHN0bXQubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNhdmUgPSByZXN1bHQ7XG5cbiAgICAgICAgICAgIGlmIChwcmVzZXJ2ZUJsYW5rTGluZXMpIHtcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gc3RtdC5sZWFkaW5nQ29tbWVudHNbMF07XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgICAgICBleHRSYW5nZSA9IGNvbW1lbnQuZXh0ZW5kZWRSYW5nZTtcbiAgICAgICAgICAgICAgICByYW5nZSA9IGNvbW1lbnQucmFuZ2U7XG5cbiAgICAgICAgICAgICAgICBwcmVmaXggPSBzb3VyY2VDb2RlLnN1YnN0cmluZyhleHRSYW5nZVswXSwgcmFuZ2VbMF0pO1xuICAgICAgICAgICAgICAgIGNvdW50ID0gKHByZWZpeC5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdHJpbmdSZXBlYXQoJ1xcbicsIGNvdW50KSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCkpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwcmVmaXgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHByZXZSYW5nZSA9IHJhbmdlO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgbGVuID0gc3RtdC5sZWFkaW5nQ29tbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IHN0bXQubGVhZGluZ0NvbW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IGNvbW1lbnQucmFuZ2U7XG5cbiAgICAgICAgICAgICAgICAgICAgaW5maXggPSBzb3VyY2VDb2RlLnN1YnN0cmluZyhwcmV2UmFuZ2VbMV0sIHJhbmdlWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSAoaW5maXgubWF0Y2goL1xcbi9nKSB8fCBbXSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdHJpbmdSZXBlYXQoJ1xcbicsIGNvdW50KSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCkpKTtcblxuICAgICAgICAgICAgICAgICAgICBwcmV2UmFuZ2UgPSByYW5nZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdWZmaXggPSBzb3VyY2VDb2RlLnN1YnN0cmluZyhyYW5nZVsxXSwgZXh0UmFuZ2VbMV0pO1xuICAgICAgICAgICAgICAgIGNvdW50ID0gKHN1ZmZpeC5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RyaW5nUmVwZWF0KCdcXG4nLCBjb3VudCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gc3RtdC5sZWFkaW5nQ29tbWVudHNbMF07XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHNhZmVDb25jYXRlbmF0aW9uICYmIHN0bXQudHlwZSA9PT0gU3ludGF4LlByb2dyYW0gJiYgc3RtdC5ib2R5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlQ29tbWVudChjb21tZW50KSk7XG4gICAgICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgbGVuID0gc3RtdC5sZWFkaW5nQ29tbWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IHN0bXQubGVhZGluZ0NvbW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IFtnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChmcmFnbWVudCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LnB1c2goJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudChmcmFnbWVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYWRkSW5kZW50KHNhdmUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdG10LnRyYWlsaW5nQ29tbWVudHMpIHtcblxuICAgICAgICAgICAgaWYgKHByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzdG10LnRyYWlsaW5nQ29tbWVudHNbMF07XG4gICAgICAgICAgICAgICAgZXh0UmFuZ2UgPSBjb21tZW50LmV4dGVuZGVkUmFuZ2U7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjb21tZW50LnJhbmdlO1xuXG4gICAgICAgICAgICAgICAgcHJlZml4ID0gc291cmNlQ29kZS5zdWJzdHJpbmcoZXh0UmFuZ2VbMF0sIHJhbmdlWzBdKTtcbiAgICAgICAgICAgICAgICBjb3VudCA9IChwcmVmaXgubWF0Y2goL1xcbi9nKSB8fCBbXSkubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdHJpbmdSZXBlYXQoJ1xcbicsIGNvdW50KSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCkpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwcmVmaXgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFpbGluZ1RvU3RhdGVtZW50ID0gIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHNwZWNpYWxCYXNlID0gc3RyaW5nUmVwZWF0KCcgJywgY2FsY3VsYXRlU3BhY2VzKHRvU291cmNlTm9kZVdoZW5OZWVkZWQoW2Jhc2UsIHJlc3VsdCwgaW5kZW50XSkudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHN0bXQudHJhaWxpbmdDb21tZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gc3RtdC50cmFpbGluZ0NvbW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFpbGluZ1RvU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhc3N1bWUgdGFyZ2V0IGxpa2UgZm9sbG93aW5nIHNjcmlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhciB0ID0gMjA7ICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgKiBUaGlzIGlzIGNvbW1lbnQgb2YgdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdCBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Jlc3VsdCwgaW5kZW50XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Jlc3VsdCwgc3BlY2lhbEJhc2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQsIHNwZWNpYWxCYXNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbcmVzdWx0LCBhZGRJbmRlbnQoZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQpKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IGxlbiAtIDEgJiYgIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbcmVzdWx0LCAnXFxuJ107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQmxhbmtMaW5lcyhzdGFydCwgZW5kLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIGosIG5ld2xpbmVDb3VudCA9IDA7XG5cbiAgICAgICAgZm9yIChqID0gc3RhcnQ7IGogPCBlbmQ7IGorKykge1xuICAgICAgICAgICAgaWYgKHNvdXJjZUNvZGVbal0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgbmV3bGluZUNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGogPSAxOyBqIDwgbmV3bGluZUNvdW50OyBqKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyZW50aGVzaXplKHRleHQsIGN1cnJlbnQsIHNob3VsZCkge1xuICAgICAgICBpZiAoY3VycmVudCA8IHNob3VsZCkge1xuICAgICAgICAgICAgcmV0dXJuIFsnKCcsIHRleHQsICcpJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVWZXJiYXRpbVN0cmluZyhzdHJpbmcpIHtcbiAgICAgICAgdmFyIGksIGl6LCByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9IHN0cmluZy5zcGxpdCgvXFxyXFxufFxcbi8pO1xuICAgICAgICBmb3IgKGkgPSAxLCBpeiA9IHJlc3VsdC5sZW5ndGg7IGkgPCBpejsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBuZXdsaW5lICsgYmFzZSArIHJlc3VsdFtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlVmVyYmF0aW0oZXhwciwgcHJlY2VkZW5jZSkge1xuICAgICAgICB2YXIgdmVyYmF0aW0sIHJlc3VsdCwgcHJlYztcbiAgICAgICAgdmVyYmF0aW0gPSBleHByW2V4dHJhLnZlcmJhdGltXTtcblxuICAgICAgICBpZiAodHlwZW9mIHZlcmJhdGltID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyZW50aGVzaXplKGdlbmVyYXRlVmVyYmF0aW1TdHJpbmcodmVyYmF0aW0pLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHZlcmJhdGltIGlzIG9iamVjdFxuICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVWZXJiYXRpbVN0cmluZyh2ZXJiYXRpbS5jb250ZW50KTtcbiAgICAgICAgICAgIHByZWMgPSAodmVyYmF0aW0ucHJlY2VkZW5jZSAhPSBudWxsKSA/IHZlcmJhdGltLnByZWNlZGVuY2UgOiBQcmVjZWRlbmNlLlNlcXVlbmNlO1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyZW50aGVzaXplKHJlc3VsdCwgcHJlYywgcHJlY2VkZW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQsIGV4cHIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENvZGVHZW5lcmF0b3IoKSB7XG4gICAgfVxuXG4gICAgLy8gSGVscGVycy5cblxuICAgIENvZGVHZW5lcmF0b3IucHJvdG90eXBlLm1heWJlQmxvY2sgPSBmdW5jdGlvbihzdG10LCBmbGFncykge1xuICAgICAgICB2YXIgcmVzdWx0LCBub0xlYWRpbmdDb21tZW50LCB0aGF0ID0gdGhpcztcblxuICAgICAgICBub0xlYWRpbmdDb21tZW50ID0gIWV4dHJhLmNvbW1lbnQgfHwgIXN0bXQubGVhZGluZ0NvbW1lbnRzO1xuXG4gICAgICAgIGlmIChzdG10LnR5cGUgPT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCAmJiBub0xlYWRpbmdDb21tZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW3NwYWNlLCB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQsIGZsYWdzKV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RtdC50eXBlID09PSBTeW50YXguRW1wdHlTdGF0ZW1lbnQgJiYgbm9MZWFkaW5nQ29tbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuICc7JztcbiAgICAgICAgfVxuXG4gICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgIG5ld2xpbmUsXG4gICAgICAgICAgICAgICAgYWRkSW5kZW50KHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdCwgZmxhZ3MpKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUubWF5YmVCbG9ja1N1ZmZpeCA9IGZ1bmN0aW9uIChzdG10LCByZXN1bHQpIHtcbiAgICAgICAgdmFyIGVuZHMgPSBlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKHN0bXQudHlwZSA9PT0gU3ludGF4LkJsb2NrU3RhdGVtZW50ICYmICghZXh0cmEuY29tbWVudCB8fCAhc3RtdC5sZWFkaW5nQ29tbWVudHMpICYmICFlbmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gW3Jlc3VsdCwgc3BhY2VdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gW3Jlc3VsdCwgYmFzZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtyZXN1bHQsIG5ld2xpbmUsIGJhc2VdO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUlkZW50aWZpZXIobm9kZSkge1xuICAgICAgICByZXR1cm4gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChub2RlLm5hbWUsIG5vZGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQXN5bmNQcmVmaXgobm9kZSwgc3BhY2VSZXF1aXJlZCkge1xuICAgICAgICByZXR1cm4gbm9kZS5hc3luYyA/ICdhc3luYycgKyAoc3BhY2VSZXF1aXJlZCA/IG5vRW1wdHlTcGFjZSgpIDogc3BhY2UpIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVTdGFyU3VmZml4KG5vZGUpIHtcbiAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gbm9kZS5nZW5lcmF0b3IgJiYgIWV4dHJhLm1vei5zdGFybGVzc0dlbmVyYXRvcjtcbiAgICAgICAgcmV0dXJuIGlzR2VuZXJhdG9yID8gJyonICsgc3BhY2UgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZU1ldGhvZFByZWZpeChwcm9wKSB7XG4gICAgICAgIHZhciBmdW5jID0gcHJvcC52YWx1ZSwgcHJlZml4ID0gJyc7XG4gICAgICAgIGlmIChmdW5jLmFzeW5jKSB7XG4gICAgICAgICAgICBwcmVmaXggKz0gZ2VuZXJhdGVBc3luY1ByZWZpeChmdW5jLCAhcHJvcC5jb21wdXRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bmMuZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICAvLyBhdm9pZCBzcGFjZSBiZWZvcmUgbWV0aG9kIG5hbWVcbiAgICAgICAgICAgIHByZWZpeCArPSBnZW5lcmF0ZVN0YXJTdWZmaXgoZnVuYykgPyAnKicgOiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgIH1cblxuICAgIENvZGVHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlUGF0dGVybiA9IGZ1bmN0aW9uIChub2RlLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlSWRlbnRpZmllcihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24obm9kZSwgcHJlY2VkZW5jZSwgZmxhZ3MpO1xuICAgIH07XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZUZ1bmN0aW9uUGFyYW1zID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGksIGl6LCByZXN1bHQsIGhhc0RlZmF1bHQ7XG5cbiAgICAgICAgaGFzRGVmYXVsdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiAmJlxuICAgICAgICAgICAgICAgICFub2RlLnJlc3QgJiYgKCFub2RlLmRlZmF1bHRzIHx8IG5vZGUuZGVmYXVsdHMubGVuZ3RoID09PSAwKSAmJlxuICAgICAgICAgICAgICAgIG5vZGUucGFyYW1zLmxlbmd0aCA9PT0gMSAmJiBub2RlLnBhcmFtc1swXS50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgLy8gYXJnID0+IHsgfSBjYXNlXG4gICAgICAgICAgICByZXN1bHQgPSBbZ2VuZXJhdGVBc3luY1ByZWZpeChub2RlLCB0cnVlKSwgZ2VuZXJhdGVJZGVudGlmaWVyKG5vZGUucGFyYW1zWzBdKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBub2RlLnR5cGUgPT09IFN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA/IFtnZW5lcmF0ZUFzeW5jUHJlZml4KG5vZGUsIGZhbHNlKV0gOiBbXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcoJyk7XG4gICAgICAgICAgICBpZiAobm9kZS5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIGhhc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBub2RlLnBhcmFtcy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0RlZmF1bHQgJiYgbm9kZS5kZWZhdWx0c1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZGVmYXVsdCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVBc3NpZ25tZW50KG5vZGUucGFyYW1zW2ldLCBub2RlLmRlZmF1bHRzW2ldLCAnPScsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlUGF0dGVybihub2RlLnBhcmFtc1tpXSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZS5yZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucGFyYW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcuLi4nKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZUlkZW50aWZpZXIobm9kZS5yZXN0KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcpJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZUZ1bmN0aW9uQm9keSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciByZXN1bHQsIGV4cHI7XG5cbiAgICAgICAgcmVzdWx0ID0gdGhpcy5nZW5lcmF0ZUZ1bmN0aW9uUGFyYW1zKG5vZGUpO1xuXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJz0+Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5leHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSk7XG4gICAgICAgICAgICBleHByID0gdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24obm9kZS5ib2R5LCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKTtcbiAgICAgICAgICAgIGlmIChleHByLnRvU3RyaW5nKCkuY2hhckF0KDApID09PSAneycpIHtcbiAgICAgICAgICAgICAgICBleHByID0gWycoJywgZXhwciwgJyknXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGV4cHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5tYXliZUJsb2NrKG5vZGUuYm9keSwgU19UVEZGKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZUl0ZXJhdGlvbkZvclN0YXRlbWVudCA9IGZ1bmN0aW9uIChvcGVyYXRvciwgc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFsnZm9yJyArIChzdG10LmF3YWl0ID8gbm9FbXB0eVNwYWNlKCkgKyAnYXdhaXQnIDogJycpICsgc3BhY2UgKyAnKCddLCB0aGF0ID0gdGhpcztcbiAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc3RtdC5sZWZ0LnR5cGUgPT09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0bXQubGVmdC5raW5kICsgbm9FbXB0eVNwYWNlKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlU3RhdGVtZW50KHN0bXQubGVmdC5kZWNsYXJhdGlvbnNbMF0sIFNfRkZGRikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmxlZnQsIFByZWNlZGVuY2UuQ2FsbCwgRV9UVFQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIG9wZXJhdG9yKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtqb2luKFxuICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICB0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnJpZ2h0LCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKVxuICAgICAgICAgICAgKSwgJyknXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubWF5YmVCbG9jayhzdG10LmJvZHksIGZsYWdzKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIENvZGVHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlUHJvcGVydHlLZXkgPSBmdW5jdGlvbiAoZXhwciwgY29tcHV0ZWQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJ1snKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpKTtcblxuICAgICAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCddJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZUFzc2lnbm1lbnQgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIG9wZXJhdG9yLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICBpZiAoUHJlY2VkZW5jZS5Bc3NpZ25tZW50IDwgcHJlY2VkZW5jZSkge1xuICAgICAgICAgICAgZmxhZ3MgfD0gRl9BTExPV19JTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24obGVmdCwgUHJlY2VkZW5jZS5DYWxsLCBmbGFncyksXG4gICAgICAgICAgICAgICAgc3BhY2UgKyBvcGVyYXRvciArIHNwYWNlLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHJpZ2h0LCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIGZsYWdzKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFByZWNlZGVuY2UuQXNzaWdubWVudCxcbiAgICAgICAgICAgIHByZWNlZGVuY2VcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUuc2VtaWNvbG9uID0gZnVuY3Rpb24gKGZsYWdzKSB7XG4gICAgICAgIGlmICghc2VtaWNvbG9ucyAmJiBmbGFncyAmIEZfU0VNSUNPTE9OX09QVCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnOyc7XG4gICAgfTtcblxuICAgIC8vIFN0YXRlbWVudHMuXG5cbiAgICBDb2RlR2VuZXJhdG9yLlN0YXRlbWVudCA9IHtcblxuICAgICAgICBCbG9ja1N0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UsIGNvbnRlbnQsIHJlc3VsdCA9IFsneycsIG5ld2xpbmVdLCB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGZ1bmN0aW9ucyB3aXRob3V0IGFueSBjb2RlXG4gICAgICAgICAgICAgICAgaWYgKHN0bXQuYm9keS5sZW5ndGggPT09IDAgJiYgcHJlc2VydmVCbGFua0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gc3RtdC5yYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlWzFdIC0gcmFuZ2VbMF0gPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gc291cmNlQ29kZS5zdWJzdHJpbmcocmFuZ2VbMF0gKyAxLCByYW5nZVsxXSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbMF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gWyd7J107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBpLCBpeiwgZnJhZ21lbnQsIGJvZHlGbGFncztcbiAgICAgICAgICAgICAgICBib2R5RmxhZ3MgPSBTX1RGRkY7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzICYgRl9GVU5DX0JPRFkpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keUZsYWdzIHw9IEZfRElSRUNUSVZFX0NUWDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IHN0bXQuYm9keS5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVzZXJ2ZUJsYW5rTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzcGFjZXMgYmVmb3JlIHRoZSBmaXJzdCBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG10LmJvZHlbMF0ubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlID0gc3RtdC5ib2R5WzBdLmxlYWRpbmdDb21tZW50c1swXS5leHRlbmRlZFJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gc291cmNlQ29kZS5zdWJzdHJpbmcocmFuZ2VbMF0sIHJhbmdlWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbMF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbJ3snXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0bXQuYm9keVswXS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVCbGFua0xpbmVzKHN0bXQucmFuZ2VbMF0sIHN0bXQuYm9keVswXS5yYW5nZVswXSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzcGFjZXMgYmV0d2VlbiBsaW5lc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG10LmJvZHlbaSAtIDFdLnRyYWlsaW5nQ29tbWVudHMgICYmICFzdG10LmJvZHlbaV0ubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlQmxhbmtMaW5lcyhzdG10LmJvZHlbaSAtIDFdLnJhbmdlWzFdLCBzdG10LmJvZHlbaV0ucmFuZ2VbMF0sIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGl6IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUZsYWdzIHw9IEZfU0VNSUNPTE9OX09QVDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG10LmJvZHlbaV0ubGVhZGluZ0NvbW1lbnRzICYmIHByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGF0LmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuYm9keVtpXSwgYm9keUZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gYWRkSW5kZW50KHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5ib2R5W2ldLCBib2R5RmxhZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQoZnJhZ21lbnQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlc2VydmVCbGFua0xpbmVzICYmIGkgPCBpeiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBhZGQgYSBuZXcgbGluZSBpZiB0aGVyZSBhcmUgbGVhZGluZyBjb21lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIG5leHQgc3RhdGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG10LmJvZHlbaSArIDFdLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHNwYWNlcyBhZnRlciB0aGUgbGFzdCBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaXogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG10LmJvZHlbaV0udHJhaWxpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUJsYW5rTGluZXMoc3RtdC5ib2R5W2ldLnJhbmdlWzFdLCBzdG10LnJhbmdlWzFdLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXN1bHQucHVzaChhZGRJbmRlbnQoJ30nKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEJyZWFrU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmIChzdG10LmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdicmVhayAnICsgc3RtdC5sYWJlbC5uYW1lICsgdGhpcy5zZW1pY29sb24oZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdicmVhaycgKyB0aGlzLnNlbWljb2xvbihmbGFncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29udGludWVTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgaWYgKHN0bXQubGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2NvbnRpbnVlICcgKyBzdG10LmxhYmVsLm5hbWUgKyB0aGlzLnNlbWljb2xvbihmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ2NvbnRpbnVlJyArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBDbGFzc0JvZHk6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFsgJ3snLCBuZXdsaW5lXSwgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKGluZGVudCkge1xuICAgICAgICAgICAgICAgIHZhciBpLCBpejtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gc3RtdC5ib2R5Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5ib2R5W2ldLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYmFzZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnfScpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBDbGFzc0RlY2xhcmF0aW9uOiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGZyYWdtZW50O1xuICAgICAgICAgICAgcmVzdWx0ICA9IFsnY2xhc3MnXTtcbiAgICAgICAgICAgIGlmIChzdG10LmlkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuaWQsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RtdC5zdXBlckNsYXNzKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBqb2luKCdleHRlbmRzJywgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zdXBlckNsYXNzLCBQcmVjZWRlbmNlLlVuYXJ5LCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBmcmFnbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuYm9keSwgU19URkZUKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIERpcmVjdGl2ZVN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoZXh0cmEucmF3ICYmIHN0bXQucmF3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0bXQucmF3ICsgdGhpcy5zZW1pY29sb24oZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVzY2FwZURpcmVjdGl2ZShzdG10LmRpcmVjdGl2ZSkgKyB0aGlzLnNlbWljb2xvbihmbGFncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRG9XaGlsZVN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIGBkbyA0MiB3aGlsZSAoY29uZClgIGlzIFN5bnRheCBFcnJvci4gV2UgbmVlZCBzZW1pY29sb24uXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gam9pbignZG8nLCB0aGlzLm1heWJlQmxvY2soc3RtdC5ib2R5LCBTX1RGRkYpKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWF5YmVCbG9ja1N1ZmZpeChzdG10LmJvZHksIHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gam9pbihyZXN1bHQsIFtcbiAgICAgICAgICAgICAgICAnd2hpbGUnICsgc3BhY2UgKyAnKCcsXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC50ZXN0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCksXG4gICAgICAgICAgICAgICAgJyknICsgdGhpcy5zZW1pY29sb24oZmxhZ3MpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSxcblxuICAgICAgICBDYXRjaENsYXVzZTogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBndWFyZDtcblxuICAgICAgICAgICAgICAgIGlmIChzdG10LnBhcmFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYXRjaCcgKyBzcGFjZSArICcoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQucGFyYW0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICcpJ1xuICAgICAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG10Lmd1YXJkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBndWFyZCA9IHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuZ3VhcmQsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UoMiwgMCwgJyBpZiAnLCBndWFyZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbJ2NhdGNoJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLm1heWJlQmxvY2soc3RtdC5ib2R5LCBTX1RGRkYpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRGVidWdnZXJTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuICdkZWJ1Z2dlcicgKyB0aGlzLnNlbWljb2xvbihmbGFncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRW1wdHlTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuICc7JztcbiAgICAgICAgfSxcblxuICAgICAgICBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb246IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFsgJ2V4cG9ydCcgXSwgYm9keUZsYWdzO1xuXG4gICAgICAgICAgICBib2R5RmxhZ3MgPSAoZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQpID8gU19URkZUIDogU19URkZGO1xuXG4gICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBIb2lzdGFibGVEZWNsYXJhdGlvbltEZWZhdWx0XVxuICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgQXNzaWdubWVudEV4cHJlc3Npb25bSW5dIDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCAnZGVmYXVsdCcpO1xuICAgICAgICAgICAgaWYgKGlzU3RhdGVtZW50KHN0bXQuZGVjbGFyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5kZWNsYXJhdGlvbiwgYm9keUZsYWdzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmRlY2xhcmF0aW9uLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKSArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEV4cG9ydE5hbWVkRGVjbGFyYXRpb246IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFsgJ2V4cG9ydCcgXSwgYm9keUZsYWdzLCB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgYm9keUZsYWdzID0gKGZsYWdzICYgRl9TRU1JQ09MT05fT1BUKSA/IFNfVEZGVCA6IFNfVEZGRjtcblxuICAgICAgICAgICAgLy8gZXhwb3J0IFZhcmlhYmxlU3RhdGVtZW50XG4gICAgICAgICAgICAvLyBleHBvcnQgRGVjbGFyYXRpb25bRGVmYXVsdF1cbiAgICAgICAgICAgIGlmIChzdG10LmRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuZGVjbGFyYXRpb24sIGJvZHlGbGFncykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBleHBvcnQgRXhwb3J0Q2xhdXNlW05vUmVmZXJlbmNlXSBGcm9tQ2xhdXNlIDtcbiAgICAgICAgICAgIC8vIGV4cG9ydCBFeHBvcnRDbGF1c2UgO1xuICAgICAgICAgICAgaWYgKHN0bXQuc3BlY2lmaWVycykge1xuICAgICAgICAgICAgICAgIGlmIChzdG10LnNwZWNpZmllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCAneycgKyBzcGFjZSArICd9Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdG10LnNwZWNpZmllcnNbMF0udHlwZSA9PT0gU3ludGF4LkV4cG9ydEJhdGNoU3BlY2lmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNwZWNpZmllcnNbMF0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsICd7Jyk7XG4gICAgICAgICAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKGluZGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGl6O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IHN0bXQuc3BlY2lmaWVycy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNwZWNpZmllcnNbaV0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgbmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmFzZSArICd9Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0bXQuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnJvbScgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vZHVsZVNwZWNpZmllclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zb3VyY2UsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VtaWNvbG9uKGZsYWdzKVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnNlbWljb2xvbihmbGFncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXhwb3J0QWxsRGVjbGFyYXRpb246IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgLy8gZXhwb3J0ICogRnJvbUNsYXVzZSA7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICdleHBvcnQnICsgc3BhY2UsXG4gICAgICAgICAgICAgICAgJyonICsgc3BhY2UsXG4gICAgICAgICAgICAgICAgJ2Zyb20nICsgc3BhY2UsXG4gICAgICAgICAgICAgICAgLy8gTW9kdWxlU3BlY2lmaWVyXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zb3VyY2UsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICB0aGlzLnNlbWljb2xvbihmbGFncylcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXhwcmVzc2lvblN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBmcmFnbWVudDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gaXNDbGFzc1ByZWZpeGVkKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGU7XG4gICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50LnNsaWNlKDAsIDUpICE9PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29kZSA9IGZyYWdtZW50LmNoYXJDb2RlQXQoNSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGUgPT09IDB4N0IgIC8qICd7JyAqLyB8fCBlc3V0aWxzLmNvZGUuaXNXaGl0ZVNwYWNlKGNvZGUpIHx8IGVzdXRpbHMuY29kZS5pc0xpbmVUZXJtaW5hdG9yKGNvZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uUHJlZml4ZWQoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuc2xpY2UoMCwgOCkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2RlID0gZnJhZ21lbnQuY2hhckNvZGVBdCg4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZSA9PT0gMHgyOCAvKiAnKCcgKi8gfHwgZXN1dGlscy5jb2RlLmlzV2hpdGVTcGFjZShjb2RlKSB8fCBjb2RlID09PSAweDJBICAvKiAnKicgKi8gfHwgZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3IoY29kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzQXN5bmNQcmVmaXhlZChmcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlLCBpLCBpejtcbiAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuc2xpY2UoMCwgNSkgIT09ICdhc3luYycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2UoZnJhZ21lbnQuY2hhckNvZGVBdCg1KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSA2LCBpeiA9IGZyYWdtZW50Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlc3V0aWxzLmNvZGUuaXNXaGl0ZVNwYWNlKGZyYWdtZW50LmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaXopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuc2xpY2UoaSwgaSArIDgpICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29kZSA9IGZyYWdtZW50LmNoYXJDb2RlQXQoaSArIDgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlID09PSAweDI4IC8qICcoJyAqLyB8fCBlc3V0aWxzLmNvZGUuaXNXaGl0ZVNwYWNlKGNvZGUpIHx8IGNvZGUgPT09IDB4MkEgIC8qICcqJyAqLyB8fCBlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihjb2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gW3RoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuZXhwcmVzc2lvbiwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpXTtcbiAgICAgICAgICAgIC8vIDEyLjQgJ3snLCAnZnVuY3Rpb24nLCAnY2xhc3MnIGlzIG5vdCBhbGxvd2VkIGluIHRoaXMgcG9zaXRpb24uXG4gICAgICAgICAgICAvLyB3cmFwIGV4cHJlc3Npb24gd2l0aCBwYXJlbnRoZXNlc1xuICAgICAgICAgICAgZnJhZ21lbnQgPSB0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudC5jaGFyQ29kZUF0KDApID09PSAweDdCICAvKiAneycgKi8gfHwgIC8vIE9iamVjdEV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgaXNDbGFzc1ByZWZpeGVkKGZyYWdtZW50KSB8fFxuICAgICAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uUHJlZml4ZWQoZnJhZ21lbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzQXN5bmNQcmVmaXhlZChmcmFnbWVudCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGRpcmVjdGl2ZSAmJiAoZmxhZ3MgJiBGX0RJUkVDVElWRV9DVFgpICYmIHN0bXQuZXhwcmVzc2lvbi50eXBlID09PSBTeW50YXguTGl0ZXJhbCAmJiB0eXBlb2Ygc3RtdC5leHByZXNzaW9uLnZhbHVlID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbJygnLCByZXN1bHQsICcpJyArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuc2VtaWNvbG9uKGZsYWdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEltcG9ydERlY2xhcmF0aW9uOiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIC8vIEVTNjogMTUuMi4xIHZhbGlkIGltcG9ydCBkZWNsYXJhdGlvbnM6XG4gICAgICAgICAgICAvLyAgICAgLSBpbXBvcnQgSW1wb3J0Q2xhdXNlIEZyb21DbGF1c2UgO1xuICAgICAgICAgICAgLy8gICAgIC0gaW1wb3J0IE1vZHVsZVNwZWNpZmllciA7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBjdXJzb3IsIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBJZiBubyBJbXBvcnRDbGF1c2UgaXMgcHJlc2VudCxcbiAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIGJlIGBpbXBvcnQgTW9kdWxlU3BlY2lmaWVyYCBzbyBza2lwIGBmcm9tYFxuICAgICAgICAgICAgLy8gTW9kdWxlU3BlY2lmaWVyIGlzIFN0cmluZ0xpdGVyYWwuXG4gICAgICAgICAgICBpZiAoc3RtdC5zcGVjaWZpZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGltcG9ydCBNb2R1bGVTcGVjaWZpZXIgO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICdpbXBvcnQnLFxuICAgICAgICAgICAgICAgICAgICBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gTW9kdWxlU3BlY2lmaWVyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuc291cmNlLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VtaWNvbG9uKGZsYWdzKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGltcG9ydCBJbXBvcnRDbGF1c2UgRnJvbUNsYXVzZSA7XG4gICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgJ2ltcG9ydCdcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjdXJzb3IgPSAwO1xuXG4gICAgICAgICAgICAvLyBJbXBvcnRlZEJpbmRpbmdcbiAgICAgICAgICAgIGlmIChzdG10LnNwZWNpZmllcnNbY3Vyc29yXS50eXBlID09PSBTeW50YXguSW1wb3J0RGVmYXVsdFNwZWNpZmllcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNwZWNpZmllcnNbY3Vyc29yXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgKytjdXJzb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdG10LnNwZWNpZmllcnNbY3Vyc29yXSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RtdC5zcGVjaWZpZXJzW2N1cnNvcl0udHlwZSA9PT0gU3ludGF4LkltcG9ydE5hbWVzcGFjZVNwZWNpZmllcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBOYW1lU3BhY2VJbXBvcnRcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNwZWNpZmllcnNbY3Vyc29yXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5hbWVkSW1wb3J0c1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSArICd7Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKChzdG10LnNwZWNpZmllcnMubGVuZ3RoIC0gY3Vyc29yKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1wb3J0IHsgLi4uIH0gZnJvbSBcIi4uLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zcGVjaWZpZXJzW2N1cnNvcl0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSArICd9JyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltcG9ydCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAuLi4sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAuLi4sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9IGZyb20gXCIuLi5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKGluZGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpLCBpejtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBjdXJzb3IsIGl6ID0gc3RtdC5zcGVjaWZpZXJzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zcGVjaWZpZXJzW2ldLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgbmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJhc2UgKyAnfScgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBbXG4gICAgICAgICAgICAgICAgJ2Zyb20nICsgc3BhY2UsXG4gICAgICAgICAgICAgICAgLy8gTW9kdWxlU3BlY2lmaWVyXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zb3VyY2UsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICB0aGlzLnNlbWljb2xvbihmbGFncylcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0b3I6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIGl0ZW1GbGFncyA9IChmbGFncyAmIEZfQUxMT1dfSU4pID8gRV9UVFQgOiBFX0ZUVDtcbiAgICAgICAgICAgIGlmIChzdG10LmluaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmlkLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIGl0ZW1GbGFncyksXG4gICAgICAgICAgICAgICAgICAgIHNwYWNlLFxuICAgICAgICAgICAgICAgICAgICAnPScsXG4gICAgICAgICAgICAgICAgICAgIHNwYWNlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmluaXQsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgaXRlbUZsYWdzKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVBhdHRlcm4oc3RtdC5pZCwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBpdGVtRmxhZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRpb246IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgLy8gVmFyaWFibGVEZWNsYXJhdG9yIGlzIHR5cGVkIGFzIFN0YXRlbWVudCxcbiAgICAgICAgICAgIC8vIGJ1dCBqb2luZWQgd2l0aCBjb21tYSAobm90IExpbmVUZXJtaW5hdG9yKS5cbiAgICAgICAgICAgIC8vIFNvIGlmIGNvbW1lbnQgaXMgYXR0YWNoZWQgdG8gdGFyZ2V0IG5vZGUsIHdlIHNob3VsZCBzcGVjaWFsaXplLlxuICAgICAgICAgICAgdmFyIHJlc3VsdCwgaSwgaXosIG5vZGUsIGJvZHlGbGFncywgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IFsgc3RtdC5raW5kIF07XG5cbiAgICAgICAgICAgIGJvZHlGbGFncyA9IChmbGFncyAmIEZfQUxMT1dfSU4pID8gU19URkZGIDogU19GRkZGO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBibG9jaygpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gc3RtdC5kZWNsYXJhdGlvbnNbMF07XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnQgJiYgbm9kZS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhZGRJbmRlbnQodGhhdC5nZW5lcmF0ZVN0YXRlbWVudChub2RlLCBib2R5RmxhZ3MpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9FbXB0eVNwYWNlKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlU3RhdGVtZW50KG5vZGUsIGJvZHlGbGFncykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGl6ID0gc3RtdC5kZWNsYXJhdGlvbnMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gc3RtdC5kZWNsYXJhdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYS5jb21tZW50ICYmIG5vZGUubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudCh0aGF0LmdlbmVyYXRlU3RhdGVtZW50KG5vZGUsIGJvZHlGbGFncykpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQobm9kZSwgYm9keUZsYWdzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdG10LmRlY2xhcmF0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgd2l0aEluZGVudChibG9jayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJsb2NrKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuc2VtaWNvbG9uKGZsYWdzKSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIFtqb2luKFxuICAgICAgICAgICAgICAgICd0aHJvdycsXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5hcmd1bWVudCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpXG4gICAgICAgICAgICApLCB0aGlzLnNlbWljb2xvbihmbGFncyldO1xuICAgICAgICB9LFxuXG4gICAgICAgIFRyeVN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBpLCBpeiwgZ3VhcmRlZEhhbmRsZXJzO1xuXG4gICAgICAgICAgICByZXN1bHQgPSBbJ3RyeScsIHRoaXMubWF5YmVCbG9jayhzdG10LmJsb2NrLCBTX1RGRkYpXTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWF5YmVCbG9ja1N1ZmZpeChzdG10LmJsb2NrLCByZXN1bHQpO1xuXG4gICAgICAgICAgICBpZiAoc3RtdC5oYW5kbGVycykge1xuICAgICAgICAgICAgICAgIC8vIG9sZCBpbnRlcmZhY2VcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IHN0bXQuaGFuZGxlcnMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgdGhpcy5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmhhbmRsZXJzW2ldLCBTX1RGRkYpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuZmluYWxpemVyIHx8IGkgKyAxICE9PSBpeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYXliZUJsb2NrU3VmZml4KHN0bXQuaGFuZGxlcnNbaV0uYm9keSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3VhcmRlZEhhbmRsZXJzID0gc3RtdC5ndWFyZGVkSGFuZGxlcnMgfHwgW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGd1YXJkZWRIYW5kbGVycy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KGd1YXJkZWRIYW5kbGVyc1tpXSwgU19URkZGKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG10LmZpbmFsaXplciB8fCBpICsgMSAhPT0gaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWF5YmVCbG9ja1N1ZmZpeChndWFyZGVkSGFuZGxlcnNbaV0uYm9keSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG5ldyBpbnRlcmZhY2VcbiAgICAgICAgICAgICAgICBpZiAoc3RtdC5oYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0bXQuaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gc3RtdC5oYW5kbGVyLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgdGhpcy5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmhhbmRsZXJbaV0sIFNfVEZGRikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG10LmZpbmFsaXplciB8fCBpICsgMSAhPT0gaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYXliZUJsb2NrU3VmZml4KHN0bXQuaGFuZGxlcltpXS5ib2R5LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuaGFuZGxlciwgU19URkZGKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RtdC5maW5hbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1heWJlQmxvY2tTdWZmaXgoc3RtdC5oYW5kbGVyLmJvZHksIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RtdC5maW5hbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgWydmaW5hbGx5JywgdGhpcy5tYXliZUJsb2NrKHN0bXQuZmluYWxpemVyLCBTX1RGRkYpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIFN3aXRjaFN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBmcmFnbWVudCwgaSwgaXosIGJvZHlGbGFncywgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgICdzd2l0Y2gnICsgc3BhY2UgKyAnKCcsXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuZGlzY3JpbWluYW50LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCksXG4gICAgICAgICAgICAgICAgICAgICcpJyArIHNwYWNlICsgJ3snICsgbmV3bGluZVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzdG10LmNhc2VzKSB7XG4gICAgICAgICAgICAgICAgYm9keUZsYWdzID0gU19URkZGO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gc3RtdC5jYXNlcy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBpeiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlGbGFncyB8PSBGX1NFTUlDT0xPTl9PUFQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBhZGRJbmRlbnQodGhpcy5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmNhc2VzW2ldLCBib2R5RmxhZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChmcmFnbWVudCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYWRkSW5kZW50KCd9JykpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBTd2l0Y2hDYXNlOiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGZyYWdtZW50LCBpLCBpeiwgYm9keUZsYWdzLCB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChzdG10LnRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgam9pbignY2FzZScsIHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQudGVzdCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICc6J1xuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsnZGVmYXVsdDonXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBpeiA9IHN0bXQuY29uc2VxdWVudC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGl6ICYmIHN0bXQuY29uc2VxdWVudFswXS50eXBlID09PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGF0Lm1heWJlQmxvY2soc3RtdC5jb25zZXF1ZW50WzBdLCBTX1RGRkYpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGkgPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpICE9PSBpeiAmJiAhZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYm9keUZsYWdzID0gU19URkZGO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaXogLSAxICYmIGZsYWdzICYgRl9TRU1JQ09MT05fT1BUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5RmxhZ3MgfD0gRl9TRU1JQ09MT05fT1BUO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gYWRkSW5kZW50KHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5jb25zZXF1ZW50W2ldLCBib2R5RmxhZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSArIDEgIT09IGl6ICYmICFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQoZnJhZ21lbnQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBJZlN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBib2R5RmxhZ3MsIHNlbWljb2xvbk9wdGlvbmFsLCB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ2lmJyArIHNwYWNlICsgJygnLFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnRlc3QsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VtaWNvbG9uT3B0aW9uYWwgPSBmbGFncyAmIEZfU0VNSUNPTE9OX09QVDtcbiAgICAgICAgICAgIGJvZHlGbGFncyA9IFNfVEZGRjtcbiAgICAgICAgICAgIGlmIChzZW1pY29sb25PcHRpb25hbCkge1xuICAgICAgICAgICAgICAgIGJvZHlGbGFncyB8PSBGX1NFTUlDT0xPTl9PUFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RtdC5hbHRlcm5hdGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLm1heWJlQmxvY2soc3RtdC5jb25zZXF1ZW50LCBTX1RGRkYpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1heWJlQmxvY2tTdWZmaXgoc3RtdC5jb25zZXF1ZW50LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChzdG10LmFsdGVybmF0ZS50eXBlID09PSBTeW50YXguSWZTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIFsnZWxzZSAnLCB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuYWx0ZXJuYXRlLCBib2R5RmxhZ3MpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGpvaW4oJ2Vsc2UnLCB0aGlzLm1heWJlQmxvY2soc3RtdC5hbHRlcm5hdGUsIGJvZHlGbGFncykpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubWF5YmVCbG9jayhzdG10LmNvbnNlcXVlbnQsIGJvZHlGbGFncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBGb3JTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbJ2ZvcicgKyBzcGFjZSArICcoJ107XG4gICAgICAgICAgICAgICAgaWYgKHN0bXQuaW5pdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RtdC5pbml0LnR5cGUgPT09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuaW5pdCwgU19GRkZGKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGX0FMTE9XX0lOIGJlY29tZXMgZmFsc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmluaXQsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfRlRUKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnOycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJzsnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RtdC50ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC50ZXN0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnOycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCc7Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0bXQudXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC51cGRhdGUsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcpJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJyknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5tYXliZUJsb2NrKHN0bXQuYm9keSwgZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQgPyBTX1RGRlQgOiBTX1RGRkYpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRm9ySW5TdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVJdGVyYXRpb25Gb3JTdGF0ZW1lbnQoJ2luJywgc3RtdCwgZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQgPyBTX1RGRlQgOiBTX1RGRkYpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEZvck9mU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlSXRlcmF0aW9uRm9yU3RhdGVtZW50KCdvZicsIHN0bXQsIGZsYWdzICYgRl9TRU1JQ09MT05fT1BUID8gU19URkZUIDogU19URkZGKTtcbiAgICAgICAgfSxcblxuICAgICAgICBMYWJlbGVkU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBbc3RtdC5sYWJlbC5uYW1lICsgJzonLCB0aGlzLm1heWJlQmxvY2soc3RtdC5ib2R5LCBmbGFncyAmIEZfU0VNSUNPTE9OX09QVCA/IFNfVEZGVCA6IFNfVEZGRildO1xuICAgICAgICB9LFxuXG4gICAgICAgIFByb2dyYW06IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZnJhZ21lbnQsIGksIGl6LCBib2R5RmxhZ3M7XG4gICAgICAgICAgICBpeiA9IHN0bXQuYm9keS5sZW5ndGg7XG4gICAgICAgICAgICByZXN1bHQgPSBbc2FmZUNvbmNhdGVuYXRpb24gJiYgaXogPiAwID8gJ1xcbicgOiAnJ107XG4gICAgICAgICAgICBib2R5RmxhZ3MgPSBTX1RGVEY7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICghc2FmZUNvbmNhdGVuYXRpb24gJiYgaSA9PT0gaXogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlGbGFncyB8PSBGX1NFTUlDT0xPTl9PUFQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgc3BhY2VzIGJlZm9yZSB0aGUgZmlyc3QgbGluZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG10LmJvZHlbMF0ubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVCbGFua0xpbmVzKHN0bXQucmFuZ2VbMF0sIHN0bXQuYm9keVtpXS5yYW5nZVswXSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzcGFjZXMgYmV0d2VlbiBsaW5lc1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RtdC5ib2R5W2kgLSAxXS50cmFpbGluZ0NvbW1lbnRzICYmICFzdG10LmJvZHlbaV0ubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVCbGFua0xpbmVzKHN0bXQuYm9keVtpIC0gMV0ucmFuZ2VbMV0sIHN0bXQuYm9keVtpXS5yYW5nZVswXSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gYWRkSW5kZW50KHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5ib2R5W2ldLCBib2R5RmxhZ3MpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXogJiYgIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChmcmFnbWVudCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG10LmJvZHlbaSArIDFdLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocHJlc2VydmVCbGFua0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzcGFjZXMgYWZ0ZXIgdGhlIGxhc3QgbGluZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaXogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0bXQuYm9keVtpXS50cmFpbGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVCbGFua0xpbmVzKHN0bXQuYm9keVtpXS5yYW5nZVsxXSwgc3RtdC5yYW5nZVsxXSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlQXN5bmNQcmVmaXgoc3RtdCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZVN0YXJTdWZmaXgoc3RtdCkgfHwgbm9FbXB0eVNwYWNlKCksXG4gICAgICAgICAgICAgICAgc3RtdC5pZCA/IGdlbmVyYXRlSWRlbnRpZmllcihzdG10LmlkKSA6ICcnLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVGdW5jdGlvbkJvZHkoc3RtdClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmIChzdG10LmFyZ3VtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtqb2luKFxuICAgICAgICAgICAgICAgICAgICAncmV0dXJuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5hcmd1bWVudCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpXG4gICAgICAgICAgICAgICAgKSwgdGhpcy5zZW1pY29sb24oZmxhZ3MpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbJ3JldHVybicgKyB0aGlzLnNlbWljb2xvbihmbGFncyldO1xuICAgICAgICB9LFxuXG4gICAgICAgIFdoaWxlU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICAnd2hpbGUnICsgc3BhY2UgKyAnKCcsXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQudGVzdCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpLFxuICAgICAgICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLm1heWJlQmxvY2soc3RtdC5ib2R5LCBmbGFncyAmIEZfU0VNSUNPTE9OX09QVCA/IFNfVEZGVCA6IFNfVEZGRikpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBXaXRoU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICAnd2l0aCcgKyBzcGFjZSArICcoJyxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5vYmplY3QsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5tYXliZUJsb2NrKHN0bXQuYm9keSwgZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQgPyBTX1RGRlQgOiBTX1RGRkYpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBtZXJnZShDb2RlR2VuZXJhdG9yLnByb3RvdHlwZSwgQ29kZUdlbmVyYXRvci5TdGF0ZW1lbnQpO1xuXG4gICAgLy8gRXhwcmVzc2lvbnMuXG5cbiAgICBDb2RlR2VuZXJhdG9yLkV4cHJlc3Npb24gPSB7XG5cbiAgICAgICAgU2VxdWVuY2VFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGksIGl6O1xuICAgICAgICAgICAgaWYgKFByZWNlZGVuY2UuU2VxdWVuY2UgPCBwcmVjZWRlbmNlKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgfD0gRl9BTExPV19JTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBleHByLmV4cHJlc3Npb25zLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmV4cHJlc3Npb25zW2ldLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIGZsYWdzKSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUFzc2lnbm1lbnQoZXhwci5sZWZ0LCBleHByLnJpZ2h0LCBleHByLm9wZXJhdG9yLCBwcmVjZWRlbmNlLCBmbGFncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZSh0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIpLCBQcmVjZWRlbmNlLkFycm93RnVuY3Rpb24sIHByZWNlZGVuY2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoUHJlY2VkZW5jZS5Db25kaXRpb25hbCA8IHByZWNlZGVuY2UpIHtcbiAgICAgICAgICAgICAgICBmbGFncyB8PSBGX0FMTE9XX0lOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIudGVzdCwgUHJlY2VkZW5jZS5Db2FsZXNjZSwgZmxhZ3MpLFxuICAgICAgICAgICAgICAgICAgICBzcGFjZSArICc/JyArIHNwYWNlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmNvbnNlcXVlbnQsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgZmxhZ3MpLFxuICAgICAgICAgICAgICAgICAgICBzcGFjZSArICc6JyArIHNwYWNlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmFsdGVybmF0ZSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBmbGFncylcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFByZWNlZGVuY2UuQ29uZGl0aW9uYWwsXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBMb2dpY2FsRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoZXhwci5vcGVyYXRvciA9PT0gJz8/Jykge1xuICAgICAgICAgICAgICAgIGZsYWdzIHw9IEZfRk9VTkRfQ09BTEVTQ0U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5CaW5hcnlFeHByZXNzaW9uKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBCaW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGxlZnRQcmVjZWRlbmNlLCByaWdodFByZWNlZGVuY2UsIGN1cnJlbnRQcmVjZWRlbmNlLCBmcmFnbWVudCwgbGVmdFNvdXJjZTtcbiAgICAgICAgICAgIGN1cnJlbnRQcmVjZWRlbmNlID0gQmluYXJ5UHJlY2VkZW5jZVtleHByLm9wZXJhdG9yXTtcbiAgICAgICAgICAgIGxlZnRQcmVjZWRlbmNlID0gZXhwci5vcGVyYXRvciA9PT0gJyoqJyA/IFByZWNlZGVuY2UuUG9zdGZpeCA6IGN1cnJlbnRQcmVjZWRlbmNlO1xuICAgICAgICAgICAgcmlnaHRQcmVjZWRlbmNlID0gZXhwci5vcGVyYXRvciA9PT0gJyoqJyA/IGN1cnJlbnRQcmVjZWRlbmNlIDogY3VycmVudFByZWNlZGVuY2UgKyAxO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFByZWNlZGVuY2UgPCBwcmVjZWRlbmNlKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgfD0gRl9BTExPV19JTjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmxlZnQsIGxlZnRQcmVjZWRlbmNlLCBmbGFncyk7XG5cbiAgICAgICAgICAgIGxlZnRTb3VyY2UgPSBmcmFnbWVudC50b1N0cmluZygpO1xuXG4gICAgICAgICAgICBpZiAobGVmdFNvdXJjZS5jaGFyQ29kZUF0KGxlZnRTb3VyY2UubGVuZ3RoIC0gMSkgPT09IDB4MkYgLyogLyAqLyAmJiBlc3V0aWxzLmNvZGUuaXNJZGVudGlmaWVyUGFydEVTNShleHByLm9wZXJhdG9yLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW2ZyYWdtZW50LCBub0VtcHR5U3BhY2UoKSwgZXhwci5vcGVyYXRvcl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4oZnJhZ21lbnQsIGV4cHIub3BlcmF0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucmlnaHQsIHJpZ2h0UHJlY2VkZW5jZSwgZmxhZ3MpO1xuXG4gICAgICAgICAgICBpZiAoZXhwci5vcGVyYXRvciA9PT0gJy8nICYmIGZyYWdtZW50LnRvU3RyaW5nKCkuY2hhckF0KDApID09PSAnLycgfHxcbiAgICAgICAgICAgIGV4cHIub3BlcmF0b3Iuc2xpY2UoLTEpID09PSAnPCcgJiYgZnJhZ21lbnQudG9TdHJpbmcoKS5zbGljZSgwLCAzKSA9PT0gJyEtLScpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiAnLycgY29uY2F0cyB3aXRoICcvJyBvciBgPGAgY29uY2F0cyB3aXRoIGAhLS1gLCBpdCBpcyBpbnRlcnByZXRlZCBhcyBjb21tZW50IHN0YXJ0XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9FbXB0eVNwYWNlKCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIub3BlcmF0b3IgPT09ICdpbicgJiYgIShmbGFncyAmIEZfQUxMT1dfSU4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnKCcsIHJlc3VsdCwgJyknXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZXhwci5vcGVyYXRvciA9PT0gJ3x8JyB8fCBleHByLm9wZXJhdG9yID09PSAnJiYnKSAmJiAoZmxhZ3MgJiBGX0ZPVU5EX0NPQUxFU0NFKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJygnLCByZXN1bHQsICcpJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKHJlc3VsdCwgY3VycmVudFByZWNlZGVuY2UsIHByZWNlZGVuY2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIENhbGxFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGksIGl6O1xuXG4gICAgICAgICAgICAvLyBGX0FMTE9XX1VOUEFSQVRIX05FVyBiZWNvbWVzIGZhbHNlLlxuICAgICAgICAgICAgcmVzdWx0ID0gW3RoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuY2FsbGVlLCBQcmVjZWRlbmNlLkNhbGwsIEVfVFRGKV07XG5cbiAgICAgICAgICAgIGlmIChleHByLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJz8uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcoJyk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGV4cHJbJ2FyZ3VtZW50cyddLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByWydhcmd1bWVudHMnXVtpXSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnKScpO1xuXG4gICAgICAgICAgICBpZiAoIShmbGFncyAmIEZfQUxMT1dfQ0FMTCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWycoJywgcmVzdWx0LCAnKSddO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5DYWxsLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBDaGFpbkV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgaWYgKFByZWNlZGVuY2UuT3B0aW9uYWxDaGFpbmluZyA8IHByZWNlZGVuY2UpIHtcbiAgICAgICAgICAgICAgICBmbGFncyB8PSBGX0FMTE9XX0NBTEw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmV4cHJlc3Npb24sIFByZWNlZGVuY2UuT3B0aW9uYWxDaGFpbmluZywgZmxhZ3MpO1xuXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5PcHRpb25hbENoYWluaW5nLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBOZXdFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGxlbmd0aCwgaSwgaXosIGl0ZW1GbGFncztcbiAgICAgICAgICAgIGxlbmd0aCA9IGV4cHJbJ2FyZ3VtZW50cyddLmxlbmd0aDtcblxuICAgICAgICAgICAgLy8gRl9BTExPV19DQUxMIGJlY29tZXMgZmFsc2UuXG4gICAgICAgICAgICAvLyBGX0FMTE9XX1VOUEFSQVRIX05FVyBtYXkgYmVjb21lIGZhbHNlLlxuICAgICAgICAgICAgaXRlbUZsYWdzID0gKGZsYWdzICYgRl9BTExPV19VTlBBUkFUSF9ORVcgJiYgIXBhcmVudGhlc2VzICYmIGxlbmd0aCA9PT0gMCkgPyBFX1RGVCA6IEVfVEZGO1xuXG4gICAgICAgICAgICByZXN1bHQgPSBqb2luKFxuICAgICAgICAgICAgICAgICduZXcnLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuY2FsbGVlLCBQcmVjZWRlbmNlLk5ldywgaXRlbUZsYWdzKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKCEoZmxhZ3MgJiBGX0FMTE9XX1VOUEFSQVRIX05FVykgfHwgcGFyZW50aGVzZXMgfHwgbGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcoJyk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBsZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHJbJ2FyZ3VtZW50cyddW2ldLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJyknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShyZXN1bHQsIFByZWNlZGVuY2UuTmV3LCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBNZW1iZXJFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGZyYWdtZW50O1xuXG4gICAgICAgICAgICAvLyBGX0FMTE9XX1VOUEFSQVRIX05FVyBiZWNvbWVzIGZhbHNlLlxuICAgICAgICAgICAgcmVzdWx0ID0gW3RoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIub2JqZWN0LCBQcmVjZWRlbmNlLkNhbGwsIChmbGFncyAmIEZfQUxMT1dfQ0FMTCkgPyBFX1RURiA6IEVfVEZGKV07XG5cbiAgICAgICAgICAgIGlmIChleHByLmNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIub3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJz8uJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ1snKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLnByb3BlcnR5LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBmbGFncyAmIEZfQUxMT1dfQ0FMTCA/IEVfVFRUIDogRV9URlQpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnXScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWV4cHIub3B0aW9uYWwgJiYgZXhwci5vYmplY3QudHlwZSA9PT0gU3ludGF4LkxpdGVyYWwgJiYgdHlwZW9mIGV4cHIub2JqZWN0LnZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgYWxsIHRydWUsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgMS4gTm8gZmxvYXRpbmcgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gICAyLiBEb24ndCBoYXZlIGV4cG9uZW50c1xuICAgICAgICAgICAgICAgICAgICAvLyAgIDMuIFRoZSBsYXN0IGNoYXJhY3RlciBpcyBhIGRlY2ltYWwgZGlnaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gICA0LiBOb3QgaGV4YWRlY2ltYWwgT1Igb2N0YWwgbnVtYmVyIGxpdGVyYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIGFkZCBhIGZsb2F0aW5nIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQuaW5kZXhPZignLicpIDwgMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEvW2VFeFhdLy50ZXN0KGZyYWdtZW50KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzdXRpbHMuY29kZS5pc0RlY2ltYWxEaWdpdChmcmFnbWVudC5jaGFyQ29kZUF0KGZyYWdtZW50Lmxlbmd0aCAtIDEpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEoZnJhZ21lbnQubGVuZ3RoID49IDIgJiYgZnJhZ21lbnQuY2hhckNvZGVBdCgwKSA9PT0gNDgpICAvLyAnMCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcgJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZXhwci5vcHRpb25hbCA/ICc/LicgOiAnLicpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlSWRlbnRpZmllcihleHByLnByb3BlcnR5KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLk1lbWJlciwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTWV0YVByb3BlcnR5OiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHR5cGVvZiBleHByLm1ldGEgPT09IFwic3RyaW5nXCIgPyBleHByLm1ldGEgOiBnZW5lcmF0ZUlkZW50aWZpZXIoZXhwci5tZXRhKSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnLicpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godHlwZW9mIGV4cHIucHJvcGVydHkgPT09IFwic3RyaW5nXCIgPyBleHByLnByb3BlcnR5IDogZ2VuZXJhdGVJZGVudGlmaWVyKGV4cHIucHJvcGVydHkpKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLk1lbWJlciwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGZyYWdtZW50LCByaWdodENoYXJDb2RlLCBsZWZ0U291cmNlLCBsZWZ0Q2hhckNvZGU7XG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnQsIFByZWNlZGVuY2UuVW5hcnksIEVfVFRUKTtcblxuICAgICAgICAgICAgaWYgKHNwYWNlID09PSAnJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4oZXhwci5vcGVyYXRvciwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbZXhwci5vcGVyYXRvcl07XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIub3BlcmF0b3IubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUsIHZvaWQsIHR5cGVvZlxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgYHR5cGVvZiBbXWAsIG5vdCBgdHlwZW9mW11gXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBpbnNlcnRpbmcgc3BhY2VzIGJldHdlZW4gb3BlcmF0b3IgYW5kIGFyZ3VtZW50IGlmIGl0IGlzIHVubmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgIC8vIGxpa2UsIGAhY29uZGBcbiAgICAgICAgICAgICAgICAgICAgbGVmdFNvdXJjZSA9IHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0Q2hhckNvZGUgPSBsZWZ0U291cmNlLmNoYXJDb2RlQXQobGVmdFNvdXJjZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRDaGFyQ29kZSA9IGZyYWdtZW50LnRvU3RyaW5nKCkuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoKChsZWZ0Q2hhckNvZGUgPT09IDB4MkIgIC8qICsgKi8gfHwgbGVmdENoYXJDb2RlID09PSAweDJEICAvKiAtICovKSAmJiBsZWZ0Q2hhckNvZGUgPT09IHJpZ2h0Q2hhckNvZGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVzdXRpbHMuY29kZS5pc0lkZW50aWZpZXJQYXJ0RVM1KGxlZnRDaGFyQ29kZSkgJiYgZXN1dGlscy5jb2RlLmlzSWRlbnRpZmllclBhcnRFUzUocmlnaHRDaGFyQ29kZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub0VtcHR5U3BhY2UoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5VbmFyeSwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgWWllbGRFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoZXhwci5kZWxlZ2F0ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICd5aWVsZConO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAneWllbGQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cHIuYXJndW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnQsIFByZWNlZGVuY2UuWWllbGQsIEVfVFRUKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5ZaWVsZCwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQXdhaXRFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBqb2luKFxuICAgICAgICAgICAgICAgIGV4cHIuYWxsID8gJ2F3YWl0KicgOiAnYXdhaXQnLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnQsIFByZWNlZGVuY2UuQXdhaXQsIEVfVFRUKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLkF3YWl0LCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBVcGRhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmIChleHByLnByZWZpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUoXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmFyZ3VtZW50LCBQcmVjZWRlbmNlLlVuYXJ5LCBFX1RUVClcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgUHJlY2VkZW5jZS5VbmFyeSxcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudCwgUHJlY2VkZW5jZS5Qb3N0Zml4LCBFX1RUVCksXG4gICAgICAgICAgICAgICAgICAgIGV4cHIub3BlcmF0b3JcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFByZWNlZGVuY2UuUG9zdGZpeCxcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlQXN5bmNQcmVmaXgoZXhwciwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmIChleHByLmlkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVTdGFyU3VmZml4KGV4cHIpIHx8IG5vRW1wdHlTcGFjZSgpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZUlkZW50aWZpZXIoZXhwci5pZCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZVN0YXJTdWZmaXgoZXhwcikgfHwgc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUZ1bmN0aW9uQm9keShleHByKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEFycmF5UGF0dGVybjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5BcnJheUV4cHJlc3Npb24oZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MsIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEFycmF5RXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzLCBpc1BhdHRlcm4pIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIG11bHRpbGluZSwgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIWV4cHIuZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbXSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtdWx0aWxpbmUgPSBpc1BhdHRlcm4gPyBmYWxzZSA6IGV4cHIuZWxlbWVudHMubGVuZ3RoID4gMTtcbiAgICAgICAgICAgIHJlc3VsdCA9IFsnWycsIG11bHRpbGluZSA/IG5ld2xpbmUgOiAnJ107XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uIChpbmRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgaXo7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBleHByLmVsZW1lbnRzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleHByLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA9PT0gaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobXVsdGlsaW5lID8gaW5kZW50IDogJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5lbGVtZW50c1tpXSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyAobXVsdGlsaW5lID8gbmV3bGluZSA6IHNwYWNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChtdWx0aWxpbmUgJiYgIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChtdWx0aWxpbmUgPyBiYXNlIDogJycpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJ10nKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgUmVzdEVsZW1lbnQ6IGZ1bmN0aW9uKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gJy4uLicgKyB0aGlzLmdlbmVyYXRlUGF0dGVybihleHByLmFyZ3VtZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBDbGFzc0V4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZnJhZ21lbnQ7XG4gICAgICAgICAgICByZXN1bHQgPSBbJ2NsYXNzJ107XG4gICAgICAgICAgICBpZiAoZXhwci5pZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmlkLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cHIuc3VwZXJDbGFzcykge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gam9pbignZXh0ZW5kcycsIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuc3VwZXJDbGFzcywgUHJlY2VkZW5jZS5VbmFyeSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZVN0YXRlbWVudChleHByLmJvZHksIFNfVEZGVCkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBNZXRob2REZWZpbml0aW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGZyYWdtZW50O1xuICAgICAgICAgICAgaWYgKGV4cHJbJ3N0YXRpYyddKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gWydzdGF0aWMnICsgc3BhY2VdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHByLmtpbmQgPT09ICdnZXQnIHx8IGV4cHIua2luZCA9PT0gJ3NldCcpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgam9pbihleHByLmtpbmQsIHRoaXMuZ2VuZXJhdGVQcm9wZXJ0eUtleShleHByLmtleSwgZXhwci5jb21wdXRlZCkpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIudmFsdWUpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTWV0aG9kUHJlZml4KGV4cHIpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlUHJvcGVydHlLZXkoZXhwci5rZXksIGV4cHIuY29tcHV0ZWQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIudmFsdWUpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBqb2luKHJlc3VsdCwgZnJhZ21lbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFByb3BlcnR5OiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmIChleHByLmtpbmQgPT09ICdnZXQnIHx8IGV4cHIua2luZCA9PT0gJ3NldCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBleHByLmtpbmQsIG5vRW1wdHlTcGFjZSgpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlUHJvcGVydHlLZXkoZXhwci5rZXksIGV4cHIuY29tcHV0ZWQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIudmFsdWUpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIuc2hvcnRoYW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIudmFsdWUudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkFzc2lnbm1lbnRQYXR0ZXJuKGV4cHIudmFsdWUsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVQcm9wZXJ0eUtleShleHByLmtleSwgZXhwci5jb21wdXRlZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHByLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTWV0aG9kUHJlZml4KGV4cHIpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlUHJvcGVydHlLZXkoZXhwci5rZXksIGV4cHIuY29tcHV0ZWQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIudmFsdWUpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlUHJvcGVydHlLZXkoZXhwci5rZXksIGV4cHIuY29tcHV0ZWQpLFxuICAgICAgICAgICAgICAgICc6JyArIHNwYWNlLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIudmFsdWUsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIG11bHRpbGluZSwgcmVzdWx0LCBmcmFnbWVudCwgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICghZXhwci5wcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAne30nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXVsdGlsaW5lID0gZXhwci5wcm9wZXJ0aWVzLmxlbmd0aCA+IDE7XG5cbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5wcm9wZXJ0aWVzWzBdLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFtdWx0aWxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBpc3N1ZXMgNFxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCB0cmFuc2Zvcm0gZnJvbVxuICAgICAgICAgICAgICAgIC8vICAgZGVqYXZ1LkNsYXNzLmRlY2xhcmUoe1xuICAgICAgICAgICAgICAgIC8vICAgICAgIG1ldGhvZDI6IGZ1bmN0aW9uICgpIHt9XG4gICAgICAgICAgICAgICAgLy8gICB9KTtcbiAgICAgICAgICAgICAgICAvLyB0b1xuICAgICAgICAgICAgICAgIC8vICAgZGVqYXZ1LkNsYXNzLmRlY2xhcmUoe21ldGhvZDI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICB9fSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKGZyYWdtZW50KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyAneycsIHNwYWNlLCBmcmFnbWVudCwgc3BhY2UsICd9JyBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIGl6O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsgJ3snLCBuZXdsaW5lLCBpbmRlbnQsIGZyYWdtZW50IF07XG5cbiAgICAgICAgICAgICAgICBpZiAobXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBpeiA9IGV4cHIucHJvcGVydGllcy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5wcm9wZXJ0aWVzW2ldLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChiYXNlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCd9Jyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEFzc2lnbm1lbnRQYXR0ZXJuOiBmdW5jdGlvbihleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVBc3NpZ25tZW50KGV4cHIubGVmdCwgZXhwci5yaWdodCwgJz0nLCBwcmVjZWRlbmNlLCBmbGFncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgT2JqZWN0UGF0dGVybjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBpLCBpeiwgbXVsdGlsaW5lLCBwcm9wZXJ0eSwgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIWV4cHIucHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3t9JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbXVsdGlsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZXhwci5wcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gZXhwci5wcm9wZXJ0aWVzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkudHlwZSA9PT0gU3ludGF4LlByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICYmIHByb3BlcnR5LnZhbHVlLnR5cGUgIT09IFN5bnRheC5JZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpbGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGV4cHIucHJvcGVydGllcy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gZXhwci5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS50eXBlID09PSBTeW50YXguUHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmICFwcm9wZXJ0eS5zaG9ydGhhbmRcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBbJ3snLCBtdWx0aWxpbmUgPyBuZXdsaW5lIDogJycgXTtcblxuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIGl6O1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gZXhwci5wcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobXVsdGlsaW5lID8gaW5kZW50IDogJycpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihleHByLnByb3BlcnRpZXNbaV0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyAobXVsdGlsaW5lID8gbmV3bGluZSA6IHNwYWNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG11bHRpbGluZSAmJiAhZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG11bHRpbGluZSA/IGJhc2UgOiAnJyk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnfScpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBUaGlzRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RoaXMnO1xuICAgICAgICB9LFxuXG4gICAgICAgIFN1cGVyOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiAnc3VwZXInO1xuICAgICAgICB9LFxuXG4gICAgICAgIElkZW50aWZpZXI6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlSWRlbnRpZmllcihleHByKTtcbiAgICAgICAgfSxcblxuICAgICAgICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZUlkZW50aWZpZXIoZXhwci5pZCB8fCBleHByLmxvY2FsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFsnKiddO1xuICAgICAgICAgICAgdmFyIGlkID0gZXhwci5pZCB8fCBleHByLmxvY2FsO1xuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UgKyAnYXMnICsgbm9FbXB0eVNwYWNlKCkgKyBnZW5lcmF0ZUlkZW50aWZpZXIoaWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgSW1wb3J0U3BlY2lmaWVyOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciBpbXBvcnRlZCA9IGV4cHIuaW1wb3J0ZWQ7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gWyBpbXBvcnRlZC5uYW1lIF07XG4gICAgICAgICAgICB2YXIgbG9jYWwgPSBleHByLmxvY2FsO1xuICAgICAgICAgICAgaWYgKGxvY2FsICYmIGxvY2FsLm5hbWUgIT09IGltcG9ydGVkLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub0VtcHR5U3BhY2UoKSArICdhcycgKyBub0VtcHR5U3BhY2UoKSArIGdlbmVyYXRlSWRlbnRpZmllcihsb2NhbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBFeHBvcnRTcGVjaWZpZXI6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIGxvY2FsID0gZXhwci5sb2NhbDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbIGxvY2FsLm5hbWUgXTtcbiAgICAgICAgICAgIHZhciBleHBvcnRlZCA9IGV4cHIuZXhwb3J0ZWQ7XG4gICAgICAgICAgICBpZiAoZXhwb3J0ZWQgJiYgZXhwb3J0ZWQubmFtZSAhPT0gbG9jYWwubmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vRW1wdHlTcGFjZSgpICsgJ2FzJyArIG5vRW1wdHlTcGFjZSgpICsgZ2VuZXJhdGVJZGVudGlmaWVyKGV4cG9ydGVkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIExpdGVyYWw6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJhdztcbiAgICAgICAgICAgIGlmIChleHByLmhhc093blByb3BlcnR5KCdyYXcnKSAmJiBwYXJzZSAmJiBleHRyYS5yYXcpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByYXcgPSBwYXJzZShleHByLnJhdykuYm9keVswXS5leHByZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmF3LnR5cGUgPT09IFN5bnRheC5MaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmF3LnZhbHVlID09PSBleHByLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHIucmF3O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3QgdXNlIHJhdyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIucmVnZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICcvJyArIGV4cHIucmVnZXgucGF0dGVybiArICcvJyArIGV4cHIucmVnZXguZmxhZ3M7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwci52YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwci52YWx1ZS50b1N0cmluZygpICsgJ24nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBgZXhwci52YWx1ZWAgY2FuIGJlIG51bGwgaWYgYGV4cHIuYmlnaW50YCBleGlzdHMuIFdlIG5lZWQgdG8gY2hlY2tcbiAgICAgICAgICAgIC8vIGBleHByLmJpZ2ludGAgZmlyc3QuXG4gICAgICAgICAgICBpZiAoZXhwci5iaWdpbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwci5iaWdpbnQgKyAnbic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHByLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByLnZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVTdHJpbmcoZXhwci52YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwci52YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVOdW1iZXIoZXhwci52YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwci52YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cHIudmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVSZWdFeHAoZXhwci52YWx1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgR2VuZXJhdG9yRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5Db21wcmVoZW5zaW9uRXhwcmVzc2lvbihleHByLCBwcmVjZWRlbmNlLCBmbGFncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tcHJlaGVuc2lvbkV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgLy8gR2VuZXJhdG9yRXhwcmVzc2lvbiBzaG91bGQgYmUgcGFyZW50aGVzaXplZCB3aXRoICguLi4pLCBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiB3aXRoIFsuLi5dXG4gICAgICAgICAgICAvLyBEdWUgdG8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODgzNDY4IHBvc2l0aW9uIG9mIGV4cHIuYm9keSBjYW4gZGlmZmVyIGluIFNwaWRlcm1vbmtleSBhbmQgRVM2XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQsIGksIGl6LCBmcmFnbWVudCwgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICByZXN1bHQgPSAoZXhwci50eXBlID09PSBTeW50YXguR2VuZXJhdG9yRXhwcmVzc2lvbikgPyBbJygnXSA6IFsnWyddO1xuXG4gICAgICAgICAgICBpZiAoZXh0cmEubW96LmNvbXByZWhlbnNpb25FeHByZXNzaW9uU3RhcnRzV2l0aEFzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYm9keSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXhwci5ibG9ja3MpIHtcbiAgICAgICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBleHByLmJsb2Nrcy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYmxvY2tzW2ldLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDAgfHwgZXh0cmEubW96LmNvbXByZWhlbnNpb25FeHByZXNzaW9uU3RhcnRzV2l0aEFzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsICdpZicgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmZpbHRlciwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBbICcoJywgZnJhZ21lbnQsICcpJyBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFleHRyYS5tb3ouY29tcHJlaGVuc2lvbkV4cHJlc3Npb25TdGFydHNXaXRoQXNzaWdubWVudCkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5ib2R5LCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKTtcblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBmcmFnbWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChleHByLnR5cGUgPT09IFN5bnRheC5HZW5lcmF0b3JFeHByZXNzaW9uKSA/ICcpJyA6ICddJyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbXByZWhlbnNpb25CbG9jazogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgZnJhZ21lbnQ7XG4gICAgICAgICAgICBpZiAoZXhwci5sZWZ0LnR5cGUgPT09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIGV4cHIubGVmdC5raW5kLCBub0VtcHR5U3BhY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZVN0YXRlbWVudChleHByLmxlZnQuZGVjbGFyYXRpb25zWzBdLCBTX0ZGRkYpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmxlZnQsIFByZWNlZGVuY2UuQ2FsbCwgRV9UVFQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcmFnbWVudCA9IGpvaW4oZnJhZ21lbnQsIGV4cHIub2YgPyAnb2YnIDogJ2luJyk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGpvaW4oZnJhZ21lbnQsIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucmlnaHQsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBbICdmb3InICsgc3BhY2UgKyAnKCcsIGZyYWdtZW50LCAnKScgXTtcbiAgICAgICAgfSxcblxuICAgICAgICBTcHJlYWRFbGVtZW50OiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgJy4uLicsXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudCwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciBpdGVtRmxhZ3MgPSBFX1RURjtcbiAgICAgICAgICAgIGlmICghKGZsYWdzICYgRl9BTExPV19DQUxMKSkge1xuICAgICAgICAgICAgICAgIGl0ZW1GbGFncyA9IEVfVEZGO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLnRhZywgUHJlY2VkZW5jZS5DYWxsLCBpdGVtRmxhZ3MpLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucXVhc2ksIFByZWNlZGVuY2UuUHJpbWFyeSwgRV9GRlQpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShyZXN1bHQsIFByZWNlZGVuY2UuVGFnZ2VkVGVtcGxhdGUsIHByZWNlZGVuY2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFRlbXBsYXRlRWxlbWVudDogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICAvLyBEb24ndCB1c2UgXCJjb29rZWRcIi4gU2luY2UgdGFnZ2VkIHRlbXBsYXRlIGNhbiB1c2UgcmF3IHRlbXBsYXRlXG4gICAgICAgICAgICAvLyByZXByZXNlbnRhdGlvbi4gU28gaWYgd2UgZG8gc28sIGl0IGJyZWFrcyB0aGUgc2NyaXB0IHNlbWFudGljcy5cbiAgICAgICAgICAgIHJldHVybiBleHByLnZhbHVlLnJhdztcbiAgICAgICAgfSxcblxuICAgICAgICBUZW1wbGF0ZUxpdGVyYWw6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgaSwgaXo7XG4gICAgICAgICAgICByZXN1bHQgPSBbICdgJyBdO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBleHByLnF1YXNpcy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5xdWFzaXNbaV0sIFByZWNlZGVuY2UuUHJpbWFyeSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnJHsnICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmV4cHJlc3Npb25zW2ldLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSArICd9Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goJ2AnKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTW9kdWxlU3BlY2lmaWVyOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkxpdGVyYWwoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEltcG9ydEV4cHJlc3Npb246IGZ1bmN0aW9uKGV4cHIsIHByZWNlZGVuY2UsIGZsYWcpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUoW1xuICAgICAgICAgICAgICAgICdpbXBvcnQoJyxcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLnNvdXJjZSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCksXG4gICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICBdLCBQcmVjZWRlbmNlLkNhbGwsIHByZWNlZGVuY2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1lcmdlKENvZGVHZW5lcmF0b3IucHJvdG90eXBlLCBDb2RlR2VuZXJhdG9yLkV4cHJlc3Npb24pO1xuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgIHZhciByZXN1bHQsIHR5cGU7XG5cbiAgICAgICAgdHlwZSA9IGV4cHIudHlwZSB8fCBTeW50YXguUHJvcGVydHk7XG5cbiAgICAgICAgaWYgKGV4dHJhLnZlcmJhdGltICYmIGV4cHIuaGFzT3duUHJvcGVydHkoZXh0cmEudmVyYmF0aW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVWZXJiYXRpbShleHByLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHRoaXNbdHlwZV0oZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpO1xuXG5cbiAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGFkZENvbW1lbnRzKGV4cHIsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0LCBleHByKTtcbiAgICB9O1xuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICAgIGZyYWdtZW50O1xuXG4gICAgICAgIHJlc3VsdCA9IHRoaXNbc3RtdC50eXBlXShzdG10LCBmbGFncyk7XG5cbiAgICAgICAgLy8gQXR0YWNoIGNvbW1lbnRzXG5cbiAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGFkZENvbW1lbnRzKHN0bXQsIHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFnbWVudCA9IHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpO1xuICAgICAgICBpZiAoc3RtdC50eXBlID09PSBTeW50YXguUHJvZ3JhbSAmJiAhc2FmZUNvbmNhdGVuYXRpb24gJiYgbmV3bGluZSA9PT0gJycgJiYgIGZyYWdtZW50LmNoYXJBdChmcmFnbWVudC5sZW5ndGggLSAxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZU1hcCA/IHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS5yZXBsYWNlUmlnaHQoL1xccyskLywgJycpIDogZnJhZ21lbnQucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQsIHN0bXQpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUludGVybmFsKG5vZGUpIHtcbiAgICAgICAgdmFyIGNvZGVnZW47XG5cbiAgICAgICAgY29kZWdlbiA9IG5ldyBDb2RlR2VuZXJhdG9yKCk7XG4gICAgICAgIGlmIChpc1N0YXRlbWVudChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW4uZ2VuZXJhdGVTdGF0ZW1lbnQobm9kZSwgU19URkZGKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0V4cHJlc3Npb24obm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuLmdlbmVyYXRlRXhwcmVzc2lvbihub2RlLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZSB0eXBlOiAnICsgbm9kZS50eXBlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZShub2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IGdldERlZmF1bHRPcHRpb25zKCksIHJlc3VsdCwgcGFpcjtcblxuICAgICAgICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBPYnNvbGV0ZSBvcHRpb25zXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICBgb3B0aW9ucy5pbmRlbnRgXG4gICAgICAgICAgICAvLyAgIGBvcHRpb25zLmJhc2VgXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiB0aGVtLCB3ZSBjYW4gdXNlIGBvcHRpb24uZm9ybWF0LmluZGVudGAuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW5kZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zLmZvcm1hdC5pbmRlbnQuc3R5bGUgPSBvcHRpb25zLmluZGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5iYXNlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zLmZvcm1hdC5pbmRlbnQuYmFzZSA9IG9wdGlvbnMuYmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMgPSB1cGRhdGVEZWVwbHkoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaW5kZW50ID0gb3B0aW9ucy5mb3JtYXQuaW5kZW50LnN0eWxlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmJhc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IG9wdGlvbnMuYmFzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHN0cmluZ1JlcGVhdChpbmRlbnQsIG9wdGlvbnMuZm9ybWF0LmluZGVudC5iYXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgICAgIGluZGVudCA9IG9wdGlvbnMuZm9ybWF0LmluZGVudC5zdHlsZTtcbiAgICAgICAgICAgIGJhc2UgPSBzdHJpbmdSZXBlYXQoaW5kZW50LCBvcHRpb25zLmZvcm1hdC5pbmRlbnQuYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAganNvbiA9IG9wdGlvbnMuZm9ybWF0Lmpzb247XG4gICAgICAgIHJlbnVtYmVyID0gb3B0aW9ucy5mb3JtYXQucmVudW1iZXI7XG4gICAgICAgIGhleGFkZWNpbWFsID0ganNvbiA/IGZhbHNlIDogb3B0aW9ucy5mb3JtYXQuaGV4YWRlY2ltYWw7XG4gICAgICAgIHF1b3RlcyA9IGpzb24gPyAnZG91YmxlJyA6IG9wdGlvbnMuZm9ybWF0LnF1b3RlcztcbiAgICAgICAgZXNjYXBlbGVzcyA9IG9wdGlvbnMuZm9ybWF0LmVzY2FwZWxlc3M7XG4gICAgICAgIG5ld2xpbmUgPSBvcHRpb25zLmZvcm1hdC5uZXdsaW5lO1xuICAgICAgICBzcGFjZSA9IG9wdGlvbnMuZm9ybWF0LnNwYWNlO1xuICAgICAgICBpZiAob3B0aW9ucy5mb3JtYXQuY29tcGFjdCkge1xuICAgICAgICAgICAgbmV3bGluZSA9IHNwYWNlID0gaW5kZW50ID0gYmFzZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudGhlc2VzID0gb3B0aW9ucy5mb3JtYXQucGFyZW50aGVzZXM7XG4gICAgICAgIHNlbWljb2xvbnMgPSBvcHRpb25zLmZvcm1hdC5zZW1pY29sb25zO1xuICAgICAgICBzYWZlQ29uY2F0ZW5hdGlvbiA9IG9wdGlvbnMuZm9ybWF0LnNhZmVDb25jYXRlbmF0aW9uO1xuICAgICAgICBkaXJlY3RpdmUgPSBvcHRpb25zLmRpcmVjdGl2ZTtcbiAgICAgICAgcGFyc2UgPSBqc29uID8gbnVsbCA6IG9wdGlvbnMucGFyc2U7XG4gICAgICAgIHNvdXJjZU1hcCA9IG9wdGlvbnMuc291cmNlTWFwO1xuICAgICAgICBzb3VyY2VDb2RlID0gb3B0aW9ucy5zb3VyY2VDb2RlO1xuICAgICAgICBwcmVzZXJ2ZUJsYW5rTGluZXMgPSBvcHRpb25zLmZvcm1hdC5wcmVzZXJ2ZUJsYW5rTGluZXMgJiYgc291cmNlQ29kZSAhPT0gbnVsbDtcbiAgICAgICAgZXh0cmEgPSBvcHRpb25zO1xuXG4gICAgICAgIGlmIChzb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGlmICghZXhwb3J0cy5icm93c2VyKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXNzdW1lIGVudmlyb25tZW50IGlzIG5vZGUuanNcbiAgICAgICAgICAgICAgICAvLyBBbmQgcHJldmVudCBmcm9tIGluY2x1ZGluZyBzb3VyY2UtbWFwIGJ5IGJyb3dzZXJpZnlcbiAgICAgICAgICAgICAgICBTb3VyY2VOb2RlID0gcmVxdWlyZSgnc291cmNlLW1hcCcpLlNvdXJjZU5vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFNvdXJjZU5vZGUgPSBnbG9iYWwuc291cmNlTWFwLlNvdXJjZU5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBnZW5lcmF0ZUludGVybmFsKG5vZGUpO1xuXG4gICAgICAgIGlmICghc291cmNlTWFwKSB7XG4gICAgICAgICAgICBwYWlyID0ge2NvZGU6IHJlc3VsdC50b1N0cmluZygpLCBtYXA6IG51bGx9O1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuc291cmNlTWFwV2l0aENvZGUgPyBwYWlyIDogcGFpci5jb2RlO1xuICAgICAgICB9XG5cblxuICAgICAgICBwYWlyID0gcmVzdWx0LnRvU3RyaW5nV2l0aFNvdXJjZU1hcCh7XG4gICAgICAgICAgICBmaWxlOiBvcHRpb25zLmZpbGUsXG4gICAgICAgICAgICBzb3VyY2VSb290OiBvcHRpb25zLnNvdXJjZU1hcFJvb3RcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc291cmNlQ29udGVudCkge1xuICAgICAgICAgICAgcGFpci5tYXAuc2V0U291cmNlQ29udGVudChvcHRpb25zLnNvdXJjZU1hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zb3VyY2VDb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcFdpdGhDb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFpcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYWlyLm1hcC50b1N0cmluZygpO1xuICAgIH1cblxuICAgIEZPUk1BVF9NSU5JRlkgPSB7XG4gICAgICAgIGluZGVudDoge1xuICAgICAgICAgICAgc3R5bGU6ICcnLFxuICAgICAgICAgICAgYmFzZTogMFxuICAgICAgICB9LFxuICAgICAgICByZW51bWJlcjogdHJ1ZSxcbiAgICAgICAgaGV4YWRlY2ltYWw6IHRydWUsXG4gICAgICAgIHF1b3RlczogJ2F1dG8nLFxuICAgICAgICBlc2NhcGVsZXNzOiB0cnVlLFxuICAgICAgICBjb21wYWN0OiB0cnVlLFxuICAgICAgICBwYXJlbnRoZXNlczogZmFsc2UsXG4gICAgICAgIHNlbWljb2xvbnM6IGZhbHNlXG4gICAgfTtcblxuICAgIEZPUk1BVF9ERUZBVUxUUyA9IGdldERlZmF1bHRPcHRpb25zKCkuZm9ybWF0O1xuXG4gICAgZXhwb3J0cy52ZXJzaW9uID0gcmVxdWlyZSgnLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuICAgIGV4cG9ydHMuZ2VuZXJhdGUgPSBnZW5lcmF0ZTtcbiAgICBleHBvcnRzLmF0dGFjaENvbW1lbnRzID0gZXN0cmF2ZXJzZS5hdHRhY2hDb21tZW50cztcbiAgICBleHBvcnRzLlByZWNlZGVuY2UgPSB1cGRhdGVEZWVwbHkoe30sIFByZWNlZGVuY2UpO1xuICAgIGV4cG9ydHMuYnJvd3NlciA9IGZhbHNlO1xuICAgIGV4cG9ydHMuRk9STUFUX01JTklGWSA9IEZPUk1BVF9NSU5JRlk7XG4gICAgZXhwb3J0cy5GT1JNQVRfREVGQVVMVFMgPSBGT1JNQVRfREVGQVVMVFM7XG59KCkpO1xuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiJdLCJuYW1lcyI6WyJTeW50YXgiLCJQcmVjZWRlbmNlIiwiQmluYXJ5UHJlY2VkZW5jZSIsIlNvdXJjZU5vZGUiLCJlc3RyYXZlcnNlIiwiZXN1dGlscyIsImJhc2UiLCJpbmRlbnQiLCJqc29uIiwicmVudW1iZXIiLCJoZXhhZGVjaW1hbCIsInF1b3RlcyIsImVzY2FwZWxlc3MiLCJuZXdsaW5lIiwic3BhY2UiLCJwYXJlbnRoZXNlcyIsInNlbWljb2xvbnMiLCJzYWZlQ29uY2F0ZW5hdGlvbiIsImRpcmVjdGl2ZSIsImV4dHJhIiwicGFyc2UiLCJzb3VyY2VNYXAiLCJzb3VyY2VDb2RlIiwicHJlc2VydmVCbGFua0xpbmVzIiwiRk9STUFUX01JTklGWSIsIkZPUk1BVF9ERUZBVUxUUyIsInJlcXVpcmUiLCJpc0V4cHJlc3Npb24iLCJub2RlIiwiQ29kZUdlbmVyYXRvciIsIkV4cHJlc3Npb24iLCJoYXNPd25Qcm9wZXJ0eSIsInR5cGUiLCJpc1N0YXRlbWVudCIsIlN0YXRlbWVudCIsIlNlcXVlbmNlIiwiWWllbGQiLCJBc3NpZ25tZW50IiwiQ29uZGl0aW9uYWwiLCJBcnJvd0Z1bmN0aW9uIiwiQ29hbGVzY2UiLCJMb2dpY2FsT1IiLCJMb2dpY2FsQU5EIiwiQml0d2lzZU9SIiwiQml0d2lzZVhPUiIsIkJpdHdpc2VBTkQiLCJFcXVhbGl0eSIsIlJlbGF0aW9uYWwiLCJCaXR3aXNlU0hJRlQiLCJBZGRpdGl2ZSIsIk11bHRpcGxpY2F0aXZlIiwiRXhwb25lbnRpYXRpb24iLCJBd2FpdCIsIlVuYXJ5IiwiUG9zdGZpeCIsIk9wdGlvbmFsQ2hhaW5pbmciLCJDYWxsIiwiTmV3IiwiVGFnZ2VkVGVtcGxhdGUiLCJNZW1iZXIiLCJQcmltYXJ5IiwiRl9BTExPV19JTiIsIkZfQUxMT1dfQ0FMTCIsIkZfQUxMT1dfVU5QQVJBVEhfTkVXIiwiRl9GVU5DX0JPRFkiLCJGX0RJUkVDVElWRV9DVFgiLCJGX1NFTUlDT0xPTl9PUFQiLCJGX0ZPVU5EX0NPQUxFU0NFIiwiRV9GVFQiLCJFX1RURiIsIkVfVFRUIiwiRV9URkYiLCJFX0ZGVCIsIkVfVEZUIiwiU19URkZGIiwiU19URkZUIiwiU19GRkZGIiwiU19URlRGIiwiU19UVEZGIiwiZ2V0RGVmYXVsdE9wdGlvbnMiLCJjb21tZW50IiwiZm9ybWF0Iiwic3R5bGUiLCJhZGp1c3RNdWx0aWxpbmVDb21tZW50IiwiY29tcGFjdCIsIm1veiIsImNvbXByZWhlbnNpb25FeHByZXNzaW9uU3RhcnRzV2l0aEFzc2lnbm1lbnQiLCJzdGFybGVzc0dlbmVyYXRvciIsInNvdXJjZU1hcFJvb3QiLCJzb3VyY2VNYXBXaXRoQ29kZSIsInJhdyIsInZlcmJhdGltIiwic3RyaW5nUmVwZWF0Iiwic3RyIiwibnVtIiwicmVzdWx0IiwiaGFzTGluZVRlcm1pbmF0b3IiLCJ0ZXN0IiwiZW5kc1dpdGhMaW5lVGVybWluYXRvciIsImxlbiIsImxlbmd0aCIsImNvZGUiLCJpc0xpbmVUZXJtaW5hdG9yIiwiY2hhckNvZGVBdCIsIm1lcmdlIiwidGFyZ2V0Iiwib3ZlcnJpZGUiLCJrZXkiLCJ1cGRhdGVEZWVwbHkiLCJ2YWwiLCJpc0hhc2hPYmplY3QiLCJPYmplY3QiLCJSZWdFeHAiLCJnZW5lcmF0ZU51bWJlciIsInZhbHVlIiwicG9pbnQiLCJ0ZW1wIiwiZXhwb25lbnQiLCJwb3MiLCJFcnJvciIsImluZGV4T2YiLCJzbGljZSIsInJlcGxhY2UiLCJNYXRoIiwiZmxvb3IiLCJ0b1N0cmluZyIsImVzY2FwZVJlZ0V4cENoYXJhY3RlciIsImNoIiwicHJldmlvdXNJc0JhY2tzbGFzaCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImdlbmVyYXRlUmVnRXhwIiwicmVnIiwibWF0Y2giLCJmbGFncyIsImkiLCJpeiIsImNoYXJhY3RlckluQnJhY2siLCJzb3VyY2UiLCJlc2NhcGVBbGxvd2VkQ2hhcmFjdGVyIiwibmV4dCIsImhleCIsInRvVXBwZXJDYXNlIiwiaXNEZWNpbWFsRGlnaXQiLCJlc2NhcGVEaXNhbGxvd2VkQ2hhcmFjdGVyIiwiZXNjYXBlRGlyZWN0aXZlIiwicXVvdGUiLCJlc2NhcGVTdHJpbmciLCJzaW5nbGVRdW90ZXMiLCJkb3VibGVRdW90ZXMiLCJzaW5nbGUiLCJpc0lkZW50aWZpZXJQYXJ0RVM1IiwiZmxhdHRlblRvU3RyaW5nIiwiYXJyIiwiZWxlbSIsIkFycmF5IiwiaXNBcnJheSIsInRvU291cmNlTm9kZVdoZW5OZWVkZWQiLCJnZW5lcmF0ZWQiLCJsb2MiLCJuYW1lIiwic3RhcnQiLCJsaW5lIiwiY29sdW1uIiwibm9FbXB0eVNwYWNlIiwiam9pbiIsImxlZnQiLCJyaWdodCIsImxlZnRTb3VyY2UiLCJyaWdodFNvdXJjZSIsImxlZnRDaGFyQ29kZSIsInJpZ2h0Q2hhckNvZGUiLCJpc1doaXRlU3BhY2UiLCJhZGRJbmRlbnQiLCJzdG10Iiwid2l0aEluZGVudCIsImZuIiwicHJldmlvdXNCYXNlIiwiY2FsY3VsYXRlU3BhY2VzIiwic3BlY2lhbEJhc2UiLCJhcnJheSIsImoiLCJzcGFjZXMiLCJzbiIsInNwbGl0IiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiZ2VuZXJhdGVDb21tZW50IiwiYWRkQ29tbWVudHMiLCJzYXZlIiwidGFpbGluZ1RvU3RhdGVtZW50IiwiZnJhZ21lbnQiLCJleHRSYW5nZSIsInJhbmdlIiwicHJldlJhbmdlIiwicHJlZml4IiwiaW5maXgiLCJzdWZmaXgiLCJjb3VudCIsImxlYWRpbmdDb21tZW50cyIsImV4dGVuZGVkUmFuZ2UiLCJzdWJzdHJpbmciLCJwdXNoIiwiUHJvZ3JhbSIsImJvZHkiLCJ0cmFpbGluZ0NvbW1lbnRzIiwiZ2VuZXJhdGVCbGFua0xpbmVzIiwiZW5kIiwibmV3bGluZUNvdW50IiwicGFyZW50aGVzaXplIiwidGV4dCIsImN1cnJlbnQiLCJzaG91bGQiLCJnZW5lcmF0ZVZlcmJhdGltU3RyaW5nIiwic3RyaW5nIiwiZ2VuZXJhdGVWZXJiYXRpbSIsImV4cHIiLCJwcmVjZWRlbmNlIiwicHJlYyIsImNvbnRlbnQiLCJwcm90b3R5cGUiLCJtYXliZUJsb2NrIiwibm9MZWFkaW5nQ29tbWVudCIsInRoYXQiLCJCbG9ja1N0YXRlbWVudCIsImdlbmVyYXRlU3RhdGVtZW50IiwiRW1wdHlTdGF0ZW1lbnQiLCJtYXliZUJsb2NrU3VmZml4IiwiZW5kcyIsImdlbmVyYXRlSWRlbnRpZmllciIsImdlbmVyYXRlQXN5bmNQcmVmaXgiLCJzcGFjZVJlcXVpcmVkIiwiYXN5bmMiLCJnZW5lcmF0ZVN0YXJTdWZmaXgiLCJpc0dlbmVyYXRvciIsImdlbmVyYXRvciIsImdlbmVyYXRlTWV0aG9kUHJlZml4IiwicHJvcCIsImZ1bmMiLCJjb21wdXRlZCIsImdlbmVyYXRlUGF0dGVybiIsIklkZW50aWZpZXIiLCJnZW5lcmF0ZUV4cHJlc3Npb24iLCJnZW5lcmF0ZUZ1bmN0aW9uUGFyYW1zIiwiaGFzRGVmYXVsdCIsIkFycm93RnVuY3Rpb25FeHByZXNzaW9uIiwicmVzdCIsImRlZmF1bHRzIiwicGFyYW1zIiwiZ2VuZXJhdGVBc3NpZ25tZW50IiwiZ2VuZXJhdGVGdW5jdGlvbkJvZHkiLCJleHByZXNzaW9uIiwiY2hhckF0IiwiZ2VuZXJhdGVJdGVyYXRpb25Gb3JTdGF0ZW1lbnQiLCJvcGVyYXRvciIsImF3YWl0IiwiVmFyaWFibGVEZWNsYXJhdGlvbiIsImtpbmQiLCJkZWNsYXJhdGlvbnMiLCJnZW5lcmF0ZVByb3BlcnR5S2V5Iiwic2VtaWNvbG9uIiwiYm9keUZsYWdzIiwiQnJlYWtTdGF0ZW1lbnQiLCJsYWJlbCIsIkNvbnRpbnVlU3RhdGVtZW50IiwiQ2xhc3NCb2R5IiwiQ2xhc3NEZWNsYXJhdGlvbiIsImlkIiwic3VwZXJDbGFzcyIsIkRpcmVjdGl2ZVN0YXRlbWVudCIsIkRvV2hpbGVTdGF0ZW1lbnQiLCJDYXRjaENsYXVzZSIsImd1YXJkIiwicGFyYW0iLCJzcGxpY2UiLCJEZWJ1Z2dlclN0YXRlbWVudCIsIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiIsImRlY2xhcmF0aW9uIiwiRXhwb3J0TmFtZWREZWNsYXJhdGlvbiIsInNwZWNpZmllcnMiLCJFeHBvcnRCYXRjaFNwZWNpZmllciIsIkV4cG9ydEFsbERlY2xhcmF0aW9uIiwiRXhwcmVzc2lvblN0YXRlbWVudCIsImlzQ2xhc3NQcmVmaXhlZCIsImlzRnVuY3Rpb25QcmVmaXhlZCIsImlzQXN5bmNQcmVmaXhlZCIsIkxpdGVyYWwiLCJJbXBvcnREZWNsYXJhdGlvbiIsImN1cnNvciIsIkltcG9ydERlZmF1bHRTcGVjaWZpZXIiLCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIiLCJWYXJpYWJsZURlY2xhcmF0b3IiLCJpdGVtRmxhZ3MiLCJpbml0IiwiYmxvY2siLCJUaHJvd1N0YXRlbWVudCIsImFyZ3VtZW50IiwiVHJ5U3RhdGVtZW50IiwiZ3VhcmRlZEhhbmRsZXJzIiwiaGFuZGxlcnMiLCJmaW5hbGl6ZXIiLCJoYW5kbGVyIiwiU3dpdGNoU3RhdGVtZW50IiwiZGlzY3JpbWluYW50IiwiY2FzZXMiLCJTd2l0Y2hDYXNlIiwiY29uc2VxdWVudCIsIklmU3RhdGVtZW50Iiwic2VtaWNvbG9uT3B0aW9uYWwiLCJhbHRlcm5hdGUiLCJGb3JTdGF0ZW1lbnQiLCJ1cGRhdGUiLCJGb3JJblN0YXRlbWVudCIsIkZvck9mU3RhdGVtZW50IiwiTGFiZWxlZFN0YXRlbWVudCIsIkZ1bmN0aW9uRGVjbGFyYXRpb24iLCJSZXR1cm5TdGF0ZW1lbnQiLCJXaGlsZVN0YXRlbWVudCIsIldpdGhTdGF0ZW1lbnQiLCJvYmplY3QiLCJTZXF1ZW5jZUV4cHJlc3Npb24iLCJleHByZXNzaW9ucyIsIkFzc2lnbm1lbnRFeHByZXNzaW9uIiwiQ29uZGl0aW9uYWxFeHByZXNzaW9uIiwiTG9naWNhbEV4cHJlc3Npb24iLCJCaW5hcnlFeHByZXNzaW9uIiwibGVmdFByZWNlZGVuY2UiLCJyaWdodFByZWNlZGVuY2UiLCJjdXJyZW50UHJlY2VkZW5jZSIsIkNhbGxFeHByZXNzaW9uIiwiY2FsbGVlIiwib3B0aW9uYWwiLCJDaGFpbkV4cHJlc3Npb24iLCJOZXdFeHByZXNzaW9uIiwiTWVtYmVyRXhwcmVzc2lvbiIsInByb3BlcnR5IiwiTWV0YVByb3BlcnR5IiwibWV0YSIsIlVuYXJ5RXhwcmVzc2lvbiIsIllpZWxkRXhwcmVzc2lvbiIsImRlbGVnYXRlIiwiQXdhaXRFeHByZXNzaW9uIiwiYWxsIiwiVXBkYXRlRXhwcmVzc2lvbiIsIkZ1bmN0aW9uRXhwcmVzc2lvbiIsIkFycmF5UGF0dGVybiIsIkFycmF5RXhwcmVzc2lvbiIsImlzUGF0dGVybiIsIm11bHRpbGluZSIsImVsZW1lbnRzIiwiUmVzdEVsZW1lbnQiLCJDbGFzc0V4cHJlc3Npb24iLCJNZXRob2REZWZpbml0aW9uIiwiUHJvcGVydHkiLCJzaG9ydGhhbmQiLCJBc3NpZ25tZW50UGF0dGVybiIsIm1ldGhvZCIsIk9iamVjdEV4cHJlc3Npb24iLCJwcm9wZXJ0aWVzIiwiT2JqZWN0UGF0dGVybiIsIlRoaXNFeHByZXNzaW9uIiwiU3VwZXIiLCJsb2NhbCIsIkltcG9ydFNwZWNpZmllciIsImltcG9ydGVkIiwiRXhwb3J0U3BlY2lmaWVyIiwiZXhwb3J0ZWQiLCJlIiwicmVnZXgiLCJwYXR0ZXJuIiwiYmlnaW50IiwiR2VuZXJhdG9yRXhwcmVzc2lvbiIsIkNvbXByZWhlbnNpb25FeHByZXNzaW9uIiwiYmxvY2tzIiwiZmlsdGVyIiwiQ29tcHJlaGVuc2lvbkJsb2NrIiwib2YiLCJTcHJlYWRFbGVtZW50IiwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uIiwidGFnIiwicXVhc2kiLCJUZW1wbGF0ZUVsZW1lbnQiLCJUZW1wbGF0ZUxpdGVyYWwiLCJxdWFzaXMiLCJNb2R1bGVTcGVjaWZpZXIiLCJJbXBvcnRFeHByZXNzaW9uIiwiZmxhZyIsInJlcGxhY2VSaWdodCIsImdlbmVyYXRlSW50ZXJuYWwiLCJjb2RlZ2VuIiwiZ2VuZXJhdGUiLCJvcHRpb25zIiwiZGVmYXVsdE9wdGlvbnMiLCJwYWlyIiwiZXhwb3J0cyIsImJyb3dzZXIiLCJnbG9iYWwiLCJtYXAiLCJ0b1N0cmluZ1dpdGhTb3VyY2VNYXAiLCJmaWxlIiwic291cmNlUm9vdCIsInNvdXJjZUNvbnRlbnQiLCJzZXRTb3VyY2VDb250ZW50IiwidmVyc2lvbiIsImF0dGFjaENvbW1lbnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/escodegen/escodegen.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/escodegen/package.json":
/*!*************************************************!*\
  !*** ../../node_modules/escodegen/package.json ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"escodegen","description":"ECMAScript code generator","homepage":"http://github.com/estools/escodegen","main":"escodegen.js","bin":{"esgenerate":"./bin/esgenerate.js","escodegen":"./bin/escodegen.js"},"files":["LICENSE.BSD","README.md","bin","escodegen.js","package.json"],"version":"2.1.0","engines":{"node":">=6.0"},"maintainers":[{"name":"Yusuke Suzuki","email":"utatane.tea@gmail.com","web":"http://github.com/Constellation"}],"repository":{"type":"git","url":"http://github.com/estools/escodegen.git"},"dependencies":{"estraverse":"^5.2.0","esutils":"^2.0.2","esprima":"^4.0.1"},"optionalDependencies":{"source-map":"~0.6.1"},"devDependencies":{"acorn":"^8.0.4","bluebird":"^3.4.7","bower-registry-client":"^1.0.0","chai":"^4.2.0","chai-exclude":"^2.0.2","commonjs-everywhere":"^0.9.7","gulp":"^4.0.2","gulp-eslint":"^6.0.0","gulp-mocha":"^7.0.2","minimist":"^1.2.5","optionator":"^0.9.1","semver":"^7.3.4"},"license":"BSD-2-Clause","scripts":{"test":"gulp travis","unit-test":"gulp test","lint":"gulp lint","release":"node tools/release.js","build-min":"./node_modules/.bin/cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js","build":"./node_modules/.bin/cjsify -a path: tools/entry-point.js > escodegen.browser.js"}}');

/***/ })

};
;