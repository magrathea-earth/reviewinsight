"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pac-proxy-agent";
exports.ids = ["vendor-chunks/pac-proxy-agent"];
exports.modules = {

/***/ "(rsc)/../../node_modules/pac-proxy-agent/dist/index.js":
/*!********************************************************!*\
  !*** ../../node_modules/pac-proxy-agent/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PacProxyAgent = void 0;\nconst net = __importStar(__webpack_require__(/*! net */ \"net\"));\nconst tls = __importStar(__webpack_require__(/*! tls */ \"tls\"));\nconst crypto = __importStar(__webpack_require__(/*! crypto */ \"crypto\"));\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/../../node_modules/debug/src/index.js\"));\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst agent_base_1 = __webpack_require__(/*! agent-base */ \"(rsc)/../../node_modules/agent-base/dist/index.js\");\nconst get_uri_1 = __webpack_require__(/*! get-uri */ \"(rsc)/../../node_modules/get-uri/dist/index.js\");\nconst pac_resolver_1 = __webpack_require__(/*! pac-resolver */ \"(rsc)/../../node_modules/pac-resolver/dist/index.js\");\nconst quickjs_emscripten_1 = __webpack_require__(/*! @tootallnate/quickjs-emscripten */ \"(rsc)/../../node_modules/@tootallnate/quickjs-emscripten/dist/index.js\");\nconst debug = (0, debug_1.default)(\"pac-proxy-agent\");\nconst setServernameFromNonIpHost = (options)=>{\n    if (options.servername === undefined && options.host && !net.isIP(options.host)) {\n        return {\n            ...options,\n            servername: options.host\n        };\n    }\n    return options;\n};\n/**\n * The `PacProxyAgent` class.\n *\n * A few different \"protocol\" modes are supported (supported protocols are\n * backed by the `get-uri` module):\n *\n *   - \"pac+data\", \"data\" - refers to an embedded \"data:\" URI\n *   - \"pac+file\", \"file\" - refers to a local file\n *   - \"pac+ftp\", \"ftp\" - refers to a file located on an FTP server\n *   - \"pac+http\", \"http\" - refers to an HTTP endpoint\n *   - \"pac+https\", \"https\" - refers to an HTTPS endpoint\n */ class PacProxyAgent extends agent_base_1.Agent {\n    constructor(uri, opts){\n        super(opts);\n        this.clearResolverPromise = ()=>{\n            this.resolverPromise = undefined;\n        };\n        // Strip the \"pac+\" prefix\n        const uriStr = typeof uri === \"string\" ? uri : uri.href;\n        this.uri = new url_1.URL(uriStr.replace(/^pac\\+/i, \"\"));\n        debug(\"Creating PacProxyAgent with URI %o\", this.uri.href);\n        // @ts-expect-error Not sure why TS is complaining hereâ€¦\n        this.opts = {\n            ...opts\n        };\n        this.cache = undefined;\n        this.resolver = undefined;\n        this.resolverHash = \"\";\n        this.resolverPromise = undefined;\n        // For `PacResolver`\n        if (!this.opts.filename) {\n            this.opts.filename = this.uri.href;\n        }\n    }\n    /**\n     * Loads the PAC proxy file from the source if necessary, and returns\n     * a generated `FindProxyForURL()` resolver function to use.\n     */ getResolver() {\n        if (!this.resolverPromise) {\n            this.resolverPromise = this.loadResolver();\n            this.resolverPromise.then(this.clearResolverPromise, this.clearResolverPromise);\n        }\n        return this.resolverPromise;\n    }\n    async loadResolver() {\n        try {\n            // (Re)load the contents of the PAC file URI\n            const [qjs, code] = await Promise.all([\n                (0, quickjs_emscripten_1.getQuickJS)(),\n                this.loadPacFile()\n            ]);\n            // Create a sha1 hash of the JS code\n            const hash = crypto.createHash(\"sha1\").update(code).digest(\"hex\");\n            if (this.resolver && this.resolverHash === hash) {\n                debug(\"Same sha1 hash for code - contents have not changed, reusing previous proxy resolver\");\n                return this.resolver;\n            }\n            // Cache the resolver\n            debug(\"Creating new proxy resolver instance\");\n            this.resolver = (0, pac_resolver_1.createPacResolver)(qjs, code, this.opts);\n            // Store that sha1 hash for future comparison purposes\n            this.resolverHash = hash;\n            return this.resolver;\n        } catch (err) {\n            if (this.resolver && err.code === \"ENOTMODIFIED\") {\n                debug(\"Got ENOTMODIFIED response, reusing previous proxy resolver\");\n                return this.resolver;\n            }\n            throw err;\n        }\n    }\n    /**\n     * Loads the contents of the PAC proxy file.\n     *\n     * @api private\n     */ async loadPacFile() {\n        debug(\"Loading PAC file: %o\", this.uri);\n        const rs = await (0, get_uri_1.getUri)(this.uri, {\n            ...this.opts,\n            cache: this.cache\n        });\n        debug(\"Got `Readable` instance for URI\");\n        this.cache = rs;\n        const buf = await (0, agent_base_1.toBuffer)(rs);\n        debug(\"Read %o byte PAC file from URI\", buf.length);\n        return buf.toString(\"utf8\");\n    }\n    /**\n     * Called when the node-core HTTP client library is creating a new HTTP request.\n     */ async connect(req, opts) {\n        const { secureEndpoint } = opts;\n        const isWebSocket = req.getHeader(\"upgrade\") === \"websocket\";\n        // First, get a generated `FindProxyForURL()` function,\n        // either cached or retrieved from the source\n        const resolver = await this.getResolver();\n        // Calculate the `url` parameter\n        const protocol = secureEndpoint ? \"https:\" : \"http:\";\n        const host = opts.host && net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;\n        const defaultPort = secureEndpoint ? 443 : 80;\n        const url = Object.assign(new url_1.URL(req.path, `${protocol}//${host}`), defaultPort ? undefined : {\n            port: opts.port\n        });\n        debug(\"url: %s\", url);\n        let result = await resolver(url);\n        // Default to \"DIRECT\" if a falsey value was returned (or nothing)\n        if (!result) {\n            result = \"DIRECT\";\n        }\n        const proxies = String(result).trim().split(/\\s*;\\s*/g).filter(Boolean);\n        if (this.opts.fallbackToDirect && !proxies.includes(\"DIRECT\")) {\n            proxies.push(\"DIRECT\");\n        }\n        for (const proxy of proxies){\n            let agent = null;\n            let socket = null;\n            const [type, target] = proxy.split(/\\s+/);\n            debug(\"Attempting to use proxy: %o\", proxy);\n            if (type === \"DIRECT\") {\n                // Direct connection to the destination endpoint\n                if (secureEndpoint) {\n                    socket = tls.connect(setServernameFromNonIpHost(opts));\n                } else {\n                    socket = net.connect(opts);\n                }\n            } else if (type === \"SOCKS\" || type === \"SOCKS5\") {\n                // Use a SOCKSv5h proxy\n                const { SocksProxyAgent } = await Promise.resolve().then(()=>__importStar(__webpack_require__(/*! socks-proxy-agent */ \"(rsc)/../../node_modules/socks-proxy-agent/dist/index.js\")));\n                agent = new SocksProxyAgent(`socks://${target}`, this.opts);\n            } else if (type === \"SOCKS4\") {\n                // Use a SOCKSv4a proxy\n                const { SocksProxyAgent } = await Promise.resolve().then(()=>__importStar(__webpack_require__(/*! socks-proxy-agent */ \"(rsc)/../../node_modules/socks-proxy-agent/dist/index.js\")));\n                agent = new SocksProxyAgent(`socks4a://${target}`, this.opts);\n            } else if (type === \"PROXY\" || type === \"HTTP\" || type === \"HTTPS\") {\n                // Use an HTTP or HTTPS proxy\n                // http://dev.chromium.org/developers/design-documents/secure-web-proxy\n                const proxyURL = `${type === \"HTTPS\" ? \"https\" : \"http\"}://${target}`;\n                if (secureEndpoint || isWebSocket) {\n                    const { HttpsProxyAgent } = await Promise.resolve().then(()=>__importStar(__webpack_require__(/*! https-proxy-agent */ \"(rsc)/../../node_modules/https-proxy-agent/dist/index.js\")));\n                    agent = new HttpsProxyAgent(proxyURL, this.opts);\n                } else {\n                    const { HttpProxyAgent } = await Promise.resolve().then(()=>__importStar(__webpack_require__(/*! http-proxy-agent */ \"(rsc)/../../node_modules/http-proxy-agent/dist/index.js\")));\n                    agent = new HttpProxyAgent(proxyURL, this.opts);\n                }\n            }\n            try {\n                if (socket) {\n                    // \"DIRECT\" connection, wait for connection confirmation\n                    await (0, events_1.once)(socket, \"connect\");\n                    req.emit(\"proxy\", {\n                        proxy,\n                        socket\n                    });\n                    return socket;\n                }\n                if (agent) {\n                    const s = await agent.connect(req, opts);\n                    if (!(s instanceof net.Socket)) {\n                        throw new Error(\"Expected a `net.Socket` to be returned from agent\");\n                    }\n                    req.emit(\"proxy\", {\n                        proxy,\n                        socket: s\n                    });\n                    return s;\n                }\n                throw new Error(`Could not determine proxy type for: ${proxy}`);\n            } catch (err) {\n                debug(\"Got error for proxy %o: %o\", proxy, err);\n                req.emit(\"proxy\", {\n                    proxy,\n                    error: err\n                });\n            }\n        }\n        throw new Error(`Failed to establish a socket connection to proxies: ${JSON.stringify(proxies)}`);\n    }\n}\nPacProxyAgent.protocols = [\n    \"pac+data\",\n    \"pac+file\",\n    \"pac+ftp\",\n    \"pac+http\",\n    \"pac+https\"\n];\nexports.PacProxyAgent = PacProxyAgent; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3BhYy1wcm94eS1hZ2VudC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcscUJBQXFCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsa0JBQWtCLElBQU1mLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVjLENBQUM7SUFDekZoQixPQUFPYyxjQUFjLENBQUNaLEdBQUcsV0FBVztRQUFFVSxZQUFZO1FBQU1LLE9BQU9EO0lBQUU7QUFDckUsSUFBSyxTQUFTZCxDQUFDLEVBQUVjLENBQUM7SUFDZGQsQ0FBQyxDQUFDLFVBQVUsR0FBR2M7QUFDbkI7QUFDQSxJQUFJRSxlQUFlLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFB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LE9BQU9BO2dCQUNYO2dCQUNBLE1BQU0sSUFBSUUsTUFBTSxDQUFDLG9DQUFvQyxFQUFFZCxNQUFNLENBQUM7WUFDbEUsRUFDQSxPQUFPNUIsS0FBSztnQkFDUm5DLE1BQU0sOEJBQThCK0QsT0FBTzVCO2dCQUMzQ1EsSUFBSStCLElBQUksQ0FBQyxTQUFTO29CQUFFWDtvQkFBT2UsT0FBTzNDO2dCQUFJO1lBQzFDO1FBQ0o7UUFDQSxNQUFNLElBQUkwQyxNQUFNLENBQUMsb0RBQW9ELEVBQUVFLEtBQUtDLFNBQVMsQ0FBQzFCLFNBQVMsQ0FBQztJQUNwRztBQUNKO0FBQ0FsRSxjQUFjNkYsU0FBUyxHQUFHO0lBQ3RCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNEOUYscUJBQXFCLEdBQUdDLGVBQ3hCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvcGFjLXByb3h5LWFnZW50L2Rpc3QvaW5kZXguanM/YTZiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYWNQcm94eUFnZW50ID0gdm9pZCAwO1xuY29uc3QgbmV0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJuZXRcIikpO1xuY29uc3QgdGxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJ0bHNcIikpO1xuY29uc3QgY3J5cHRvID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJjcnlwdG9cIikpO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgYWdlbnRfYmFzZV8xID0gcmVxdWlyZShcImFnZW50LWJhc2VcIik7XG5jb25zdCBnZXRfdXJpXzEgPSByZXF1aXJlKFwiZ2V0LXVyaVwiKTtcbmNvbnN0IHBhY19yZXNvbHZlcl8xID0gcmVxdWlyZShcInBhYy1yZXNvbHZlclwiKTtcbmNvbnN0IHF1aWNranNfZW1zY3JpcHRlbl8xID0gcmVxdWlyZShcIkB0b290YWxsbmF0ZS9xdWlja2pzLWVtc2NyaXB0ZW5cIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKCdwYWMtcHJveHktYWdlbnQnKTtcbmNvbnN0IHNldFNlcnZlcm5hbWVGcm9tTm9uSXBIb3N0ID0gKG9wdGlvbnMpID0+IHtcbiAgICBpZiAob3B0aW9ucy5zZXJ2ZXJuYW1lID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgb3B0aW9ucy5ob3N0ICYmXG4gICAgICAgICFuZXQuaXNJUChvcHRpb25zLmhvc3QpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgc2VydmVybmFtZTogb3B0aW9ucy5ob3N0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG4vKipcbiAqIFRoZSBgUGFjUHJveHlBZ2VudGAgY2xhc3MuXG4gKlxuICogQSBmZXcgZGlmZmVyZW50IFwicHJvdG9jb2xcIiBtb2RlcyBhcmUgc3VwcG9ydGVkIChzdXBwb3J0ZWQgcHJvdG9jb2xzIGFyZVxuICogYmFja2VkIGJ5IHRoZSBgZ2V0LXVyaWAgbW9kdWxlKTpcbiAqXG4gKiAgIC0gXCJwYWMrZGF0YVwiLCBcImRhdGFcIiAtIHJlZmVycyB0byBhbiBlbWJlZGRlZCBcImRhdGE6XCIgVVJJXG4gKiAgIC0gXCJwYWMrZmlsZVwiLCBcImZpbGVcIiAtIHJlZmVycyB0byBhIGxvY2FsIGZpbGVcbiAqICAgLSBcInBhYytmdHBcIiwgXCJmdHBcIiAtIHJlZmVycyB0byBhIGZpbGUgbG9jYXRlZCBvbiBhbiBGVFAgc2VydmVyXG4gKiAgIC0gXCJwYWMraHR0cFwiLCBcImh0dHBcIiAtIHJlZmVycyB0byBhbiBIVFRQIGVuZHBvaW50XG4gKiAgIC0gXCJwYWMraHR0cHNcIiwgXCJodHRwc1wiIC0gcmVmZXJzIHRvIGFuIEhUVFBTIGVuZHBvaW50XG4gKi9cbmNsYXNzIFBhY1Byb3h5QWdlbnQgZXh0ZW5kcyBhZ2VudF9iYXNlXzEuQWdlbnQge1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgb3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgdGhpcy5jbGVhclJlc29sdmVyUHJvbWlzZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZXJQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICAvLyBTdHJpcCB0aGUgXCJwYWMrXCIgcHJlZml4XG4gICAgICAgIGNvbnN0IHVyaVN0ciA9IHR5cGVvZiB1cmkgPT09ICdzdHJpbmcnID8gdXJpIDogdXJpLmhyZWY7XG4gICAgICAgIHRoaXMudXJpID0gbmV3IHVybF8xLlVSTCh1cmlTdHIucmVwbGFjZSgvXnBhY1xcKy9pLCAnJykpO1xuICAgICAgICBkZWJ1ZygnQ3JlYXRpbmcgUGFjUHJveHlBZ2VudCB3aXRoIFVSSSAlbycsIHRoaXMudXJpLmhyZWYpO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5vdCBzdXJlIHdoeSBUUyBpcyBjb21wbGFpbmluZyBoZXJl4oCmXG4gICAgICAgIHRoaXMub3B0cyA9IHsgLi4ub3B0cyB9O1xuICAgICAgICB0aGlzLmNhY2hlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJlc29sdmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJlc29sdmVySGFzaCA9ICcnO1xuICAgICAgICB0aGlzLnJlc29sdmVyUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gRm9yIGBQYWNSZXNvbHZlcmBcbiAgICAgICAgaWYgKCF0aGlzLm9wdHMuZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMub3B0cy5maWxlbmFtZSA9IHRoaXMudXJpLmhyZWY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIFBBQyBwcm94eSBmaWxlIGZyb20gdGhlIHNvdXJjZSBpZiBuZWNlc3NhcnksIGFuZCByZXR1cm5zXG4gICAgICogYSBnZW5lcmF0ZWQgYEZpbmRQcm94eUZvclVSTCgpYCByZXNvbHZlciBmdW5jdGlvbiB0byB1c2UuXG4gICAgICovXG4gICAgZ2V0UmVzb2x2ZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZXNvbHZlclByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZXJQcm9taXNlID0gdGhpcy5sb2FkUmVzb2x2ZXIoKTtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZXJQcm9taXNlLnRoZW4odGhpcy5jbGVhclJlc29sdmVyUHJvbWlzZSwgdGhpcy5jbGVhclJlc29sdmVyUHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZXJQcm9taXNlO1xuICAgIH1cbiAgICBhc3luYyBsb2FkUmVzb2x2ZXIoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyAoUmUpbG9hZCB0aGUgY29udGVudHMgb2YgdGhlIFBBQyBmaWxlIFVSSVxuICAgICAgICAgICAgY29uc3QgW3FqcywgY29kZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgKDAsIHF1aWNranNfZW1zY3JpcHRlbl8xLmdldFF1aWNrSlMpKCksXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkUGFjRmlsZSgpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzaGExIGhhc2ggb2YgdGhlIEpTIGNvZGVcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShjb2RlKS5kaWdlc3QoJ2hleCcpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzb2x2ZXIgJiYgdGhpcy5yZXNvbHZlckhhc2ggPT09IGhhc2gpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnU2FtZSBzaGExIGhhc2ggZm9yIGNvZGUgLSBjb250ZW50cyBoYXZlIG5vdCBjaGFuZ2VkLCByZXVzaW5nIHByZXZpb3VzIHByb3h5IHJlc29sdmVyJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDYWNoZSB0aGUgcmVzb2x2ZXJcbiAgICAgICAgICAgIGRlYnVnKCdDcmVhdGluZyBuZXcgcHJveHkgcmVzb2x2ZXIgaW5zdGFuY2UnKTtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZXIgPSAoMCwgcGFjX3Jlc29sdmVyXzEuY3JlYXRlUGFjUmVzb2x2ZXIpKHFqcywgY29kZSwgdGhpcy5vcHRzKTtcbiAgICAgICAgICAgIC8vIFN0b3JlIHRoYXQgc2hhMSBoYXNoIGZvciBmdXR1cmUgY29tcGFyaXNvbiBwdXJwb3Nlc1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlckhhc2ggPSBoYXNoO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzb2x2ZXIgJiZcbiAgICAgICAgICAgICAgICBlcnIuY29kZSA9PT0gJ0VOT1RNT0RJRklFRCcpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnR290IEVOT1RNT0RJRklFRCByZXNwb25zZSwgcmV1c2luZyBwcmV2aW91cyBwcm94eSByZXNvbHZlcicpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBjb250ZW50cyBvZiB0aGUgUEFDIHByb3h5IGZpbGUuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBsb2FkUGFjRmlsZSgpIHtcbiAgICAgICAgZGVidWcoJ0xvYWRpbmcgUEFDIGZpbGU6ICVvJywgdGhpcy51cmkpO1xuICAgICAgICBjb25zdCBycyA9IGF3YWl0ICgwLCBnZXRfdXJpXzEuZ2V0VXJpKSh0aGlzLnVyaSwgeyAuLi50aGlzLm9wdHMsIGNhY2hlOiB0aGlzLmNhY2hlIH0pO1xuICAgICAgICBkZWJ1ZygnR290IGBSZWFkYWJsZWAgaW5zdGFuY2UgZm9yIFVSSScpO1xuICAgICAgICB0aGlzLmNhY2hlID0gcnM7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGF3YWl0ICgwLCBhZ2VudF9iYXNlXzEudG9CdWZmZXIpKHJzKTtcbiAgICAgICAgZGVidWcoJ1JlYWQgJW8gYnl0ZSBQQUMgZmlsZSBmcm9tIFVSSScsIGJ1Zi5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBub2RlLWNvcmUgSFRUUCBjbGllbnQgbGlicmFyeSBpcyBjcmVhdGluZyBhIG5ldyBIVFRQIHJlcXVlc3QuXG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdChyZXEsIG9wdHMpIHtcbiAgICAgICAgY29uc3QgeyBzZWN1cmVFbmRwb2ludCB9ID0gb3B0cztcbiAgICAgICAgY29uc3QgaXNXZWJTb2NrZXQgPSByZXEuZ2V0SGVhZGVyKCd1cGdyYWRlJykgPT09ICd3ZWJzb2NrZXQnO1xuICAgICAgICAvLyBGaXJzdCwgZ2V0IGEgZ2VuZXJhdGVkIGBGaW5kUHJveHlGb3JVUkwoKWAgZnVuY3Rpb24sXG4gICAgICAgIC8vIGVpdGhlciBjYWNoZWQgb3IgcmV0cmlldmVkIGZyb20gdGhlIHNvdXJjZVxuICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IHRoaXMuZ2V0UmVzb2x2ZXIoKTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBgdXJsYCBwYXJhbWV0ZXJcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSBzZWN1cmVFbmRwb2ludCA/ICdodHRwczonIDogJ2h0dHA6JztcbiAgICAgICAgY29uc3QgaG9zdCA9IG9wdHMuaG9zdCAmJiBuZXQuaXNJUHY2KG9wdHMuaG9zdCkgPyBgWyR7b3B0cy5ob3N0fV1gIDogb3B0cy5ob3N0O1xuICAgICAgICBjb25zdCBkZWZhdWx0UG9ydCA9IHNlY3VyZUVuZHBvaW50ID8gNDQzIDogODA7XG4gICAgICAgIGNvbnN0IHVybCA9IE9iamVjdC5hc3NpZ24obmV3IHVybF8xLlVSTChyZXEucGF0aCwgYCR7cHJvdG9jb2x9Ly8ke2hvc3R9YCksIGRlZmF1bHRQb3J0ID8gdW5kZWZpbmVkIDogeyBwb3J0OiBvcHRzLnBvcnQgfSk7XG4gICAgICAgIGRlYnVnKCd1cmw6ICVzJywgdXJsKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHJlc29sdmVyKHVybCk7XG4gICAgICAgIC8vIERlZmF1bHQgdG8gXCJESVJFQ1RcIiBpZiBhIGZhbHNleSB2YWx1ZSB3YXMgcmV0dXJuZWQgKG9yIG5vdGhpbmcpXG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSAnRElSRUNUJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm94aWVzID0gU3RyaW5nKHJlc3VsdClcbiAgICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAgIC5zcGxpdCgvXFxzKjtcXHMqL2cpXG4gICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmZhbGxiYWNrVG9EaXJlY3QgJiYgIXByb3hpZXMuaW5jbHVkZXMoJ0RJUkVDVCcpKSB7XG4gICAgICAgICAgICBwcm94aWVzLnB1c2goJ0RJUkVDVCcpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcHJveHkgb2YgcHJveGllcykge1xuICAgICAgICAgICAgbGV0IGFnZW50ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBzb2NrZXQgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgW3R5cGUsIHRhcmdldF0gPSBwcm94eS5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgICAgZGVidWcoJ0F0dGVtcHRpbmcgdG8gdXNlIHByb3h5OiAlbycsIHByb3h5KTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnRElSRUNUJykge1xuICAgICAgICAgICAgICAgIC8vIERpcmVjdCBjb25uZWN0aW9uIHRvIHRoZSBkZXN0aW5hdGlvbiBlbmRwb2ludFxuICAgICAgICAgICAgICAgIGlmIChzZWN1cmVFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQgPSB0bHMuY29ubmVjdChzZXRTZXJ2ZXJuYW1lRnJvbU5vbklwSG9zdChvcHRzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQgPSBuZXQuY29ubmVjdChvcHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnU09DS1MnIHx8IHR5cGUgPT09ICdTT0NLUzUnKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIGEgU09DS1N2NWggcHJveHlcbiAgICAgICAgICAgICAgICBjb25zdCB7IFNvY2tzUHJveHlBZ2VudCB9ID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBfX2ltcG9ydFN0YXIocmVxdWlyZSgnc29ja3MtcHJveHktYWdlbnQnKSkpO1xuICAgICAgICAgICAgICAgIGFnZW50ID0gbmV3IFNvY2tzUHJveHlBZ2VudChgc29ja3M6Ly8ke3RhcmdldH1gLCB0aGlzLm9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ1NPQ0tTNCcpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgYSBTT0NLU3Y0YSBwcm94eVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgU29ja3NQcm94eUFnZW50IH0gPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IF9faW1wb3J0U3RhcihyZXF1aXJlKCdzb2Nrcy1wcm94eS1hZ2VudCcpKSk7XG4gICAgICAgICAgICAgICAgYWdlbnQgPSBuZXcgU29ja3NQcm94eUFnZW50KGBzb2NrczRhOi8vJHt0YXJnZXR9YCwgdGhpcy5vcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdQUk9YWScgfHxcbiAgICAgICAgICAgICAgICB0eXBlID09PSAnSFRUUCcgfHxcbiAgICAgICAgICAgICAgICB0eXBlID09PSAnSFRUUFMnKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIGFuIEhUVFAgb3IgSFRUUFMgcHJveHlcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vZGV2LmNocm9taXVtLm9yZy9kZXZlbG9wZXJzL2Rlc2lnbi1kb2N1bWVudHMvc2VjdXJlLXdlYi1wcm94eVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3h5VVJMID0gYCR7dHlwZSA9PT0gJ0hUVFBTJyA/ICdodHRwcycgOiAnaHR0cCd9Oi8vJHt0YXJnZXR9YDtcbiAgICAgICAgICAgICAgICBpZiAoc2VjdXJlRW5kcG9pbnQgfHwgaXNXZWJTb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBIdHRwc1Byb3h5QWdlbnQgfSA9IGF3YWl0IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gX19pbXBvcnRTdGFyKHJlcXVpcmUoJ2h0dHBzLXByb3h5LWFnZW50JykpKTtcbiAgICAgICAgICAgICAgICAgICAgYWdlbnQgPSBuZXcgSHR0cHNQcm94eUFnZW50KHByb3h5VVJMLCB0aGlzLm9wdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBIdHRwUHJveHlBZ2VudCB9ID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBfX2ltcG9ydFN0YXIocmVxdWlyZSgnaHR0cC1wcm94eS1hZ2VudCcpKSk7XG4gICAgICAgICAgICAgICAgICAgIGFnZW50ID0gbmV3IEh0dHBQcm94eUFnZW50KHByb3h5VVJMLCB0aGlzLm9wdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvY2tldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBcIkRJUkVDVFwiIGNvbm5lY3Rpb24sIHdhaXQgZm9yIGNvbm5lY3Rpb24gY29uZmlybWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0ICgwLCBldmVudHNfMS5vbmNlKShzb2NrZXQsICdjb25uZWN0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5lbWl0KCdwcm94eScsIHsgcHJveHksIHNvY2tldCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFnZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBhd2FpdCBhZ2VudC5jb25uZWN0KHJlcSwgb3B0cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHMgaW5zdGFuY2VvZiBuZXQuU29ja2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIGBuZXQuU29ja2V0YCB0byBiZSByZXR1cm5lZCBmcm9tIGFnZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVxLmVtaXQoJ3Byb3h5JywgeyBwcm94eSwgc29ja2V0OiBzIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZGV0ZXJtaW5lIHByb3h5IHR5cGUgZm9yOiAke3Byb3h5fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdHb3QgZXJyb3IgZm9yIHByb3h5ICVvOiAlbycsIHByb3h5LCBlcnIpO1xuICAgICAgICAgICAgICAgIHJlcS5lbWl0KCdwcm94eScsIHsgcHJveHksIGVycm9yOiBlcnIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZXN0YWJsaXNoIGEgc29ja2V0IGNvbm5lY3Rpb24gdG8gcHJveGllczogJHtKU09OLnN0cmluZ2lmeShwcm94aWVzKX1gKTtcbiAgICB9XG59XG5QYWNQcm94eUFnZW50LnByb3RvY29scyA9IFtcbiAgICAncGFjK2RhdGEnLFxuICAgICdwYWMrZmlsZScsXG4gICAgJ3BhYytmdHAnLFxuICAgICdwYWMraHR0cCcsXG4gICAgJ3BhYytodHRwcycsXG5dO1xuZXhwb3J0cy5QYWNQcm94eUFnZW50ID0gUGFjUHJveHlBZ2VudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX3NldE1vZHVsZURlZmF1bHQiLCJ2IiwidmFsdWUiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJyZXN1bHQiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJfX2ltcG9ydERlZmF1bHQiLCJleHBvcnRzIiwiUGFjUHJveHlBZ2VudCIsIm5ldCIsInJlcXVpcmUiLCJ0bHMiLCJjcnlwdG8iLCJldmVudHNfMSIsImRlYnVnXzEiLCJ1cmxfMSIsImFnZW50X2Jhc2VfMSIsImdldF91cmlfMSIsInBhY19yZXNvbHZlcl8xIiwicXVpY2tqc19lbXNjcmlwdGVuXzEiLCJkZWJ1ZyIsImRlZmF1bHQiLCJzZXRTZXJ2ZXJuYW1lRnJvbU5vbklwSG9zdCIsIm9wdGlvbnMiLCJzZXJ2ZXJuYW1lIiwiaG9zdCIsImlzSVAiLCJBZ2VudCIsImNvbnN0cnVjdG9yIiwidXJpIiwib3B0cyIsImNsZWFyUmVzb2x2ZXJQcm9taXNlIiwicmVzb2x2ZXJQcm9taXNlIiwidXJpU3RyIiwiaHJlZiIsIlVSTCIsInJlcGxhY2UiLCJjYWNoZSIsInJlc29sdmVyIiwicmVzb2x2ZXJIYXNoIiwiZmlsZW5hbWUiLCJnZXRSZXNvbHZlciIsImxvYWRSZXNvbHZlciIsInRoZW4iLCJxanMiLCJjb2RlIiwiUHJvbWlzZSIsImFsbCIsImdldFF1aWNrSlMiLCJsb2FkUGFjRmlsZSIsImhhc2giLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiZGlnZXN0IiwiY3JlYXRlUGFjUmVzb2x2ZXIiLCJlcnIiLCJycyIsImdldFVyaSIsImJ1ZiIsInRvQnVmZmVyIiwibGVuZ3RoIiwidG9TdHJpbmciLCJjb25uZWN0IiwicmVxIiwic2VjdXJlRW5kcG9pbnQiLCJpc1dlYlNvY2tldCIsImdldEhlYWRlciIsInByb3RvY29sIiwiaXNJUHY2IiwiZGVmYXVsdFBvcnQiLCJ1cmwiLCJhc3NpZ24iLCJwYXRoIiwicG9ydCIsInByb3hpZXMiLCJTdHJpbmciLCJ0cmltIiwic3BsaXQiLCJmaWx0ZXIiLCJCb29sZWFuIiwiZmFsbGJhY2tUb0RpcmVjdCIsImluY2x1ZGVzIiwicHVzaCIsInByb3h5IiwiYWdlbnQiLCJzb2NrZXQiLCJ0eXBlIiwidGFyZ2V0IiwiU29ja3NQcm94eUFnZW50IiwicmVzb2x2ZSIsInByb3h5VVJMIiwiSHR0cHNQcm94eUFnZW50IiwiSHR0cFByb3h5QWdlbnQiLCJvbmNlIiwiZW1pdCIsInMiLCJTb2NrZXQiLCJFcnJvciIsImVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsInByb3RvY29scyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/pac-proxy-agent/dist/index.js\n");

/***/ })

};
;