"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/socks-proxy-agent";
exports.ids = ["vendor-chunks/socks-proxy-agent"];
exports.modules = {

/***/ "(rsc)/../../node_modules/socks-proxy-agent/dist/index.js":
/*!**********************************************************!*\
  !*** ../../node_modules/socks-proxy-agent/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SocksProxyAgent = void 0;\nconst socks_1 = __webpack_require__(/*! socks */ \"(rsc)/../../node_modules/socks/build/index.js\");\nconst agent_base_1 = __webpack_require__(/*! agent-base */ \"(rsc)/../../node_modules/agent-base/dist/index.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/../../node_modules/debug/src/index.js\"));\nconst dns = __importStar(__webpack_require__(/*! dns */ \"dns\"));\nconst net = __importStar(__webpack_require__(/*! net */ \"net\"));\nconst tls = __importStar(__webpack_require__(/*! tls */ \"tls\"));\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst debug = (0, debug_1.default)(\"socks-proxy-agent\");\nconst setServernameFromNonIpHost = (options)=>{\n    if (options.servername === undefined && options.host && !net.isIP(options.host)) {\n        return {\n            ...options,\n            servername: options.host\n        };\n    }\n    return options;\n};\nfunction parseSocksURL(url) {\n    let lookup = false;\n    let type = 5;\n    const host = url.hostname;\n    // From RFC 1928, Section 3: https://tools.ietf.org/html/rfc1928#section-3\n    // \"The SOCKS service is conventionally located on TCP port 1080\"\n    const port = parseInt(url.port, 10) || 1080;\n    // figure out if we want socks v4 or v5, based on the \"protocol\" used.\n    // Defaults to 5.\n    switch(url.protocol.replace(\":\", \"\")){\n        case \"socks4\":\n            lookup = true;\n            type = 4;\n            break;\n        // pass through\n        case \"socks4a\":\n            type = 4;\n            break;\n        case \"socks5\":\n            lookup = true;\n            type = 5;\n            break;\n        // pass through\n        case \"socks\":\n            type = 5;\n            break;\n        case \"socks5h\":\n            type = 5;\n            break;\n        default:\n            throw new TypeError(`A \"socks\" protocol must be specified! Got: ${String(url.protocol)}`);\n    }\n    const proxy = {\n        host,\n        port,\n        type\n    };\n    if (url.username) {\n        Object.defineProperty(proxy, \"userId\", {\n            value: decodeURIComponent(url.username),\n            enumerable: false\n        });\n    }\n    if (url.password != null) {\n        Object.defineProperty(proxy, \"password\", {\n            value: decodeURIComponent(url.password),\n            enumerable: false\n        });\n    }\n    return {\n        lookup,\n        proxy\n    };\n}\nclass SocksProxyAgent extends agent_base_1.Agent {\n    constructor(uri, opts){\n        super(opts);\n        const url = typeof uri === \"string\" ? new url_1.URL(uri) : uri;\n        const { proxy, lookup } = parseSocksURL(url);\n        this.shouldLookup = lookup;\n        this.proxy = proxy;\n        this.timeout = opts?.timeout ?? null;\n        this.socketOptions = opts?.socketOptions ?? null;\n    }\n    /**\n     * Initiates a SOCKS connection to the specified SOCKS proxy server,\n     * which in turn connects to the specified remote host and port.\n     */ async connect(req, opts) {\n        const { shouldLookup, proxy, timeout } = this;\n        if (!opts.host) {\n            throw new Error(\"No `host` defined!\");\n        }\n        let { host } = opts;\n        const { port, lookup: lookupFn = dns.lookup } = opts;\n        if (shouldLookup) {\n            // Client-side DNS resolution for \"4\" and \"5\" socks proxy versions.\n            host = await new Promise((resolve, reject)=>{\n                // Use the request's custom lookup, if one was configured:\n                lookupFn(host, {}, (err, res)=>{\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(res);\n                    }\n                });\n            });\n        }\n        const socksOpts = {\n            proxy,\n            destination: {\n                host,\n                port: typeof port === \"number\" ? port : parseInt(port, 10)\n            },\n            command: \"connect\",\n            timeout: timeout ?? undefined,\n            // @ts-expect-error the type supplied by socks for socket_options is wider\n            // than necessary since socks will always override the host and port\n            socket_options: this.socketOptions ?? undefined\n        };\n        const cleanup = (tlsSocket)=>{\n            req.destroy();\n            socket.destroy();\n            if (tlsSocket) tlsSocket.destroy();\n        };\n        debug(\"Creating socks proxy connection: %o\", socksOpts);\n        const { socket } = await socks_1.SocksClient.createConnection(socksOpts);\n        debug(\"Successfully created socks proxy connection\");\n        if (timeout !== null) {\n            socket.setTimeout(timeout);\n            socket.on(\"timeout\", ()=>cleanup());\n        }\n        if (opts.secureEndpoint) {\n            // The proxy is connecting to a TLS server, so upgrade\n            // this socket connection to a TLS connection.\n            debug(\"Upgrading socket connection to TLS\");\n            const tlsSocket = tls.connect({\n                ...omit(setServernameFromNonIpHost(opts), \"host\", \"path\", \"port\"),\n                socket\n            });\n            tlsSocket.once(\"error\", (error)=>{\n                debug(\"Socket TLS error\", error.message);\n                cleanup(tlsSocket);\n            });\n            return tlsSocket;\n        }\n        return socket;\n    }\n}\nSocksProxyAgent.protocols = [\n    \"socks\",\n    \"socks4\",\n    \"socks4a\",\n    \"socks5\",\n    \"socks5h\"\n];\nexports.SocksProxyAgent = SocksProxyAgent;\nfunction omit(obj, ...keys) {\n    const ret = {};\n    let key;\n    for(key in obj){\n        if (!keys.includes(key)) {\n            ret[key] = obj[key];\n        }\n    }\n    return ret;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3NvY2tzLXByb3h5LWFnZW50L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxxQkFBcUIsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxrQkFBa0IsSUFBTWYsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRWMsQ0FBQztJQUN6RmhCLE9BQU9jLGNBQWMsQ0FBQ1osR0FBRyxXQUFXO1FBQUVVLFlBQVk7UUFBTUssT0FBT0Q7SUFBRTtBQUNyRSxJQUFLLFNBQVNkLENBQUMsRUFBRWMsQ0FBQztJQUNkZCxDQUFDLENBQUMsVUFBVSxHQUFHYztBQUNuQjtBQUNBLElBQUlFLGVBQWUsQ0FBQyxNQUFHLEtBQUssT0FBRyxF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LENBQUNHLElBQUk7UUFDdkI7SUFDSjtJQUNBLE9BQU9EO0FBQ1gsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL3NvY2tzLXByb3h5LWFnZW50L2Rpc3QvaW5kZXguanM/MzQ4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Tb2Nrc1Byb3h5QWdlbnQgPSB2b2lkIDA7XG5jb25zdCBzb2Nrc18xID0gcmVxdWlyZShcInNvY2tzXCIpO1xuY29uc3QgYWdlbnRfYmFzZV8xID0gcmVxdWlyZShcImFnZW50LWJhc2VcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBkbnMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImRuc1wiKSk7XG5jb25zdCBuZXQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIm5ldFwiKSk7XG5jb25zdCB0bHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInRsc1wiKSk7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKCdzb2Nrcy1wcm94eS1hZ2VudCcpO1xuY29uc3Qgc2V0U2VydmVybmFtZUZyb21Ob25JcEhvc3QgPSAob3B0aW9ucykgPT4ge1xuICAgIGlmIChvcHRpb25zLnNlcnZlcm5hbWUgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBvcHRpb25zLmhvc3QgJiZcbiAgICAgICAgIW5ldC5pc0lQKG9wdGlvbnMuaG9zdCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBzZXJ2ZXJuYW1lOiBvcHRpb25zLmhvc3QsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufTtcbmZ1bmN0aW9uIHBhcnNlU29ja3NVUkwodXJsKSB7XG4gICAgbGV0IGxvb2t1cCA9IGZhbHNlO1xuICAgIGxldCB0eXBlID0gNTtcbiAgICBjb25zdCBob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgIC8vIEZyb20gUkZDIDE5MjgsIFNlY3Rpb24gMzogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzE5Mjgjc2VjdGlvbi0zXG4gICAgLy8gXCJUaGUgU09DS1Mgc2VydmljZSBpcyBjb252ZW50aW9uYWxseSBsb2NhdGVkIG9uIFRDUCBwb3J0IDEwODBcIlxuICAgIGNvbnN0IHBvcnQgPSBwYXJzZUludCh1cmwucG9ydCwgMTApIHx8IDEwODA7XG4gICAgLy8gZmlndXJlIG91dCBpZiB3ZSB3YW50IHNvY2tzIHY0IG9yIHY1LCBiYXNlZCBvbiB0aGUgXCJwcm90b2NvbFwiIHVzZWQuXG4gICAgLy8gRGVmYXVsdHMgdG8gNS5cbiAgICBzd2l0Y2ggKHVybC5wcm90b2NvbC5yZXBsYWNlKCc6JywgJycpKSB7XG4gICAgICAgIGNhc2UgJ3NvY2tzNCc6XG4gICAgICAgICAgICBsb29rdXAgPSB0cnVlO1xuICAgICAgICAgICAgdHlwZSA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gcGFzcyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ3NvY2tzNGEnOlxuICAgICAgICAgICAgdHlwZSA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc29ja3M1JzpcbiAgICAgICAgICAgIGxvb2t1cCA9IHRydWU7XG4gICAgICAgICAgICB0eXBlID0gNTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBwYXNzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnc29ja3MnOiAvLyBubyB2ZXJzaW9uIHNwZWNpZmllZCwgZGVmYXVsdCB0byA1aFxuICAgICAgICAgICAgdHlwZSA9IDU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc29ja3M1aCc6XG4gICAgICAgICAgICB0eXBlID0gNTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSBcInNvY2tzXCIgcHJvdG9jb2wgbXVzdCBiZSBzcGVjaWZpZWQhIEdvdDogJHtTdHJpbmcodXJsLnByb3RvY29sKX1gKTtcbiAgICB9XG4gICAgY29uc3QgcHJveHkgPSB7XG4gICAgICAgIGhvc3QsXG4gICAgICAgIHBvcnQsXG4gICAgICAgIHR5cGUsXG4gICAgfTtcbiAgICBpZiAodXJsLnVzZXJuYW1lKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm94eSwgJ3VzZXJJZCcsIHtcbiAgICAgICAgICAgIHZhbHVlOiBkZWNvZGVVUklDb21wb25lbnQodXJsLnVzZXJuYW1lKSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHVybC5wYXNzd29yZCAhPSBudWxsKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm94eSwgJ3Bhc3N3b3JkJywge1xuICAgICAgICAgICAgdmFsdWU6IGRlY29kZVVSSUNvbXBvbmVudCh1cmwucGFzc3dvcmQpLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4geyBsb29rdXAsIHByb3h5IH07XG59XG5jbGFzcyBTb2Nrc1Byb3h5QWdlbnQgZXh0ZW5kcyBhZ2VudF9iYXNlXzEuQWdlbnQge1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgb3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgY29uc3QgdXJsID0gdHlwZW9mIHVyaSA9PT0gJ3N0cmluZycgPyBuZXcgdXJsXzEuVVJMKHVyaSkgOiB1cmk7XG4gICAgICAgIGNvbnN0IHsgcHJveHksIGxvb2t1cCB9ID0gcGFyc2VTb2Nrc1VSTCh1cmwpO1xuICAgICAgICB0aGlzLnNob3VsZExvb2t1cCA9IGxvb2t1cDtcbiAgICAgICAgdGhpcy5wcm94eSA9IHByb3h5O1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBvcHRzPy50aW1lb3V0ID8/IG51bGw7XG4gICAgICAgIHRoaXMuc29ja2V0T3B0aW9ucyA9IG9wdHM/LnNvY2tldE9wdGlvbnMgPz8gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhdGVzIGEgU09DS1MgY29ubmVjdGlvbiB0byB0aGUgc3BlY2lmaWVkIFNPQ0tTIHByb3h5IHNlcnZlcixcbiAgICAgKiB3aGljaCBpbiB0dXJuIGNvbm5lY3RzIHRvIHRoZSBzcGVjaWZpZWQgcmVtb3RlIGhvc3QgYW5kIHBvcnQuXG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdChyZXEsIG9wdHMpIHtcbiAgICAgICAgY29uc3QgeyBzaG91bGRMb29rdXAsIHByb3h5LCB0aW1lb3V0IH0gPSB0aGlzO1xuICAgICAgICBpZiAoIW9wdHMuaG9zdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBgaG9zdGAgZGVmaW5lZCEnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBob3N0IH0gPSBvcHRzO1xuICAgICAgICBjb25zdCB7IHBvcnQsIGxvb2t1cDogbG9va3VwRm4gPSBkbnMubG9va3VwIH0gPSBvcHRzO1xuICAgICAgICBpZiAoc2hvdWxkTG9va3VwKSB7XG4gICAgICAgICAgICAvLyBDbGllbnQtc2lkZSBETlMgcmVzb2x1dGlvbiBmb3IgXCI0XCIgYW5kIFwiNVwiIHNvY2tzIHByb3h5IHZlcnNpb25zLlxuICAgICAgICAgICAgaG9zdCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHJlcXVlc3QncyBjdXN0b20gbG9va3VwLCBpZiBvbmUgd2FzIGNvbmZpZ3VyZWQ6XG4gICAgICAgICAgICAgICAgbG9va3VwRm4oaG9zdCwge30sIChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc29ja3NPcHRzID0ge1xuICAgICAgICAgICAgcHJveHksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjoge1xuICAgICAgICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgICAgICAgcG9ydDogdHlwZW9mIHBvcnQgPT09ICdudW1iZXInID8gcG9ydCA6IHBhcnNlSW50KHBvcnQsIDEwKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21tYW5kOiAnY29ubmVjdCcsXG4gICAgICAgICAgICB0aW1lb3V0OiB0aW1lb3V0ID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdGhlIHR5cGUgc3VwcGxpZWQgYnkgc29ja3MgZm9yIHNvY2tldF9vcHRpb25zIGlzIHdpZGVyXG4gICAgICAgICAgICAvLyB0aGFuIG5lY2Vzc2FyeSBzaW5jZSBzb2NrcyB3aWxsIGFsd2F5cyBvdmVycmlkZSB0aGUgaG9zdCBhbmQgcG9ydFxuICAgICAgICAgICAgc29ja2V0X29wdGlvbnM6IHRoaXMuc29ja2V0T3B0aW9ucyA/PyB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSAodGxzU29ja2V0KSA9PiB7XG4gICAgICAgICAgICByZXEuZGVzdHJveSgpO1xuICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGlmICh0bHNTb2NrZXQpXG4gICAgICAgICAgICAgICAgdGxzU29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgfTtcbiAgICAgICAgZGVidWcoJ0NyZWF0aW5nIHNvY2tzIHByb3h5IGNvbm5lY3Rpb246ICVvJywgc29ja3NPcHRzKTtcbiAgICAgICAgY29uc3QgeyBzb2NrZXQgfSA9IGF3YWl0IHNvY2tzXzEuU29ja3NDbGllbnQuY3JlYXRlQ29ubmVjdGlvbihzb2Nrc09wdHMpO1xuICAgICAgICBkZWJ1ZygnU3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgc29ja3MgcHJveHkgY29ubmVjdGlvbicpO1xuICAgICAgICBpZiAodGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc29ja2V0LnNldFRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICBzb2NrZXQub24oJ3RpbWVvdXQnLCAoKSA9PiBjbGVhbnVwKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnNlY3VyZUVuZHBvaW50KSB7XG4gICAgICAgICAgICAvLyBUaGUgcHJveHkgaXMgY29ubmVjdGluZyB0byBhIFRMUyBzZXJ2ZXIsIHNvIHVwZ3JhZGVcbiAgICAgICAgICAgIC8vIHRoaXMgc29ja2V0IGNvbm5lY3Rpb24gdG8gYSBUTFMgY29ubmVjdGlvbi5cbiAgICAgICAgICAgIGRlYnVnKCdVcGdyYWRpbmcgc29ja2V0IGNvbm5lY3Rpb24gdG8gVExTJyk7XG4gICAgICAgICAgICBjb25zdCB0bHNTb2NrZXQgPSB0bHMuY29ubmVjdCh7XG4gICAgICAgICAgICAgICAgLi4ub21pdChzZXRTZXJ2ZXJuYW1lRnJvbU5vbklwSG9zdChvcHRzKSwgJ2hvc3QnLCAncGF0aCcsICdwb3J0JyksXG4gICAgICAgICAgICAgICAgc29ja2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0bHNTb2NrZXQub25jZSgnZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnU29ja2V0IFRMUyBlcnJvcicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGNsZWFudXAodGxzU29ja2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRsc1NvY2tldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc29ja2V0O1xuICAgIH1cbn1cblNvY2tzUHJveHlBZ2VudC5wcm90b2NvbHMgPSBbXG4gICAgJ3NvY2tzJyxcbiAgICAnc29ja3M0JyxcbiAgICAnc29ja3M0YScsXG4gICAgJ3NvY2tzNScsXG4gICAgJ3NvY2tzNWgnLFxuXTtcbmV4cG9ydHMuU29ja3NQcm94eUFnZW50ID0gU29ja3NQcm94eUFnZW50O1xuZnVuY3Rpb24gb21pdChvYmosIC4uLmtleXMpIHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBsZXQga2V5O1xuICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICBpZiAoIWtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsInYiLCJ2YWx1ZSIsIl9faW1wb3J0U3RhciIsIm1vZCIsInJlc3VsdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIl9faW1wb3J0RGVmYXVsdCIsImV4cG9ydHMiLCJTb2Nrc1Byb3h5QWdlbnQiLCJzb2Nrc18xIiwicmVxdWlyZSIsImFnZW50X2Jhc2VfMSIsImRlYnVnXzEiLCJkbnMiLCJuZXQiLCJ0bHMiLCJ1cmxfMSIsImRlYnVnIiwiZGVmYXVsdCIsInNldFNlcnZlcm5hbWVGcm9tTm9uSXBIb3N0Iiwib3B0aW9ucyIsInNlcnZlcm5hbWUiLCJob3N0IiwiaXNJUCIsInBhcnNlU29ja3NVUkwiLCJ1cmwiLCJsb29rdXAiLCJ0eXBlIiwiaG9zdG5hbWUiLCJwb3J0IiwicGFyc2VJbnQiLCJwcm90b2NvbCIsInJlcGxhY2UiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJwcm94eSIsInVzZXJuYW1lIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicGFzc3dvcmQiLCJBZ2VudCIsImNvbnN0cnVjdG9yIiwidXJpIiwib3B0cyIsIlVSTCIsInNob3VsZExvb2t1cCIsInRpbWVvdXQiLCJzb2NrZXRPcHRpb25zIiwiY29ubmVjdCIsInJlcSIsIkVycm9yIiwibG9va3VwRm4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImVyciIsInJlcyIsInNvY2tzT3B0cyIsImRlc3RpbmF0aW9uIiwiY29tbWFuZCIsInNvY2tldF9vcHRpb25zIiwiY2xlYW51cCIsInRsc1NvY2tldCIsImRlc3Ryb3kiLCJzb2NrZXQiLCJTb2Nrc0NsaWVudCIsImNyZWF0ZUNvbm5lY3Rpb24iLCJzZXRUaW1lb3V0Iiwib24iLCJzZWN1cmVFbmRwb2ludCIsIm9taXQiLCJvbmNlIiwiZXJyb3IiLCJtZXNzYWdlIiwicHJvdG9jb2xzIiwib2JqIiwia2V5cyIsInJldCIsImtleSIsImluY2x1ZGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/socks-proxy-agent/dist/index.js\n");

/***/ })

};
;