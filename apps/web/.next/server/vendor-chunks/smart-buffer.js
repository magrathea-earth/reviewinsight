"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/smart-buffer";
exports.ids = ["vendor-chunks/smart-buffer"];
exports.modules = {

/***/ "(rsc)/../../node_modules/smart-buffer/build/smartbuffer.js":
/*!************************************************************!*\
  !*** ../../node_modules/smart-buffer/build/smartbuffer.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/../../node_modules/smart-buffer/build/utils.js\");\n// The default Buffer size if one is not provided.\nconst DEFAULT_SMARTBUFFER_SIZE = 4096;\n// The default string encoding to use for reading/writing strings.\nconst DEFAULT_SMARTBUFFER_ENCODING = \"utf8\";\nclass SmartBuffer {\n    /**\n     * Creates a new SmartBuffer instance.\n     *\n     * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.\n     */ constructor(options){\n        this.length = 0;\n        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;\n        this._writeOffset = 0;\n        this._readOffset = 0;\n        if (SmartBuffer.isSmartBufferOptions(options)) {\n            // Checks for encoding\n            if (options.encoding) {\n                utils_1.checkEncoding(options.encoding);\n                this._encoding = options.encoding;\n            }\n            // Checks for initial size length\n            if (options.size) {\n                if (utils_1.isFiniteInteger(options.size) && options.size > 0) {\n                    this._buff = Buffer.allocUnsafe(options.size);\n                } else {\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);\n                }\n            // Check for initial Buffer\n            } else if (options.buff) {\n                if (Buffer.isBuffer(options.buff)) {\n                    this._buff = options.buff;\n                    this.length = options.buff.length;\n                } else {\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);\n                }\n            } else {\n                this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n            }\n        } else {\n            // If something was passed but it's not a SmartBufferOptions object\n            if (typeof options !== \"undefined\") {\n                throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);\n            }\n            // Otherwise default to sane options\n            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n        }\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.\n     *\n     * @param size { Number } The size of the internal Buffer.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */ static fromSize(size, encoding) {\n        return new this({\n            size: size,\n            encoding: encoding\n        });\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.\n     *\n     * @param buffer { Buffer } The Buffer to use as the internal Buffer value.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */ static fromBuffer(buff, encoding) {\n        return new this({\n            buff: buff,\n            encoding: encoding\n        });\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.\n     *\n     * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.\n     */ static fromOptions(options) {\n        return new this(options);\n    }\n    /**\n     * Type checking function that determines if an object is a SmartBufferOptions object.\n     */ static isSmartBufferOptions(options) {\n        const castOptions = options;\n        return castOptions && (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined);\n    }\n    // Signed integers\n    /**\n     * Reads an Int8 value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readInt8(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);\n    }\n    /**\n     * Reads an Int16BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readInt16BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);\n    }\n    /**\n     * Reads an Int16LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readInt16LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);\n    }\n    /**\n     * Reads an Int32BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readInt32BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);\n    }\n    /**\n     * Reads an Int32LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readInt32LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);\n    }\n    /**\n     * Reads a BigInt64BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */ readBigInt64BE(offset) {\n        utils_1.bigIntAndBufferInt64Check(\"readBigInt64BE\");\n        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);\n    }\n    /**\n     * Reads a BigInt64LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */ readBigInt64LE(offset) {\n        utils_1.bigIntAndBufferInt64Check(\"readBigInt64LE\");\n        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);\n    }\n    /**\n     * Writes an Int8 value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeInt8(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n        return this;\n    }\n    /**\n     * Inserts an Int8 value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertInt8(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n    }\n    /**\n     * Writes an Int16BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeInt16BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n    }\n    /**\n     * Inserts an Int16BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertInt16BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n    }\n    /**\n     * Writes an Int16LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeInt16LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n    }\n    /**\n     * Inserts an Int16LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertInt16LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n    }\n    /**\n     * Writes an Int32BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeInt32BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n    }\n    /**\n     * Inserts an Int32BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertInt32BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n    }\n    /**\n     * Writes an Int32LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeInt32LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n    }\n    /**\n     * Inserts an Int32LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertInt32LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n    }\n    /**\n     * Writes a BigInt64BE value to the current write position (or at optional offset).\n     *\n     * @param value { BigInt } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeBigInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigInt64BE\");\n        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigInt64BE value at the given offset value.\n     *\n     * @param value { BigInt } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertBigInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigInt64BE\");\n        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n    }\n    /**\n     * Writes a BigInt64LE value to the current write position (or at optional offset).\n     *\n     * @param value { BigInt } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeBigInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigInt64LE\");\n        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n    }\n    /**\n     * Inserts a Int64LE value at the given offset value.\n     *\n     * @param value { BigInt } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertBigInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigInt64LE\");\n        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n    }\n    // Unsigned Integers\n    /**\n     * Reads an UInt8 value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readUInt8(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);\n    }\n    /**\n     * Reads an UInt16BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readUInt16BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);\n    }\n    /**\n     * Reads an UInt16LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readUInt16LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);\n    }\n    /**\n     * Reads an UInt32BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readUInt32BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);\n    }\n    /**\n     * Reads an UInt32LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readUInt32LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);\n    }\n    /**\n     * Reads a BigUInt64BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */ readBigUInt64BE(offset) {\n        utils_1.bigIntAndBufferInt64Check(\"readBigUInt64BE\");\n        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);\n    }\n    /**\n     * Reads a BigUInt64LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */ readBigUInt64LE(offset) {\n        utils_1.bigIntAndBufferInt64Check(\"readBigUInt64LE\");\n        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);\n    }\n    /**\n     * Writes an UInt8 value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeUInt8(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n    }\n    /**\n     * Inserts an UInt8 value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertUInt8(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n    }\n    /**\n     * Writes an UInt16BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeUInt16BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n    }\n    /**\n     * Inserts an UInt16BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertUInt16BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n    }\n    /**\n     * Writes an UInt16LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeUInt16LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n    }\n    /**\n     * Inserts an UInt16LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertUInt16LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n    }\n    /**\n     * Writes an UInt32BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeUInt32BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n    }\n    /**\n     * Inserts an UInt32BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertUInt32BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n    }\n    /**\n     * Writes an UInt32LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeUInt32LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n    }\n    /**\n     * Inserts an UInt32LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertUInt32LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n    }\n    /**\n     * Writes a BigUInt64BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeBigUInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigUInt64BE\");\n        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigUInt64BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertBigUInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigUInt64BE\");\n        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n    }\n    /**\n     * Writes a BigUInt64LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeBigUInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigUInt64LE\");\n        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigUInt64LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertBigUInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigUInt64LE\");\n        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n    }\n    // Floating Point\n    /**\n     * Reads an FloatBE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readFloatBE(offset) {\n        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);\n    }\n    /**\n     * Reads an FloatLE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readFloatLE(offset) {\n        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);\n    }\n    /**\n     * Writes a FloatBE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeFloatBE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n    }\n    /**\n     * Inserts a FloatBE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertFloatBE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n    }\n    /**\n     * Writes a FloatLE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeFloatLE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n    }\n    /**\n     * Inserts a FloatLE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertFloatLE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n    }\n    // Double Floating Point\n    /**\n     * Reads an DoublEBE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readDoubleBE(offset) {\n        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);\n    }\n    /**\n     * Reads an DoubleLE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readDoubleLE(offset) {\n        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);\n    }\n    /**\n     * Writes a DoubleBE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeDoubleBE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n    }\n    /**\n     * Inserts a DoubleBE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertDoubleBE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n    }\n    /**\n     * Writes a DoubleLE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeDoubleLE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n    }\n    /**\n     * Inserts a DoubleLE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertDoubleLE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n    }\n    // Strings\n    /**\n     * Reads a String from the current read position.\n     *\n     * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for\n     *             the string (Defaults to instance level encoding).\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n     *\n     * @return { String }\n     */ readString(arg1, encoding) {\n        let lengthVal;\n        // Length provided\n        if (typeof arg1 === \"number\") {\n            utils_1.checkLengthValue(arg1);\n            lengthVal = Math.min(arg1, this.length - this._readOffset);\n        } else {\n            encoding = arg1;\n            lengthVal = this.length - this._readOffset;\n        }\n        // Check encoding\n        if (typeof encoding !== \"undefined\") {\n            utils_1.checkEncoding(encoding);\n        }\n        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);\n        this._readOffset += lengthVal;\n        return value;\n    }\n    /**\n     * Inserts a String\n     *\n     * @param value { String } The String value to insert.\n     * @param offset { Number } The offset to insert the string at.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */ insertString(value, offset, encoding) {\n        utils_1.checkOffsetValue(offset);\n        return this._handleString(value, true, offset, encoding);\n    }\n    /**\n     * Writes a String\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */ writeString(value, arg2, encoding) {\n        return this._handleString(value, false, arg2, encoding);\n    }\n    /**\n     * Reads a null-terminated String from the current read position.\n     *\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n     *\n     * @return { String }\n     */ readStringNT(encoding) {\n        if (typeof encoding !== \"undefined\") {\n            utils_1.checkEncoding(encoding);\n        }\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for(let i = this._readOffset; i < this.length; i++){\n            if (this._buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read string value\n        const value = this._buff.slice(this._readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this._readOffset = nullPos + 1;\n        return value.toString(encoding || this._encoding);\n    }\n    /**\n     * Inserts a null-terminated String.\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */ insertStringNT(value, offset, encoding) {\n        utils_1.checkOffsetValue(offset);\n        // Write Values\n        this.insertString(value, offset, encoding);\n        this.insertUInt8(0x00, offset + value.length);\n        return this;\n    }\n    /**\n     * Writes a null-terminated String.\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */ writeStringNT(value, arg2, encoding) {\n        // Write Values\n        this.writeString(value, arg2, encoding);\n        this.writeUInt8(0x00, typeof arg2 === \"number\" ? arg2 + value.length : this.writeOffset);\n        return this;\n    }\n    // Buffers\n    /**\n     * Reads a Buffer from the internal read position.\n     *\n     * @param length { Number } The length of data to read as a Buffer.\n     *\n     * @return { Buffer }\n     */ readBuffer(length) {\n        if (typeof length !== \"undefined\") {\n            utils_1.checkLengthValue(length);\n        }\n        const lengthVal = typeof length === \"number\" ? length : this.length;\n        const endPoint = Math.min(this.length, this._readOffset + lengthVal);\n        // Read buffer value\n        const value = this._buff.slice(this._readOffset, endPoint);\n        // Increment internal Buffer read offset\n        this._readOffset = endPoint;\n        return value;\n    }\n    /**\n     * Writes a Buffer to the current write position.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */ insertBuffer(value, offset) {\n        utils_1.checkOffsetValue(offset);\n        return this._handleBuffer(value, true, offset);\n    }\n    /**\n     * Writes a Buffer to the current write position.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */ writeBuffer(value, offset) {\n        return this._handleBuffer(value, false, offset);\n    }\n    /**\n     * Reads a null-terminated Buffer from the current read poisiton.\n     *\n     * @return { Buffer }\n     */ readBufferNT() {\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for(let i = this._readOffset; i < this.length; i++){\n            if (this._buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read value\n        const value = this._buff.slice(this._readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this._readOffset = nullPos + 1;\n        return value;\n    }\n    /**\n     * Inserts a null-terminated Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */ insertBufferNT(value, offset) {\n        utils_1.checkOffsetValue(offset);\n        // Write Values\n        this.insertBuffer(value, offset);\n        this.insertUInt8(0x00, offset + value.length);\n        return this;\n    }\n    /**\n     * Writes a null-terminated Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */ writeBufferNT(value, offset) {\n        // Checks for valid numberic value;\n        if (typeof offset !== \"undefined\") {\n            utils_1.checkOffsetValue(offset);\n        }\n        // Write Values\n        this.writeBuffer(value, offset);\n        this.writeUInt8(0x00, typeof offset === \"number\" ? offset + value.length : this._writeOffset);\n        return this;\n    }\n    /**\n     * Clears the SmartBuffer instance to its original empty state.\n     */ clear() {\n        this._writeOffset = 0;\n        this._readOffset = 0;\n        this.length = 0;\n        return this;\n    }\n    /**\n     * Gets the remaining data left to be read from the SmartBuffer instance.\n     *\n     * @return { Number }\n     */ remaining() {\n        return this.length - this._readOffset;\n    }\n    /**\n     * Gets the current read offset value of the SmartBuffer instance.\n     *\n     * @return { Number }\n     */ get readOffset() {\n        return this._readOffset;\n    }\n    /**\n     * Sets the read offset value of the SmartBuffer instance.\n     *\n     * @param offset { Number } - The offset value to set.\n     */ set readOffset(offset) {\n        utils_1.checkOffsetValue(offset);\n        // Check for bounds.\n        utils_1.checkTargetOffset(offset, this);\n        this._readOffset = offset;\n    }\n    /**\n     * Gets the current write offset value of the SmartBuffer instance.\n     *\n     * @return { Number }\n     */ get writeOffset() {\n        return this._writeOffset;\n    }\n    /**\n     * Sets the write offset value of the SmartBuffer instance.\n     *\n     * @param offset { Number } - The offset value to set.\n     */ set writeOffset(offset) {\n        utils_1.checkOffsetValue(offset);\n        // Check for bounds.\n        utils_1.checkTargetOffset(offset, this);\n        this._writeOffset = offset;\n    }\n    /**\n     * Gets the currently set string encoding of the SmartBuffer instance.\n     *\n     * @return { BufferEncoding } The string Buffer encoding currently set.\n     */ get encoding() {\n        return this._encoding;\n    }\n    /**\n     * Sets the string encoding of the SmartBuffer instance.\n     *\n     * @param encoding { BufferEncoding } The string Buffer encoding to set.\n     */ set encoding(encoding) {\n        utils_1.checkEncoding(encoding);\n        this._encoding = encoding;\n    }\n    /**\n     * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)\n     *\n     * @return { Buffer } The Buffer value.\n     */ get internalBuffer() {\n        return this._buff;\n    }\n    /**\n     * Gets the value of the internal managed Buffer (Includes managed data only)\n     *\n     * @param { Buffer }\n     */ toBuffer() {\n        return this._buff.slice(0, this.length);\n    }\n    /**\n     * Gets the String value of the internal managed Buffer\n     *\n     * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).\n     */ toString(encoding) {\n        const encodingVal = typeof encoding === \"string\" ? encoding : this._encoding;\n        // Check for invalid encoding.\n        utils_1.checkEncoding(encodingVal);\n        return this._buff.toString(encodingVal, 0, this.length);\n    }\n    /**\n     * Destroys the SmartBuffer instance.\n     */ destroy() {\n        this.clear();\n        return this;\n    }\n    /**\n     * Handles inserting and writing strings.\n     *\n     * @param value { String } The String value to insert.\n     * @param isInsert { Boolean } True if inserting a string, false if writing.\n     * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     */ _handleString(value, isInsert, arg3, encoding) {\n        let offsetVal = this._writeOffset;\n        let encodingVal = this._encoding;\n        // Check for offset\n        if (typeof arg3 === \"number\") {\n            offsetVal = arg3;\n        // Check for encoding\n        } else if (typeof arg3 === \"string\") {\n            utils_1.checkEncoding(arg3);\n            encodingVal = arg3;\n        }\n        // Check for encoding (third param)\n        if (typeof encoding === \"string\") {\n            utils_1.checkEncoding(encoding);\n            encodingVal = encoding;\n        }\n        // Calculate bytelength of string.\n        const byteLength = Buffer.byteLength(value, encodingVal);\n        // Ensure there is enough internal Buffer capacity.\n        if (isInsert) {\n            this.ensureInsertable(byteLength, offsetVal);\n        } else {\n            this._ensureWriteable(byteLength, offsetVal);\n        }\n        // Write value\n        this._buff.write(value, offsetVal, byteLength, encodingVal);\n        // Increment internal Buffer write offset;\n        if (isInsert) {\n            this._writeOffset += byteLength;\n        } else {\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\n            if (typeof arg3 === \"number\") {\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);\n            } else {\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n                this._writeOffset += byteLength;\n            }\n        }\n        return this;\n    }\n    /**\n     * Handles writing or insert of a Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     */ _handleBuffer(value, isInsert, offset) {\n        const offsetVal = typeof offset === \"number\" ? offset : this._writeOffset;\n        // Ensure there is enough internal Buffer capacity.\n        if (isInsert) {\n            this.ensureInsertable(value.length, offsetVal);\n        } else {\n            this._ensureWriteable(value.length, offsetVal);\n        }\n        // Write buffer value\n        value.copy(this._buff, offsetVal);\n        // Increment internal Buffer write offset;\n        if (isInsert) {\n            this._writeOffset += value.length;\n        } else {\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\n            if (typeof offset === \"number\") {\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);\n            } else {\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n                this._writeOffset += value.length;\n            }\n        }\n        return this;\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to read data.\n     *\n     * @param length { Number } The length of the data that needs to be read.\n     * @param offset { Number } The offset of the data that needs to be read.\n     */ ensureReadable(length, offset) {\n        // Offset value defaults to managed read offset.\n        let offsetVal = this._readOffset;\n        // If an offset was provided, use it.\n        if (typeof offset !== \"undefined\") {\n            // Checks for valid numberic value;\n            utils_1.checkOffsetValue(offset);\n            // Overide with custom offset.\n            offsetVal = offset;\n        }\n        // Checks if offset is below zero, or the offset+length offset is beyond the total length of the managed data.\n        if (offsetVal < 0 || offsetVal + length > this.length) {\n            throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to insert data.\n     *\n     * @param dataLength { Number } The length of the data that needs to be written.\n     * @param offset { Number } The offset of the data to be written.\n     */ ensureInsertable(dataLength, offset) {\n        // Checks for valid numberic value;\n        utils_1.checkOffsetValue(offset);\n        // Ensure there is enough internal Buffer capacity.\n        this._ensureCapacity(this.length + dataLength);\n        // If an offset was provided and its not the very end of the buffer, copy data into appropriate location in regards to the offset.\n        if (offset < this.length) {\n            this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);\n        }\n        // Adjust tracked smart buffer length\n        if (offset + dataLength > this.length) {\n            this.length = offset + dataLength;\n        } else {\n            this.length += dataLength;\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to write data.\n     *\n     * @param dataLength { Number } The length of the data that needs to be written.\n     * @param offset { Number } The offset of the data to be written (defaults to writeOffset).\n     */ _ensureWriteable(dataLength, offset) {\n        const offsetVal = typeof offset === \"number\" ? offset : this._writeOffset;\n        // Ensure enough capacity to write data.\n        this._ensureCapacity(offsetVal + dataLength);\n        // Adjust SmartBuffer length (if offset + length is larger than managed length, adjust length)\n        if (offsetVal + dataLength > this.length) {\n            this.length = offsetVal + dataLength;\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to write at least the given amount of data.\n     *\n     * @param minLength { Number } The minimum length of the data needs to be written.\n     */ _ensureCapacity(minLength) {\n        const oldLength = this._buff.length;\n        if (minLength > oldLength) {\n            let data = this._buff;\n            let newLength = oldLength * 3 / 2 + 1;\n            if (newLength < minLength) {\n                newLength = minLength;\n            }\n            this._buff = Buffer.allocUnsafe(newLength);\n            data.copy(this._buff, 0, 0, oldLength);\n        }\n    }\n    /**\n     * Reads a numeric number value using the provided function.\n     *\n     * @typeparam T { number | bigint } The type of the value to be read\n     *\n     * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes read.\n     * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.\n     *\n     * @returns { T } the number value\n     */ _readNumberValue(func, byteSize, offset) {\n        this.ensureReadable(byteSize, offset);\n        // Call Buffer.readXXXX();\n        const value = func.call(this._buff, typeof offset === \"number\" ? offset : this._readOffset);\n        // Adjust internal read offset if an optional read offset was not provided.\n        if (typeof offset === \"undefined\") {\n            this._readOffset += byteSize;\n        }\n        return value;\n    }\n    /**\n     * Inserts a numeric number value based on the given offset and value.\n     *\n     * @typeparam T { number | bigint } The type of the value to be written\n     *\n     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes written.\n     * @param value { T } The number value to write.\n     * @param offset { Number } the offset to write the number at (REQUIRED).\n     *\n     * @returns SmartBuffer this buffer\n     */ _insertNumberValue(func, byteSize, value, offset) {\n        // Check for invalid offset values.\n        utils_1.checkOffsetValue(offset);\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this.ensureInsertable(byteSize, offset);\n        // Call buffer.writeXXXX();\n        func.call(this._buff, value, offset);\n        // Adjusts internally managed write offset.\n        this._writeOffset += byteSize;\n        return this;\n    }\n    /**\n     * Writes a numeric number value based on the given offset and value.\n     *\n     * @typeparam T { number | bigint } The type of the value to be written\n     *\n     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes written.\n     * @param value { T } The number value to write.\n     * @param offset { Number } the offset to write the number at (REQUIRED).\n     *\n     * @returns SmartBuffer this buffer\n     */ _writeNumberValue(func, byteSize, value, offset) {\n        // If an offset was provided, validate it.\n        if (typeof offset === \"number\") {\n            // Check if we're writing beyond the bounds of the managed data.\n            if (offset < 0) {\n                throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);\n            }\n            utils_1.checkOffsetValue(offset);\n        }\n        // Default to writeOffset if no offset value was given.\n        const offsetVal = typeof offset === \"number\" ? offset : this._writeOffset;\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this._ensureWriteable(byteSize, offsetVal);\n        func.call(this._buff, value, offsetVal);\n        // If an offset was given, check to see if we wrote beyond the current writeOffset.\n        if (typeof offset === \"number\") {\n            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);\n        } else {\n            // If no numeric offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n            this._writeOffset += byteSize;\n        }\n        return this;\n    }\n}\nexports.SmartBuffer = SmartBuffer; //# sourceMappingURL=smartbuffer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWJ1ZmZlci9idWlsZC9zbWFydGJ1ZmZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxVQUFVQyxtQkFBT0EsQ0FBQyxxRUFBUztBQUNqQyxrREFBa0Q7QUFDbEQsTUFBTUMsMkJBQTJCO0FBQ2pDLGtFQUFrRTtBQUNsRSxNQUFNQywrQkFBK0I7QUFDckMsTUFBTUM7SUFDRjs7OztLQUlDLEdBQ0RDLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsU0FBUyxHQUFHTDtRQUNqQixJQUFJLENBQUNNLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJTixZQUFZTyxvQkFBb0IsQ0FBQ0wsVUFBVTtZQUMzQyxzQkFBc0I7WUFDdEIsSUFBSUEsUUFBUU0sUUFBUSxFQUFFO2dCQUNsQlosUUFBUWEsYUFBYSxDQUFDUCxRQUFRTSxRQUFRO2dCQUN0QyxJQUFJLENBQUNKLFNBQVMsR0FBR0YsUUFBUU0sUUFBUTtZQUNyQztZQUNBLGlDQUFpQztZQUNqQyxJQUFJTixRQUFRUSxJQUFJLEVBQUU7Z0JBQ2QsSUFBSWQsUUFBUWUsZUFBZSxDQUFDVCxRQUFRUSxJQUFJLEtBQUtSLFFBQVFRLElBQUksR0FBRyxHQUFHO29CQUMzRCxJQUFJLENBQUNFLEtBQUssR0FBR0MsT0FBT0MsV0FBVyxDQUFDWixRQUFRUSxJQUFJO2dCQUNoRCxPQUNLO29CQUNELE1BQU0sSUFBSUssTUFBTW5CLFFBQVFvQixNQUFNLENBQUNDLHdCQUF3QjtnQkFDM0Q7WUFDQSwyQkFBMkI7WUFDL0IsT0FDSyxJQUFJZixRQUFRZ0IsSUFBSSxFQUFFO2dCQUNuQixJQUFJTCxPQUFPTSxRQUFRLENBQUNqQixRQUFRZ0IsSUFBSSxHQUFHO29CQUMvQixJQUFJLENBQUNOLEtBQUss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QUEyQjtRQUMzQitHLEtBQUtFLElBQUksQ0FBQyxJQUFJLENBQUNqSSxLQUFLLEVBQUVqQixPQUFPaUM7UUFDN0IsMkNBQTJDO1FBQzNDLElBQUksQ0FBQ3ZCLFlBQVksSUFBSXVJO1FBQ3JCLE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7Ozs7Ozs7O0tBV0MsR0FDRHJHLGtCQUFrQm9HLElBQUksRUFBRUMsUUFBUSxFQUFFakosS0FBSyxFQUFFaUMsTUFBTSxFQUFFO1FBQzdDLDBDQUEwQztRQUMxQyxJQUFJLE9BQU9BLFdBQVcsVUFBVTtZQUM1QixnRUFBZ0U7WUFDaEUsSUFBSUEsU0FBUyxHQUFHO2dCQUNaLE1BQU0sSUFBSWIsTUFBTW5CLFFBQVFvQixNQUFNLENBQUM4SCwyQkFBMkI7WUFDOUQ7WUFDQWxKLFFBQVFvRyxnQkFBZ0IsQ0FBQ3BFO1FBQzdCO1FBQ0EsdURBQXVEO1FBQ3ZELE1BQU1nRyxZQUFZLE9BQU9oRyxXQUFXLFdBQVdBLFNBQVMsSUFBSSxDQUFDdkIsWUFBWTtRQUN6RSwwRUFBMEU7UUFDMUUsSUFBSSxDQUFDMEgsZ0JBQWdCLENBQUNhLFVBQVVoQjtRQUNoQ2UsS0FBS0UsSUFBSSxDQUFDLElBQUksQ0FBQ2pJLEtBQUssRUFBRWpCLE9BQU9pSTtRQUM3QixtRkFBbUY7UUFDbkYsSUFBSSxPQUFPaEcsV0FBVyxVQUFVO1lBQzVCLElBQUksQ0FBQ3ZCLFlBQVksR0FBR3NGLEtBQUtzQyxHQUFHLENBQUMsSUFBSSxDQUFDNUgsWUFBWSxFQUFFdUgsWUFBWWdCO1FBQ2hFLE9BQ0s7WUFDRCxtR0FBbUc7WUFDbkcsSUFBSSxDQUFDdkksWUFBWSxJQUFJdUk7UUFDekI7UUFDQSxPQUFPLElBQUk7SUFDZjtBQUNKO0FBQ0FsSixtQkFBbUIsR0FBR00sYUFDdEIsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9zbWFydC1idWZmZXIvYnVpbGQvc21hcnRidWZmZXIuanM/MjE3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8vIFRoZSBkZWZhdWx0IEJ1ZmZlciBzaXplIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQuXG5jb25zdCBERUZBVUxUX1NNQVJUQlVGRkVSX1NJWkUgPSA0MDk2O1xuLy8gVGhlIGRlZmF1bHQgc3RyaW5nIGVuY29kaW5nIHRvIHVzZSBmb3IgcmVhZGluZy93cml0aW5nIHN0cmluZ3MuXG5jb25zdCBERUZBVUxUX1NNQVJUQlVGRkVSX0VOQ09ESU5HID0gJ3V0ZjgnO1xuY2xhc3MgU21hcnRCdWZmZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7IFNtYXJ0QnVmZmVyT3B0aW9ucyB9IFRoZSBTbWFydEJ1ZmZlck9wdGlvbnMgdG8gYXBwbHkgdG8gdGhpcyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fZW5jb2RpbmcgPSBERUZBVUxUX1NNQVJUQlVGRkVSX0VOQ09ESU5HO1xuICAgICAgICB0aGlzLl93cml0ZU9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuX3JlYWRPZmZzZXQgPSAwO1xuICAgICAgICBpZiAoU21hcnRCdWZmZXIuaXNTbWFydEJ1ZmZlck9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgICAgICAgIC8vIENoZWNrcyBmb3IgZW5jb2RpbmdcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgICAgICAgICAgICAgdXRpbHNfMS5jaGVja0VuY29kaW5nKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrcyBmb3IgaW5pdGlhbCBzaXplIGxlbmd0aFxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsc18xLmlzRmluaXRlSW50ZWdlcihvcHRpb25zLnNpemUpICYmIG9wdGlvbnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVmZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShvcHRpb25zLnNpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWxzXzEuRVJST1JTLklOVkFMSURfU01BUlRCVUZGRVJfU0laRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBpbml0aWFsIEJ1ZmZlclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5idWZmKSB7XG4gICAgICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLmJ1ZmYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmYgPSBvcHRpb25zLmJ1ZmY7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gb3B0aW9ucy5idWZmLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsc18xLkVSUk9SUy5JTlZBTElEX1NNQVJUQlVGRkVSX0JVRkZFUik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVmZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShERUZBVUxUX1NNQVJUQlVGRkVSX1NJWkUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgc29tZXRoaW5nIHdhcyBwYXNzZWQgYnV0IGl0J3Mgbm90IGEgU21hcnRCdWZmZXJPcHRpb25zIG9iamVjdFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsc18xLkVSUk9SUy5JTlZBTElEX1NNQVJUQlVGRkVSX09CSkVDVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgZGVmYXVsdCB0byBzYW5lIG9wdGlvbnNcbiAgICAgICAgICAgIHRoaXMuX2J1ZmYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoREVGQVVMVF9TTUFSVEJVRkZFUl9TSVpFKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNtYXJ0QnVmZmVyIGluc3RhbmNlIHdpdGggdGhlIHByb3ZpZGVkIGludGVybmFsIEJ1ZmZlciBzaXplIGFuZCBvcHRpb25hbCBlbmNvZGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaXplIHsgTnVtYmVyIH0gVGhlIHNpemUgb2YgdGhlIGludGVybmFsIEJ1ZmZlci5cbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvciBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7IFNtYXJ0QnVmZmVyIH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVNpemUoc2l6ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHtcbiAgICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgICBlbmNvZGluZzogZW5jb2RpbmdcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU21hcnRCdWZmZXIgaW5zdGFuY2Ugd2l0aCB0aGUgcHJvdmlkZWQgQnVmZmVyIGFuZCBvcHRpb25hbCBlbmNvZGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBidWZmZXIgeyBCdWZmZXIgfSBUaGUgQnVmZmVyIHRvIHVzZSBhcyB0aGUgaW50ZXJuYWwgQnVmZmVyIHZhbHVlLlxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB7IFN0cmluZyB9IFRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UgZm9yIHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgU21hcnRCdWZmZXIgfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQnVmZmVyKGJ1ZmYsIGVuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyh7XG4gICAgICAgICAgICBidWZmOiBidWZmLFxuICAgICAgICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNtYXJ0QnVmZmVyIGluc3RhbmNlIHdpdGggdGhlIHByb3ZpZGVkIFNtYXJ0QnVmZmVyT3B0aW9ucyBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgeyBTbWFydEJ1ZmZlck9wdGlvbnMgfSBUaGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBjcmVhdGluZyB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUeXBlIGNoZWNraW5nIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyBpZiBhbiBvYmplY3QgaXMgYSBTbWFydEJ1ZmZlck9wdGlvbnMgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1NtYXJ0QnVmZmVyT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNhc3RPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgcmV0dXJuIChjYXN0T3B0aW9ucyAmJlxuICAgICAgICAgICAgKGNhc3RPcHRpb25zLmVuY29kaW5nICE9PSB1bmRlZmluZWQgfHwgY2FzdE9wdGlvbnMuc2l6ZSAhPT0gdW5kZWZpbmVkIHx8IGNhc3RPcHRpb25zLmJ1ZmYgIT09IHVuZGVmaW5lZCkpO1xuICAgIH1cbiAgICAvLyBTaWduZWQgaW50ZWdlcnNcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBJbnQ4IHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkSW50OChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4LCAxLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBJbnQxNkJFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkSW50MTZCRShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFLCAyLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBJbnQxNkxFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkSW50MTZMRShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFLCAyLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBJbnQzMkJFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkSW50MzJCRShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFLCA0LCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBJbnQzMkxFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkSW50MzJMRShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFLCA0LCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIEJpZ0ludDY0QkUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uIG9yIGFuIG9wdGlvbmFsbHkgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gcmVhZCBkYXRhIGZyb20gKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4geyBCaWdJbnQgfVxuICAgICAqL1xuICAgIHJlYWRCaWdJbnQ2NEJFKG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3JlYWRCaWdJbnQ2NEJFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRSwgOCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBCaWdJbnQ2NExFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgQmlnSW50IH1cbiAgICAgKi9cbiAgICByZWFkQmlnSW50NjRMRShvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCdyZWFkQmlnSW50NjRMRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUsIDgsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBJbnQ4IHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlSW50OCh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDgsIDEsIHZhbHVlLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBJbnQ4IHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRJbnQ4KHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4LCAxLCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGFuIEludDE2QkUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVJbnQxNkJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUsIDIsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIEludDE2QkUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydEludDE2QkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUsIDIsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gSW50MTZMRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUludDE2TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSwgMiwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gSW50MTZMRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0SW50MTZMRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSwgMiwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBJbnQzMkJFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlSW50MzJCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBJbnQzMkJFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRJbnQzMkJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGFuIEludDMyTEUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVJbnQzMkxFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUsIDQsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIEludDMyTEUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydEludDMyTEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUsIDQsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBCaWdJbnQ2NEJFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgQmlnSW50IH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlQmlnSW50NjRCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuYmlnSW50QW5kQnVmZmVySW50NjRDaGVjaygnd3JpdGVCaWdJbnQ2NEJFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFLCA4LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhIEJpZ0ludDY0QkUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IEJpZ0ludCB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydEJpZ0ludDY0QkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3dyaXRlQmlnSW50NjRCRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0QkUsIDgsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBCaWdJbnQ2NExFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgQmlnSW50IH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlQmlnSW50NjRMRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuYmlnSW50QW5kQnVmZmVySW50NjRDaGVjaygnd3JpdGVCaWdJbnQ2NExFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFLCA4LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhIEludDY0TEUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IEJpZ0ludCB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydEJpZ0ludDY0TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3dyaXRlQmlnSW50NjRMRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUsIDgsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvLyBVbnNpZ25lZCBJbnRlZ2Vyc1xuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIFVJbnQ4IHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkVUludDgob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDgsIDEsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIFVJbnQxNkJFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkVUludDE2QkUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUsIDIsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIFVJbnQxNkxFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkVUludDE2TEUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUsIDIsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIFVJbnQzMkJFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkVUludDMyQkUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUsIDQsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIFVJbnQzMkxFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkVUludDMyTEUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUsIDQsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgQmlnVUludDY0QkUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uIG9yIGFuIG9wdGlvbmFsbHkgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gcmVhZCBkYXRhIGZyb20gKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4geyBCaWdJbnQgfVxuICAgICAqL1xuICAgIHJlYWRCaWdVSW50NjRCRShvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCdyZWFkQmlnVUludDY0QkUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRCRSwgOCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBCaWdVSW50NjRMRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IEJpZ0ludCB9XG4gICAgICovXG4gICAgcmVhZEJpZ1VJbnQ2NExFKG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3JlYWRCaWdVSW50NjRMRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NExFLCA4LCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gVUludDggdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCwgMSwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gVUludDggdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydFVJbnQ4KHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCwgMSwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBVSW50MTZCRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZVVJbnQxNkJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFLCAyLCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBVSW50MTZCRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0VUludDE2QkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFLCAyLCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGFuIFVJbnQxNkxFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlVUludDE2TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUsIDIsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIFVJbnQxNkxFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRVSW50MTZMRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUsIDIsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gVUludDMyQkUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVVSW50MzJCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gVUludDMyQkUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydFVJbnQzMkJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBVSW50MzJMRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZVVJbnQzMkxFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBVSW50MzJMRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0VUludDMyTEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgQmlnVUludDY0QkUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVCaWdVSW50NjRCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuYmlnSW50QW5kQnVmZmVySW50NjRDaGVjaygnd3JpdGVCaWdVSW50NjRCRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUsIDgsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgQmlnVUludDY0QkUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydEJpZ1VJbnQ2NEJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCd3cml0ZUJpZ1VJbnQ2NEJFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUsIDgsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBCaWdVSW50NjRMRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUJpZ1VJbnQ2NExFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCd3cml0ZUJpZ1VJbnQ2NExFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSwgOCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBCaWdVSW50NjRMRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0QmlnVUludDY0TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3dyaXRlQmlnVUludDY0TEUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSwgOCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8vIEZsb2F0aW5nIFBvaW50XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gRmxvYXRCRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZEZsb2F0QkUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSwgNCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gRmxvYXRMRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZEZsb2F0TEUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSwgNCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgRmxvYXRCRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUZsb2F0QkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBGbG9hdEJFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRGbG9hdEJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgRmxvYXRMRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUZsb2F0TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBGbG9hdExFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRGbG9hdExFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gRG91YmxlIEZsb2F0aW5nIFBvaW50XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gRG91YmxFQkUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uIG9yIGFuIG9wdGlvbmFsbHkgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gcmVhZCBkYXRhIGZyb20gKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4geyBOdW1iZXIgfVxuICAgICAqL1xuICAgIHJlYWREb3VibGVCRShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSwgOCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gRG91YmxlTEUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uIG9yIGFuIG9wdGlvbmFsbHkgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gcmVhZCBkYXRhIGZyb20gKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4geyBOdW1iZXIgfVxuICAgICAqL1xuICAgIHJlYWREb3VibGVMRShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSwgOCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgRG91YmxlQkUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVEb3VibGVCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSwgOCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBEb3VibGVCRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0RG91YmxlQkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFLCA4LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgRG91YmxlTEUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVEb3VibGVMRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSwgOCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBEb3VibGVMRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0RG91YmxlTEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFLCA4LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gU3RyaW5nc1xuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgU3RyaW5nIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmcxIHsgTnVtYmVyIHwgU3RyaW5nIH0gVGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkIGFzIGEgU3RyaW5nLCBvciB0aGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvclxuICAgICAqICAgICAgICAgICAgIHRoZSBzdHJpbmcgKERlZmF1bHRzIHRvIGluc3RhbmNlIGxldmVsIGVuY29kaW5nKS5cbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvciB0aGUgc3RyaW5nIChEZWZhdWx0cyB0byBpbnN0YW5jZSBsZXZlbCBlbmNvZGluZykuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgU3RyaW5nIH1cbiAgICAgKi9cbiAgICByZWFkU3RyaW5nKGFyZzEsIGVuY29kaW5nKSB7XG4gICAgICAgIGxldCBsZW5ndGhWYWw7XG4gICAgICAgIC8vIExlbmd0aCBwcm92aWRlZFxuICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrTGVuZ3RoVmFsdWUoYXJnMSk7XG4gICAgICAgICAgICBsZW5ndGhWYWwgPSBNYXRoLm1pbihhcmcxLCB0aGlzLmxlbmd0aCAtIHRoaXMuX3JlYWRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5jb2RpbmcgPSBhcmcxO1xuICAgICAgICAgICAgbGVuZ3RoVmFsID0gdGhpcy5sZW5ndGggLSB0aGlzLl9yZWFkT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGVuY29kaW5nXG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrRW5jb2RpbmcoZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fYnVmZi5zbGljZSh0aGlzLl9yZWFkT2Zmc2V0LCB0aGlzLl9yZWFkT2Zmc2V0ICsgbGVuZ3RoVmFsKS50b1N0cmluZyhlbmNvZGluZyB8fCB0aGlzLl9lbmNvZGluZyk7XG4gICAgICAgIHRoaXMuX3JlYWRPZmZzZXQgKz0gbGVuZ3RoVmFsO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBTdHJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IFN0cmluZyB9IFRoZSBTdHJpbmcgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgc3RyaW5nIGF0LlxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB7IFN0cmluZyB9IFRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UgZm9yIHdyaXRpbmcgc3RyaW5ncyAoZGVmYXVsdHMgdG8gaW5zdGFuY2UgZW5jb2RpbmcpLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0U3RyaW5nKHZhbHVlLCBvZmZzZXQsIGVuY29kaW5nKSB7XG4gICAgICAgIHV0aWxzXzEuY2hlY2tPZmZzZXRWYWx1ZShvZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlU3RyaW5nKHZhbHVlLCB0cnVlLCBvZmZzZXQsIGVuY29kaW5nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgU3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBTdHJpbmcgfSBUaGUgU3RyaW5nIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBhcmcyIHsgTnVtYmVyIHwgU3RyaW5nIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgc3RyaW5nIGF0LCBvciB0aGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB7IFN0cmluZyB9IFRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UgZm9yIHdyaXRpbmcgc3RyaW5ncyAoZGVmYXVsdHMgdG8gaW5zdGFuY2UgZW5jb2RpbmcpLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVTdHJpbmcodmFsdWUsIGFyZzIsIGVuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVTdHJpbmcodmFsdWUsIGZhbHNlLCBhcmcyLCBlbmNvZGluZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgbnVsbC10ZXJtaW5hdGVkIFN0cmluZyBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvciB0aGUgc3RyaW5nIChEZWZhdWx0cyB0byBpbnN0YW5jZSBsZXZlbCBlbmNvZGluZykuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgU3RyaW5nIH1cbiAgICAgKi9cbiAgICByZWFkU3RyaW5nTlQoZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuY2hlY2tFbmNvZGluZyhlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IG51bGwgY2hhcmFjdGVyIHBvc2l0aW9uIHRvIHRoZSBlbmQgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICAgIGxldCBudWxsUG9zID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIC8vIEZpbmQgbmV4dCBudWxsIGNoYXJhY3RlciAoaWYgb25lIGlzIG5vdCBmb3VuZCwgZGVmYXVsdCBmcm9tIGFib3ZlIGlzIHVzZWQpXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9yZWFkT2Zmc2V0OyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2J1ZmZbaV0gPT09IDB4MDApIHtcbiAgICAgICAgICAgICAgICBudWxsUG9zID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZWFkIHN0cmluZyB2YWx1ZVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2J1ZmYuc2xpY2UodGhpcy5fcmVhZE9mZnNldCwgbnVsbFBvcyk7XG4gICAgICAgIC8vIEluY3JlbWVudCBpbnRlcm5hbCBCdWZmZXIgcmVhZCBvZmZzZXRcbiAgICAgICAgdGhpcy5fcmVhZE9mZnNldCA9IG51bGxQb3MgKyAxO1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoZW5jb2RpbmcgfHwgdGhpcy5fZW5jb2RpbmcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgbnVsbC10ZXJtaW5hdGVkIFN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IFN0cmluZyB9IFRoZSBTdHJpbmcgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIGFyZzIgeyBOdW1iZXIgfCBTdHJpbmcgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBzdHJpbmcgdG8sIG9yIHRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UuXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHsgU3RyaW5nIH0gVGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZSBmb3Igd3JpdGluZyBzdHJpbmdzIChkZWZhdWx0cyB0byBpbnN0YW5jZSBlbmNvZGluZykuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRTdHJpbmdOVCh2YWx1ZSwgb2Zmc2V0LCBlbmNvZGluZykge1xuICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgLy8gV3JpdGUgVmFsdWVzXG4gICAgICAgIHRoaXMuaW5zZXJ0U3RyaW5nKHZhbHVlLCBvZmZzZXQsIGVuY29kaW5nKTtcbiAgICAgICAgdGhpcy5pbnNlcnRVSW50OCgweDAwLCBvZmZzZXQgKyB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgbnVsbC10ZXJtaW5hdGVkIFN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IFN0cmluZyB9IFRoZSBTdHJpbmcgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIGFyZzIgeyBOdW1iZXIgfCBTdHJpbmcgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBzdHJpbmcgdG8sIG9yIHRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UuXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHsgU3RyaW5nIH0gVGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZSBmb3Igd3JpdGluZyBzdHJpbmdzIChkZWZhdWx0cyB0byBpbnN0YW5jZSBlbmNvZGluZykuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZVN0cmluZ05UKHZhbHVlLCBhcmcyLCBlbmNvZGluZykge1xuICAgICAgICAvLyBXcml0ZSBWYWx1ZXNcbiAgICAgICAgdGhpcy53cml0ZVN0cmluZyh2YWx1ZSwgYXJnMiwgZW5jb2RpbmcpO1xuICAgICAgICB0aGlzLndyaXRlVUludDgoMHgwMCwgdHlwZW9mIGFyZzIgPT09ICdudW1iZXInID8gYXJnMiArIHZhbHVlLmxlbmd0aCA6IHRoaXMud3JpdGVPZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQnVmZmVyc1xuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgQnVmZmVyIGZyb20gdGhlIGludGVybmFsIHJlYWQgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIHsgTnVtYmVyIH0gVGhlIGxlbmd0aCBvZiBkYXRhIHRvIHJlYWQgYXMgYSBCdWZmZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgQnVmZmVyIH1cbiAgICAgKi9cbiAgICByZWFkQnVmZmVyKGxlbmd0aCkge1xuICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuY2hlY2tMZW5ndGhWYWx1ZShsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aFZhbCA9IHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInID8gbGVuZ3RoIDogdGhpcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGVuZFBvaW50ID0gTWF0aC5taW4odGhpcy5sZW5ndGgsIHRoaXMuX3JlYWRPZmZzZXQgKyBsZW5ndGhWYWwpO1xuICAgICAgICAvLyBSZWFkIGJ1ZmZlciB2YWx1ZVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2J1ZmYuc2xpY2UodGhpcy5fcmVhZE9mZnNldCwgZW5kUG9pbnQpO1xuICAgICAgICAvLyBJbmNyZW1lbnQgaW50ZXJuYWwgQnVmZmVyIHJlYWQgb2Zmc2V0XG4gICAgICAgIHRoaXMuX3JlYWRPZmZzZXQgPSBlbmRQb2ludDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBCdWZmZXIgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBCdWZmZXIgfSBUaGUgQnVmZmVyIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBCdWZmZXIgdG8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRCdWZmZXIodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUJ1ZmZlcih2YWx1ZSwgdHJ1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgQnVmZmVyIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgQnVmZmVyIH0gVGhlIEJ1ZmZlciB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgQnVmZmVyIHRvLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVCdWZmZXIodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlQnVmZmVyKHZhbHVlLCBmYWxzZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBudWxsLXRlcm1pbmF0ZWQgQnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb2lzaXRvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyBCdWZmZXIgfVxuICAgICAqL1xuICAgIHJlYWRCdWZmZXJOVCgpIHtcbiAgICAgICAgLy8gU2V0IG51bGwgY2hhcmFjdGVyIHBvc2l0aW9uIHRvIHRoZSBlbmQgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICAgIGxldCBudWxsUG9zID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIC8vIEZpbmQgbmV4dCBudWxsIGNoYXJhY3RlciAoaWYgb25lIGlzIG5vdCBmb3VuZCwgZGVmYXVsdCBmcm9tIGFib3ZlIGlzIHVzZWQpXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9yZWFkT2Zmc2V0OyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2J1ZmZbaV0gPT09IDB4MDApIHtcbiAgICAgICAgICAgICAgICBudWxsUG9zID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZWFkIHZhbHVlXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fYnVmZi5zbGljZSh0aGlzLl9yZWFkT2Zmc2V0LCBudWxsUG9zKTtcbiAgICAgICAgLy8gSW5jcmVtZW50IGludGVybmFsIEJ1ZmZlciByZWFkIG9mZnNldFxuICAgICAgICB0aGlzLl9yZWFkT2Zmc2V0ID0gbnVsbFBvcyArIDE7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhIG51bGwtdGVybWluYXRlZCBCdWZmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBCdWZmZXIgfSBUaGUgQnVmZmVyIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBCdWZmZXIgdG8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRCdWZmZXJOVCh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuY2hlY2tPZmZzZXRWYWx1ZShvZmZzZXQpO1xuICAgICAgICAvLyBXcml0ZSBWYWx1ZXNcbiAgICAgICAgdGhpcy5pbnNlcnRCdWZmZXIodmFsdWUsIG9mZnNldCk7XG4gICAgICAgIHRoaXMuaW5zZXJ0VUludDgoMHgwMCwgb2Zmc2V0ICsgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIG51bGwtdGVybWluYXRlZCBCdWZmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBCdWZmZXIgfSBUaGUgQnVmZmVyIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBCdWZmZXIgdG8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUJ1ZmZlck5UKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgLy8gQ2hlY2tzIGZvciB2YWxpZCBudW1iZXJpYyB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXcml0ZSBWYWx1ZXNcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcih2YWx1ZSwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy53cml0ZVVJbnQ4KDB4MDAsIHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInID8gb2Zmc2V0ICsgdmFsdWUubGVuZ3RoIDogdGhpcy5fd3JpdGVPZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBTbWFydEJ1ZmZlciBpbnN0YW5jZSB0byBpdHMgb3JpZ2luYWwgZW1wdHkgc3RhdGUuXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5fcmVhZE9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJlbWFpbmluZyBkYXRhIGxlZnQgdG8gYmUgcmVhZCBmcm9tIHRoZSBTbWFydEJ1ZmZlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyBOdW1iZXIgfVxuICAgICAqL1xuICAgIHJlbWFpbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoIC0gdGhpcy5fcmVhZE9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCByZWFkIG9mZnNldCB2YWx1ZSBvZiB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICBnZXQgcmVhZE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJlYWQgb2Zmc2V0IHZhbHVlIG9mIHRoZSBTbWFydEJ1ZmZlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSAtIFRoZSBvZmZzZXQgdmFsdWUgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldCByZWFkT2Zmc2V0KG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGJvdW5kcy5cbiAgICAgICAgdXRpbHNfMS5jaGVja1RhcmdldE9mZnNldChvZmZzZXQsIHRoaXMpO1xuICAgICAgICB0aGlzLl9yZWFkT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHdyaXRlIG9mZnNldCB2YWx1ZSBvZiB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICBnZXQgd3JpdGVPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgd3JpdGUgb2Zmc2V0IHZhbHVlIG9mIHRoZSBTbWFydEJ1ZmZlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSAtIFRoZSBvZmZzZXQgdmFsdWUgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldCB3cml0ZU9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5jaGVja09mZnNldFZhbHVlKG9mZnNldCk7XG4gICAgICAgIC8vIENoZWNrIGZvciBib3VuZHMuXG4gICAgICAgIHV0aWxzXzEuY2hlY2tUYXJnZXRPZmZzZXQob2Zmc2V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnRseSBzZXQgc3RyaW5nIGVuY29kaW5nIG9mIHRoZSBTbWFydEJ1ZmZlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyBCdWZmZXJFbmNvZGluZyB9IFRoZSBzdHJpbmcgQnVmZmVyIGVuY29kaW5nIGN1cnJlbnRseSBzZXQuXG4gICAgICovXG4gICAgZ2V0IGVuY29kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2Rpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cmluZyBlbmNvZGluZyBvZiB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBCdWZmZXJFbmNvZGluZyB9IFRoZSBzdHJpbmcgQnVmZmVyIGVuY29kaW5nIHRvIHNldC5cbiAgICAgKi9cbiAgICBzZXQgZW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgICAgICAgdXRpbHNfMS5jaGVja0VuY29kaW5nKGVuY29kaW5nKTtcbiAgICAgICAgdGhpcy5fZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdW5kZXJseWluZyBpbnRlcm5hbCBCdWZmZXIuIChUaGlzIGluY2x1ZGVzIHVubWFuYWdlZCBkYXRhIGluIHRoZSBCdWZmZXIpXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgQnVmZmVyIH0gVGhlIEJ1ZmZlciB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXQgaW50ZXJuYWxCdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgaW50ZXJuYWwgbWFuYWdlZCBCdWZmZXIgKEluY2x1ZGVzIG1hbmFnZWQgZGF0YSBvbmx5KVxuICAgICAqXG4gICAgICogQHBhcmFtIHsgQnVmZmVyIH1cbiAgICAgKi9cbiAgICB0b0J1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmYuc2xpY2UoMCwgdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBTdHJpbmcgdmFsdWUgb2YgdGhlIGludGVybmFsIG1hbmFnZWQgQnVmZmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gZGlzcGxheSB0aGUgQnVmZmVyIGFzIChkZWZhdWx0cyB0byBpbnN0YW5jZSBsZXZlbCBlbmNvZGluZykuXG4gICAgICovXG4gICAgdG9TdHJpbmcoZW5jb2RpbmcpIHtcbiAgICAgICAgY29uc3QgZW5jb2RpbmdWYWwgPSB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnID8gZW5jb2RpbmcgOiB0aGlzLl9lbmNvZGluZztcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGludmFsaWQgZW5jb2RpbmcuXG4gICAgICAgIHV0aWxzXzEuY2hlY2tFbmNvZGluZyhlbmNvZGluZ1ZhbCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmLnRvU3RyaW5nKGVuY29kaW5nVmFsLCAwLCB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBTbWFydEJ1ZmZlciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGluc2VydGluZyBhbmQgd3JpdGluZyBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgU3RyaW5nIH0gVGhlIFN0cmluZyB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIGlzSW5zZXJ0IHsgQm9vbGVhbiB9IFRydWUgaWYgaW5zZXJ0aW5nIGEgc3RyaW5nLCBmYWxzZSBpZiB3cml0aW5nLlxuICAgICAqIEBwYXJhbSBhcmcyIHsgTnVtYmVyIHwgU3RyaW5nIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHN0cmluZyBhdCwgb3IgdGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvciB3cml0aW5nIHN0cmluZ3MgKGRlZmF1bHRzIHRvIGluc3RhbmNlIGVuY29kaW5nKS5cbiAgICAgKi9cbiAgICBfaGFuZGxlU3RyaW5nKHZhbHVlLCBpc0luc2VydCwgYXJnMywgZW5jb2RpbmcpIHtcbiAgICAgICAgbGV0IG9mZnNldFZhbCA9IHRoaXMuX3dyaXRlT2Zmc2V0O1xuICAgICAgICBsZXQgZW5jb2RpbmdWYWwgPSB0aGlzLl9lbmNvZGluZztcbiAgICAgICAgLy8gQ2hlY2sgZm9yIG9mZnNldFxuICAgICAgICBpZiAodHlwZW9mIGFyZzMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvZmZzZXRWYWwgPSBhcmczO1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGVuY29kaW5nXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZzMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrRW5jb2RpbmcoYXJnMyk7XG4gICAgICAgICAgICBlbmNvZGluZ1ZhbCA9IGFyZzM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGVuY29kaW5nICh0aGlyZCBwYXJhbSlcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuY2hlY2tFbmNvZGluZyhlbmNvZGluZyk7XG4gICAgICAgICAgICBlbmNvZGluZ1ZhbCA9IGVuY29kaW5nO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbGN1bGF0ZSBieXRlbGVuZ3RoIG9mIHN0cmluZy5cbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlLCBlbmNvZGluZ1ZhbCk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGVyZSBpcyBlbm91Z2ggaW50ZXJuYWwgQnVmZmVyIGNhcGFjaXR5LlxuICAgICAgICBpZiAoaXNJbnNlcnQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlSW5zZXJ0YWJsZShieXRlTGVuZ3RoLCBvZmZzZXRWYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZW5zdXJlV3JpdGVhYmxlKGJ5dGVMZW5ndGgsIG9mZnNldFZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV3JpdGUgdmFsdWVcbiAgICAgICAgdGhpcy5fYnVmZi53cml0ZSh2YWx1ZSwgb2Zmc2V0VmFsLCBieXRlTGVuZ3RoLCBlbmNvZGluZ1ZhbCk7XG4gICAgICAgIC8vIEluY3JlbWVudCBpbnRlcm5hbCBCdWZmZXIgd3JpdGUgb2Zmc2V0O1xuICAgICAgICBpZiAoaXNJbnNlcnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ICs9IGJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBhbiBvZmZzZXQgd2FzIGdpdmVuLCBjaGVjayB0byBzZWUgaWYgd2Ugd3JvdGUgYmV5b25kIHRoZSBjdXJyZW50IHdyaXRlT2Zmc2V0LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmczID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5fd3JpdGVPZmZzZXQsIG9mZnNldFZhbCArIGJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gb2Zmc2V0IHdhcyBnaXZlbiwgd2Ugd3JvdGUgdG8gdGhlIGVuZCBvZiB0aGUgU21hcnRCdWZmZXIgc28gaW5jcmVtZW50IHdyaXRlT2Zmc2V0LlxuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ICs9IGJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd3JpdGluZyBvciBpbnNlcnQgb2YgYSBCdWZmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBCdWZmZXIgfSBUaGUgQnVmZmVyIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBCdWZmZXIgdG8uXG4gICAgICovXG4gICAgX2hhbmRsZUJ1ZmZlcih2YWx1ZSwgaXNJbnNlcnQsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBvZmZzZXRWYWwgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJyA/IG9mZnNldCA6IHRoaXMuX3dyaXRlT2Zmc2V0O1xuICAgICAgICAvLyBFbnN1cmUgdGhlcmUgaXMgZW5vdWdoIGludGVybmFsIEJ1ZmZlciBjYXBhY2l0eS5cbiAgICAgICAgaWYgKGlzSW5zZXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZUluc2VydGFibGUodmFsdWUubGVuZ3RoLCBvZmZzZXRWYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZW5zdXJlV3JpdGVhYmxlKHZhbHVlLmxlbmd0aCwgb2Zmc2V0VmFsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXcml0ZSBidWZmZXIgdmFsdWVcbiAgICAgICAgdmFsdWUuY29weSh0aGlzLl9idWZmLCBvZmZzZXRWYWwpO1xuICAgICAgICAvLyBJbmNyZW1lbnQgaW50ZXJuYWwgQnVmZmVyIHdyaXRlIG9mZnNldDtcbiAgICAgICAgaWYgKGlzSW5zZXJ0KSB7XG4gICAgICAgICAgICB0aGlzLl93cml0ZU9mZnNldCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBhbiBvZmZzZXQgd2FzIGdpdmVuLCBjaGVjayB0byBzZWUgaWYgd2Ugd3JvdGUgYmV5b25kIHRoZSBjdXJyZW50IHdyaXRlT2Zmc2V0LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLl93cml0ZU9mZnNldCwgb2Zmc2V0VmFsICsgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIG9mZnNldCB3YXMgZ2l2ZW4sIHdlIHdyb3RlIHRvIHRoZSBlbmQgb2YgdGhlIFNtYXJ0QnVmZmVyIHNvIGluY3JlbWVudCB3cml0ZU9mZnNldC5cbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZU9mZnNldCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgaW50ZXJuYWwgQnVmZmVyIGlzIGxhcmdlIGVub3VnaCB0byByZWFkIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIHsgTnVtYmVyIH0gVGhlIGxlbmd0aCBvZiB0aGUgZGF0YSB0aGF0IG5lZWRzIHRvIGJlIHJlYWQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgb2YgdGhlIGRhdGEgdGhhdCBuZWVkcyB0byBiZSByZWFkLlxuICAgICAqL1xuICAgIGVuc3VyZVJlYWRhYmxlKGxlbmd0aCwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIE9mZnNldCB2YWx1ZSBkZWZhdWx0cyB0byBtYW5hZ2VkIHJlYWQgb2Zmc2V0LlxuICAgICAgICBsZXQgb2Zmc2V0VmFsID0gdGhpcy5fcmVhZE9mZnNldDtcbiAgICAgICAgLy8gSWYgYW4gb2Zmc2V0IHdhcyBwcm92aWRlZCwgdXNlIGl0LlxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIENoZWNrcyBmb3IgdmFsaWQgbnVtYmVyaWMgdmFsdWU7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgICAgIC8vIE92ZXJpZGUgd2l0aCBjdXN0b20gb2Zmc2V0LlxuICAgICAgICAgICAgb2Zmc2V0VmFsID0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrcyBpZiBvZmZzZXQgaXMgYmVsb3cgemVybywgb3IgdGhlIG9mZnNldCtsZW5ndGggb2Zmc2V0IGlzIGJleW9uZCB0aGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBtYW5hZ2VkIGRhdGEuXG4gICAgICAgIGlmIChvZmZzZXRWYWwgPCAwIHx8IG9mZnNldFZhbCArIGxlbmd0aCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbHNfMS5FUlJPUlMuSU5WQUxJRF9SRUFEX0JFWU9ORF9CT1VORFMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgaW50ZXJuYWwgQnVmZmVyIGlzIGxhcmdlIGVub3VnaCB0byBpbnNlcnQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhTGVuZ3RoIHsgTnVtYmVyIH0gVGhlIGxlbmd0aCBvZiB0aGUgZGF0YSB0aGF0IG5lZWRzIHRvIGJlIHdyaXR0ZW4uXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgb2YgdGhlIGRhdGEgdG8gYmUgd3JpdHRlbi5cbiAgICAgKi9cbiAgICBlbnN1cmVJbnNlcnRhYmxlKGRhdGFMZW5ndGgsIG9mZnNldCkge1xuICAgICAgICAvLyBDaGVja3MgZm9yIHZhbGlkIG51bWJlcmljIHZhbHVlO1xuICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgLy8gRW5zdXJlIHRoZXJlIGlzIGVub3VnaCBpbnRlcm5hbCBCdWZmZXIgY2FwYWNpdHkuXG4gICAgICAgIHRoaXMuX2Vuc3VyZUNhcGFjaXR5KHRoaXMubGVuZ3RoICsgZGF0YUxlbmd0aCk7XG4gICAgICAgIC8vIElmIGFuIG9mZnNldCB3YXMgcHJvdmlkZWQgYW5kIGl0cyBub3QgdGhlIHZlcnkgZW5kIG9mIHRoZSBidWZmZXIsIGNvcHkgZGF0YSBpbnRvIGFwcHJvcHJpYXRlIGxvY2F0aW9uIGluIHJlZ2FyZHMgdG8gdGhlIG9mZnNldC5cbiAgICAgICAgaWYgKG9mZnNldCA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmLmNvcHkodGhpcy5fYnVmZiwgb2Zmc2V0ICsgZGF0YUxlbmd0aCwgb2Zmc2V0LCB0aGlzLl9idWZmLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRqdXN0IHRyYWNrZWQgc21hcnQgYnVmZmVyIGxlbmd0aFxuICAgICAgICBpZiAob2Zmc2V0ICsgZGF0YUxlbmd0aCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG9mZnNldCArIGRhdGFMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhTGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgaW50ZXJuYWwgQnVmZmVyIGlzIGxhcmdlIGVub3VnaCB0byB3cml0ZSBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFMZW5ndGggeyBOdW1iZXIgfSBUaGUgbGVuZ3RoIG9mIHRoZSBkYXRhIHRoYXQgbmVlZHMgdG8gYmUgd3JpdHRlbi5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCBvZiB0aGUgZGF0YSB0byBiZSB3cml0dGVuIChkZWZhdWx0cyB0byB3cml0ZU9mZnNldCkuXG4gICAgICovXG4gICAgX2Vuc3VyZVdyaXRlYWJsZShkYXRhTGVuZ3RoLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0VmFsID0gdHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicgPyBvZmZzZXQgOiB0aGlzLl93cml0ZU9mZnNldDtcbiAgICAgICAgLy8gRW5zdXJlIGVub3VnaCBjYXBhY2l0eSB0byB3cml0ZSBkYXRhLlxuICAgICAgICB0aGlzLl9lbnN1cmVDYXBhY2l0eShvZmZzZXRWYWwgKyBkYXRhTGVuZ3RoKTtcbiAgICAgICAgLy8gQWRqdXN0IFNtYXJ0QnVmZmVyIGxlbmd0aCAoaWYgb2Zmc2V0ICsgbGVuZ3RoIGlzIGxhcmdlciB0aGFuIG1hbmFnZWQgbGVuZ3RoLCBhZGp1c3QgbGVuZ3RoKVxuICAgICAgICBpZiAob2Zmc2V0VmFsICsgZGF0YUxlbmd0aCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG9mZnNldFZhbCArIGRhdGFMZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlcyB0aGF0IHRoZSBpbnRlcm5hbCBCdWZmZXIgaXMgbGFyZ2UgZW5vdWdoIHRvIHdyaXRlIGF0IGxlYXN0IHRoZSBnaXZlbiBhbW91bnQgb2YgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtaW5MZW5ndGggeyBOdW1iZXIgfSBUaGUgbWluaW11bSBsZW5ndGggb2YgdGhlIGRhdGEgbmVlZHMgdG8gYmUgd3JpdHRlbi5cbiAgICAgKi9cbiAgICBfZW5zdXJlQ2FwYWNpdHkobWluTGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG9sZExlbmd0aCA9IHRoaXMuX2J1ZmYubGVuZ3RoO1xuICAgICAgICBpZiAobWluTGVuZ3RoID4gb2xkTGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHRoaXMuX2J1ZmY7XG4gICAgICAgICAgICBsZXQgbmV3TGVuZ3RoID0gKG9sZExlbmd0aCAqIDMpIC8gMiArIDE7XG4gICAgICAgICAgICBpZiAobmV3TGVuZ3RoIDwgbWluTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbmV3TGVuZ3RoID0gbWluTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYnVmZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuZXdMZW5ndGgpO1xuICAgICAgICAgICAgZGF0YS5jb3B5KHRoaXMuX2J1ZmYsIDAsIDAsIG9sZExlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBudW1lcmljIG51bWJlciB2YWx1ZSB1c2luZyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZXBhcmFtIFQgeyBudW1iZXIgfCBiaWdpbnQgfSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gYmUgcmVhZFxuICAgICAqXG4gICAgICogQHBhcmFtIGZ1bmMgeyBGdW5jdGlvbihvZmZzZXQ6IG51bWJlcikgPT4gbnVtYmVyIH0gVGhlIGZ1bmN0aW9uIHRvIHJlYWQgZGF0YSBvbiB0aGUgaW50ZXJuYWwgQnVmZmVyIHdpdGguXG4gICAgICogQHBhcmFtIGJ5dGVTaXplIHsgTnVtYmVyIH0gVGhlIG51bWJlciBvZiBieXRlcyByZWFkLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZnJvbSAob3B0aW9uYWwpLiBXaGVuIHRoaXMgaXMgbm90IHByb3ZpZGVkLCB0aGUgbWFuYWdlZCByZWFkT2Zmc2V0IGlzIHVzZWQgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsgVCB9IHRoZSBudW1iZXIgdmFsdWVcbiAgICAgKi9cbiAgICBfcmVhZE51bWJlclZhbHVlKGZ1bmMsIGJ5dGVTaXplLCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVSZWFkYWJsZShieXRlU2l6ZSwgb2Zmc2V0KTtcbiAgICAgICAgLy8gQ2FsbCBCdWZmZXIucmVhZFhYWFgoKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBmdW5jLmNhbGwodGhpcy5fYnVmZiwgdHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicgPyBvZmZzZXQgOiB0aGlzLl9yZWFkT2Zmc2V0KTtcbiAgICAgICAgLy8gQWRqdXN0IGludGVybmFsIHJlYWQgb2Zmc2V0IGlmIGFuIG9wdGlvbmFsIHJlYWQgb2Zmc2V0IHdhcyBub3QgcHJvdmlkZWQuXG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5fcmVhZE9mZnNldCArPSBieXRlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBudW1lcmljIG51bWJlciB2YWx1ZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gb2Zmc2V0IGFuZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEB0eXBlcGFyYW0gVCB7IG51bWJlciB8IGJpZ2ludCB9IFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBiZSB3cml0dGVuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnVuYyB7IEZ1bmN0aW9uKG9mZnNldDogVCwgb2Zmc2V0PykgPT4gbnVtYmVyfSBUaGUgZnVuY3Rpb24gdG8gd3JpdGUgZGF0YSBvbiB0aGUgaW50ZXJuYWwgQnVmZmVyIHdpdGguXG4gICAgICogQHBhcmFtIGJ5dGVTaXplIHsgTnVtYmVyIH0gVGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuLlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IFQgfSBUaGUgbnVtYmVyIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSB0aGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBudW1iZXIgYXQgKFJFUVVJUkVEKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFNtYXJ0QnVmZmVyIHRoaXMgYnVmZmVyXG4gICAgICovXG4gICAgX2luc2VydE51bWJlclZhbHVlKGZ1bmMsIGJ5dGVTaXplLCB2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBpbnZhbGlkIG9mZnNldCB2YWx1ZXMuXG4gICAgICAgIHV0aWxzXzEuY2hlY2tPZmZzZXRWYWx1ZShvZmZzZXQpO1xuICAgICAgICAvLyBFbnN1cmUgdGhlcmUgaXMgZW5vdWdoIGludGVybmFsIEJ1ZmZlciBjYXBhY2l0eS4gKHJhdyBvZmZzZXQgaXMgcGFzc2VkKVxuICAgICAgICB0aGlzLmVuc3VyZUluc2VydGFibGUoYnl0ZVNpemUsIG9mZnNldCk7XG4gICAgICAgIC8vIENhbGwgYnVmZmVyLndyaXRlWFhYWCgpO1xuICAgICAgICBmdW5jLmNhbGwodGhpcy5fYnVmZiwgdmFsdWUsIG9mZnNldCk7XG4gICAgICAgIC8vIEFkanVzdHMgaW50ZXJuYWxseSBtYW5hZ2VkIHdyaXRlIG9mZnNldC5cbiAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgKz0gYnl0ZVNpemU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBudW1lcmljIG51bWJlciB2YWx1ZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gb2Zmc2V0IGFuZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEB0eXBlcGFyYW0gVCB7IG51bWJlciB8IGJpZ2ludCB9IFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBiZSB3cml0dGVuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnVuYyB7IEZ1bmN0aW9uKG9mZnNldDogVCwgb2Zmc2V0PykgPT4gbnVtYmVyfSBUaGUgZnVuY3Rpb24gdG8gd3JpdGUgZGF0YSBvbiB0aGUgaW50ZXJuYWwgQnVmZmVyIHdpdGguXG4gICAgICogQHBhcmFtIGJ5dGVTaXplIHsgTnVtYmVyIH0gVGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuLlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IFQgfSBUaGUgbnVtYmVyIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSB0aGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBudW1iZXIgYXQgKFJFUVVJUkVEKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFNtYXJ0QnVmZmVyIHRoaXMgYnVmZmVyXG4gICAgICovXG4gICAgX3dyaXRlTnVtYmVyVmFsdWUoZnVuYywgYnl0ZVNpemUsIHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgLy8gSWYgYW4gb2Zmc2V0IHdhcyBwcm92aWRlZCwgdmFsaWRhdGUgaXQuXG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgd3JpdGluZyBiZXlvbmQgdGhlIGJvdW5kcyBvZiB0aGUgbWFuYWdlZCBkYXRhLlxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbHNfMS5FUlJPUlMuSU5WQUxJRF9XUklURV9CRVlPTkRfQk9VTkRTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHV0aWxzXzEuY2hlY2tPZmZzZXRWYWx1ZShvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlZmF1bHQgdG8gd3JpdGVPZmZzZXQgaWYgbm8gb2Zmc2V0IHZhbHVlIHdhcyBnaXZlbi5cbiAgICAgICAgY29uc3Qgb2Zmc2V0VmFsID0gdHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicgPyBvZmZzZXQgOiB0aGlzLl93cml0ZU9mZnNldDtcbiAgICAgICAgLy8gRW5zdXJlIHRoZXJlIGlzIGVub3VnaCBpbnRlcm5hbCBCdWZmZXIgY2FwYWNpdHkuIChyYXcgb2Zmc2V0IGlzIHBhc3NlZClcbiAgICAgICAgdGhpcy5fZW5zdXJlV3JpdGVhYmxlKGJ5dGVTaXplLCBvZmZzZXRWYWwpO1xuICAgICAgICBmdW5jLmNhbGwodGhpcy5fYnVmZiwgdmFsdWUsIG9mZnNldFZhbCk7XG4gICAgICAgIC8vIElmIGFuIG9mZnNldCB3YXMgZ2l2ZW4sIGNoZWNrIHRvIHNlZSBpZiB3ZSB3cm90ZSBiZXlvbmQgdGhlIGN1cnJlbnQgd3JpdGVPZmZzZXQuXG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLl93cml0ZU9mZnNldCwgb2Zmc2V0VmFsICsgYnl0ZVNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbm8gbnVtZXJpYyBvZmZzZXQgd2FzIGdpdmVuLCB3ZSB3cm90ZSB0byB0aGUgZW5kIG9mIHRoZSBTbWFydEJ1ZmZlciBzbyBpbmNyZW1lbnQgd3JpdGVPZmZzZXQuXG4gICAgICAgICAgICB0aGlzLl93cml0ZU9mZnNldCArPSBieXRlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLlNtYXJ0QnVmZmVyID0gU21hcnRCdWZmZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbWFydGJ1ZmZlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ1dGlsc18xIiwicmVxdWlyZSIsIkRFRkFVTFRfU01BUlRCVUZGRVJfU0laRSIsIkRFRkFVTFRfU01BUlRCVUZGRVJfRU5DT0RJTkciLCJTbWFydEJ1ZmZlciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImxlbmd0aCIsIl9lbmNvZGluZyIsIl93cml0ZU9mZnNldCIsIl9yZWFkT2Zmc2V0IiwiaXNTbWFydEJ1ZmZlck9wdGlvbnMiLCJlbmNvZGluZyIsImNoZWNrRW5jb2RpbmciLCJzaXplIiwiaXNGaW5pdGVJbnRlZ2VyIiwiX2J1ZmYiLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsIkVycm9yIiwiRVJST1JTIiwiSU5WQUxJRF9TTUFSVEJVRkZFUl9TSVpFIiwiYnVmZiIsImlzQnVmZmVyIiwiSU5WQUxJRF9TTUFSVEJVRkZFUl9CVUZGRVIiLCJJTlZBTElEX1NNQVJUQlVGRkVSX09CSkVDVCIsImZyb21TaXplIiwiZnJvbUJ1ZmZlciIsImZyb21PcHRpb25zIiwiY2FzdE9wdGlvbnMiLCJ1bmRlZmluZWQiLCJyZWFkSW50OCIsIm9mZnNldCIsIl9yZWFkTnVtYmVyVmFsdWUiLCJwcm90b3R5cGUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQxNkxFIiwicmVhZEludDMyQkUiLCJyZWFkSW50MzJMRSIsInJlYWRCaWdJbnQ2NEJFIiwiYmlnSW50QW5kQnVmZmVySW50NjRDaGVjayIsInJlYWRCaWdJbnQ2NExFIiwid3JpdGVJbnQ4IiwiX3dyaXRlTnVtYmVyVmFsdWUiLCJpbnNlcnRJbnQ4IiwiX2luc2VydE51bWJlclZhbHVlIiwid3JpdGVJbnQxNkJFIiwiaW5zZXJ0SW50MTZCRSIsIndyaXRlSW50MTZMRSIsImluc2VydEludDE2TEUiLCJ3cml0ZUludDMyQkUiLCJpbnNlcnRJbnQzMkJFIiwid3JpdGVJbnQzMkxFIiwiaW5zZXJ0SW50MzJMRSIsIndyaXRlQmlnSW50NjRCRSIsImluc2VydEJpZ0ludDY0QkUiLCJ3cml0ZUJpZ0ludDY0TEUiLCJpbnNlcnRCaWdJbnQ2NExFIiwicmVhZFVJbnQ4IiwicmVhZFVJbnQxNkJFIiwicmVhZFVJbnQxNkxFIiwicmVhZFVJbnQzMkJFIiwicmVhZFVJbnQzMkxFIiwicmVhZEJpZ1VJbnQ2NEJFIiwicmVhZEJpZ1VJbnQ2NExFIiwid3JpdGVVSW50OCIsImluc2VydFVJbnQ4Iiwid3JpdGVVSW50MTZCRSIsImluc2VydFVJbnQxNkJFIiwid3JpdGVVSW50MTZMRSIsImluc2VydFVJbnQxNkxFIiwid3JpdGVVSW50MzJCRSIsImluc2VydFVJbnQzMkJFIiwid3JpdGVVSW50MzJMRSIsImluc2VydFVJbnQzMkxFIiwid3JpdGVCaWdVSW50NjRCRSIsImluc2VydEJpZ1VJbnQ2NEJFIiwid3JpdGVCaWdVSW50NjRMRSIsImluc2VydEJpZ1VJbnQ2NExFIiwicmVhZEZsb2F0QkUiLCJyZWFkRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsImluc2VydEZsb2F0QkUiLCJ3cml0ZUZsb2F0TEUiLCJpbnNlcnRGbG9hdExFIiwicmVhZERvdWJsZUJFIiwicmVhZERvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsImluc2VydERvdWJsZUJFIiwid3JpdGVEb3VibGVMRSIsImluc2VydERvdWJsZUxFIiwicmVhZFN0cmluZyIsImFyZzEiLCJsZW5ndGhWYWwiLCJjaGVja0xlbmd0aFZhbHVlIiwiTWF0aCIsIm1pbiIsInNsaWNlIiwidG9TdHJpbmciLCJpbnNlcnRTdHJpbmciLCJjaGVja09mZnNldFZhbHVlIiwiX2hhbmRsZVN0cmluZyIsIndyaXRlU3RyaW5nIiwiYXJnMiIsInJlYWRTdHJpbmdOVCIsIm51bGxQb3MiLCJpIiwiaW5zZXJ0U3RyaW5nTlQiLCJ3cml0ZVN0cmluZ05UIiwid3JpdGVPZmZzZXQiLCJyZWFkQnVmZmVyIiwiZW5kUG9pbnQiLCJpbnNlcnRCdWZmZXIiLCJfaGFuZGxlQnVmZmVyIiwid3JpdGVCdWZmZXIiLCJyZWFkQnVmZmVyTlQiLCJpbnNlcnRCdWZmZXJOVCIsIndyaXRlQnVmZmVyTlQiLCJjbGVhciIsInJlbWFpbmluZyIsInJlYWRPZmZzZXQiLCJjaGVja1RhcmdldE9mZnNldCIsImludGVybmFsQnVmZmVyIiwidG9CdWZmZXIiLCJlbmNvZGluZ1ZhbCIsImRlc3Ryb3kiLCJpc0luc2VydCIsImFyZzMiLCJvZmZzZXRWYWwiLCJieXRlTGVuZ3RoIiwiZW5zdXJlSW5zZXJ0YWJsZSIsIl9lbnN1cmVXcml0ZWFibGUiLCJ3cml0ZSIsIm1heCIsImNvcHkiLCJlbnN1cmVSZWFkYWJsZSIsIklOVkFMSURfUkVBRF9CRVlPTkRfQk9VTkRTIiwiZGF0YUxlbmd0aCIsIl9lbnN1cmVDYXBhY2l0eSIsIm1pbkxlbmd0aCIsIm9sZExlbmd0aCIsImRhdGEiLCJuZXdMZW5ndGgiLCJmdW5jIiwiYnl0ZVNpemUiLCJjYWxsIiwiSU5WQUxJRF9XUklURV9CRVlPTkRfQk9VTkRTIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/smart-buffer/build/smartbuffer.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/smart-buffer/build/utils.js":
/*!******************************************************!*\
  !*** ../../node_modules/smart-buffer/build/utils.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\n/**\n * Error strings\n */ const ERRORS = {\n    INVALID_ENCODING: \"Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.\",\n    INVALID_SMARTBUFFER_SIZE: \"Invalid size provided. Size must be a valid integer greater than zero.\",\n    INVALID_SMARTBUFFER_BUFFER: \"Invalid Buffer provided in SmartBufferOptions.\",\n    INVALID_SMARTBUFFER_OBJECT: \"Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.\",\n    INVALID_OFFSET: \"An invalid offset value was provided.\",\n    INVALID_OFFSET_NON_NUMBER: \"An invalid offset value was provided. A numeric value is required.\",\n    INVALID_LENGTH: \"An invalid length value was provided.\",\n    INVALID_LENGTH_NON_NUMBER: \"An invalid length value was provived. A numeric value is required.\",\n    INVALID_TARGET_OFFSET: \"Target offset is beyond the bounds of the internal SmartBuffer data.\",\n    INVALID_TARGET_LENGTH: \"Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.\",\n    INVALID_READ_BEYOND_BOUNDS: \"Attempted to read beyond the bounds of the managed data.\",\n    INVALID_WRITE_BEYOND_BOUNDS: \"Attempted to write beyond the bounds of the managed data.\"\n};\nexports.ERRORS = ERRORS;\n/**\n * Checks if a given encoding is a valid Buffer encoding. (Throws an exception if check fails)\n *\n * @param { String } encoding The encoding string to check.\n */ function checkEncoding(encoding) {\n    if (!buffer_1.Buffer.isEncoding(encoding)) {\n        throw new Error(ERRORS.INVALID_ENCODING);\n    }\n}\nexports.checkEncoding = checkEncoding;\n/**\n * Checks if a given number is a finite integer. (Throws an exception if check fails)\n *\n * @param { Number } value The number value to check.\n */ function isFiniteInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && isInteger(value);\n}\nexports.isFiniteInteger = isFiniteInteger;\n/**\n * Checks if an offset/length value is valid. (Throws an exception if check fails)\n *\n * @param value The value to check.\n * @param offset True if checking an offset, false if checking a length.\n */ function checkOffsetOrLengthValue(value, offset) {\n    if (typeof value === \"number\") {\n        // Check for non finite/non integers\n        if (!isFiniteInteger(value) || value < 0) {\n            throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);\n        }\n    } else {\n        throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);\n    }\n}\n/**\n * Checks if a length value is valid. (Throws an exception if check fails)\n *\n * @param { Number } length The value to check.\n */ function checkLengthValue(length) {\n    checkOffsetOrLengthValue(length, false);\n}\nexports.checkLengthValue = checkLengthValue;\n/**\n * Checks if a offset value is valid. (Throws an exception if check fails)\n *\n * @param { Number } offset The value to check.\n */ function checkOffsetValue(offset) {\n    checkOffsetOrLengthValue(offset, true);\n}\nexports.checkOffsetValue = checkOffsetValue;\n/**\n * Checks if a target offset value is out of bounds. (Throws an exception if check fails)\n *\n * @param { Number } offset The offset value to check.\n * @param { SmartBuffer } buff The SmartBuffer instance to check against.\n */ function checkTargetOffset(offset, buff) {\n    if (offset < 0 || offset > buff.length) {\n        throw new Error(ERRORS.INVALID_TARGET_OFFSET);\n    }\n}\nexports.checkTargetOffset = checkTargetOffset;\n/**\n * Determines whether a given number is a integer.\n * @param value The number to check.\n */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n}\n/**\n * Throws if Node.js version is too low to support bigint\n */ function bigIntAndBufferInt64Check(bufferMethod) {\n    if (typeof BigInt === \"undefined\") {\n        throw new Error(\"Platform does not support JS BigInt type.\");\n    }\n    if (typeof buffer_1.Buffer.prototype[bufferMethod] === \"undefined\") {\n        throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);\n    }\n}\nexports.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check; //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWJ1ZmZlci9idWlsZC91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxXQUFXQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQzs7Q0FFQyxHQUNELE1BQU1DLFNBQVM7SUFDWEMsa0JBQWtCO0lBQ2xCQywwQkFBMEI7SUFDMUJDLDRCQUE0QjtJQUM1QkMsNEJBQTRCO0lBQzVCQyxnQkFBZ0I7SUFDaEJDLDJCQUEyQjtJQUMzQkMsZ0JBQWdCO0lBQ2hCQywyQkFBMkI7SUFDM0JDLHVCQUF1QjtJQUN2QkMsdUJBQXVCO0lBQ3ZCQyw0QkFBNEI7SUFDNUJDLDZCQUE2QjtBQUNqQztBQUNBaEIsY0FBYyxHQUFHSTtBQUNqQjs7OztDQUlDLEdBQ0QsU0FBU2EsY0FBY0MsUUFBUTtJQUMzQixJQUFJLENBQUNoQixTQUFTaUIsTUFBTSxDQUFDQyxVQUFVLENBQUNGLFdBQVc7UUFDdkMsTUFBTSxJQUFJRyxNQUFNakIsT0FBT0MsZ0JBQWdCO0lBQzNDO0FBQ0o7QUFDQUwscUJBQXFCLEdBQUdpQjtBQUN4Qjs7OztDQUlDLEdBQ0QsU0FBU0ssZ0JBQWdCckIsS0FBSztJQUMxQixPQUFPLE9BQU9BLFVBQVUsWUFBWXNCLFNBQVN0QixVQUFVdUIsVUFBVXZCO0FBQ3JFO0FBQ0FELHVCQUF1QixHQUFHc0I7QUFDMUI7Ozs7O0NBS0MsR0FDRCxTQUFTRyx5QkFBeUJ4QixLQUFLLEVBQUV5QixNQUFNO0lBQzNDLElBQUksT0FBT3pCLFVBQVUsVUFBVTtRQUMzQixvQ0FBb0M7UUFDcEMsSUFBSSxDQUFDcUIsZ0JBQWdCckIsVUFBVUEsUUFBUSxHQUFHO1lBQ3RDLE1BQU0sSUFBSW9CLE1BQU1LLFNBQVN0QixPQUFPSyxjQUFjLEdBQUdMLE9BQU9PLGNBQWM7UUFDMUU7SUFDSixPQUNLO1FBQ0QsTUFBTSxJQUFJVSxNQUFNSyxTQUFTdEIsT0FBT00seUJBQXlCLEdBQUdOLE9BQU9RLHlCQUF5QjtJQUNoRztBQUNKO0FBQ0E7Ozs7Q0FJQyxHQUNELFNBQVNlLGlCQUFpQkMsTUFBTTtJQUM1QkgseUJBQXlCRyxRQUFRO0FBQ3JDO0FBQ0E1Qix3QkFBd0IsR0FBRzJCO0FBQzNCOzs7O0NBSUMsR0FDRCxTQUFTRSxpQkFBaUJILE1BQU07SUFDNUJELHlCQUF5QkMsUUFBUTtBQUNyQztBQUNBMUIsd0JBQXdCLEdBQUc2QjtBQUMzQjs7Ozs7Q0FLQyxHQUNELFNBQVNDLGtCQUFrQkosTUFBTSxFQUFFSyxJQUFJO0lBQ25DLElBQUlMLFNBQVMsS0FBS0EsU0FBU0ssS0FBS0gsTUFBTSxFQUFFO1FBQ3BDLE1BQU0sSUFBSVAsTUFBTWpCLE9BQU9TLHFCQUFxQjtJQUNoRDtBQUNKO0FBQ0FiLHlCQUF5QixHQUFHOEI7QUFDNUI7OztDQUdDLEdBQ0QsU0FBU04sVUFBVXZCLEtBQUs7SUFDcEIsT0FBTyxPQUFPQSxVQUFVLFlBQVlzQixTQUFTdEIsVUFBVStCLEtBQUtDLEtBQUssQ0FBQ2hDLFdBQVdBO0FBQ2pGO0FBQ0E7O0NBRUMsR0FDRCxTQUFTaUMsMEJBQTBCQyxZQUFZO0lBQzNDLElBQUksT0FBT0MsV0FBVyxhQUFhO1FBQy9CLE1BQU0sSUFBSWYsTUFBTTtJQUNwQjtJQUNBLElBQUksT0FBT25CLFNBQVNpQixNQUFNLENBQUNrQixTQUFTLENBQUNGLGFBQWEsS0FBSyxhQUFhO1FBQ2hFLE1BQU0sSUFBSWQsTUFBTSxDQUFDLDJDQUEyQyxFQUFFYyxhQUFhLENBQUMsQ0FBQztJQUNqRjtBQUNKO0FBQ0FuQyxpQ0FBaUMsR0FBR2tDLDJCQUNwQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWJ1ZmZlci9idWlsZC91dGlscy5qcz83NGY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuLyoqXG4gKiBFcnJvciBzdHJpbmdzXG4gKi9cbmNvbnN0IEVSUk9SUyA9IHtcbiAgICBJTlZBTElEX0VOQ09ESU5HOiAnSW52YWxpZCBlbmNvZGluZyBwcm92aWRlZC4gUGxlYXNlIHNwZWNpZnkgYSB2YWxpZCBlbmNvZGluZyB0aGUgaW50ZXJuYWwgTm9kZS5qcyBCdWZmZXIgc3VwcG9ydHMuJyxcbiAgICBJTlZBTElEX1NNQVJUQlVGRkVSX1NJWkU6ICdJbnZhbGlkIHNpemUgcHJvdmlkZWQuIFNpemUgbXVzdCBiZSBhIHZhbGlkIGludGVnZXIgZ3JlYXRlciB0aGFuIHplcm8uJyxcbiAgICBJTlZBTElEX1NNQVJUQlVGRkVSX0JVRkZFUjogJ0ludmFsaWQgQnVmZmVyIHByb3ZpZGVkIGluIFNtYXJ0QnVmZmVyT3B0aW9ucy4nLFxuICAgIElOVkFMSURfU01BUlRCVUZGRVJfT0JKRUNUOiAnSW52YWxpZCBTbWFydEJ1ZmZlck9wdGlvbnMgb2JqZWN0IHN1cHBsaWVkIHRvIFNtYXJ0QnVmZmVyIGNvbnN0cnVjdG9yIG9yIGZhY3RvcnkgbWV0aG9kcy4nLFxuICAgIElOVkFMSURfT0ZGU0VUOiAnQW4gaW52YWxpZCBvZmZzZXQgdmFsdWUgd2FzIHByb3ZpZGVkLicsXG4gICAgSU5WQUxJRF9PRkZTRVRfTk9OX05VTUJFUjogJ0FuIGludmFsaWQgb2Zmc2V0IHZhbHVlIHdhcyBwcm92aWRlZC4gQSBudW1lcmljIHZhbHVlIGlzIHJlcXVpcmVkLicsXG4gICAgSU5WQUxJRF9MRU5HVEg6ICdBbiBpbnZhbGlkIGxlbmd0aCB2YWx1ZSB3YXMgcHJvdmlkZWQuJyxcbiAgICBJTlZBTElEX0xFTkdUSF9OT05fTlVNQkVSOiAnQW4gaW52YWxpZCBsZW5ndGggdmFsdWUgd2FzIHByb3ZpdmVkLiBBIG51bWVyaWMgdmFsdWUgaXMgcmVxdWlyZWQuJyxcbiAgICBJTlZBTElEX1RBUkdFVF9PRkZTRVQ6ICdUYXJnZXQgb2Zmc2V0IGlzIGJleW9uZCB0aGUgYm91bmRzIG9mIHRoZSBpbnRlcm5hbCBTbWFydEJ1ZmZlciBkYXRhLicsXG4gICAgSU5WQUxJRF9UQVJHRVRfTEVOR1RIOiAnU3BlY2lmaWVkIGxlbmd0aCB2YWx1ZSBtb3ZlcyBjdXJzb3IgYmV5b25nIHRoZSBib3VuZHMgb2YgdGhlIGludGVybmFsIFNtYXJ0QnVmZmVyIGRhdGEuJyxcbiAgICBJTlZBTElEX1JFQURfQkVZT05EX0JPVU5EUzogJ0F0dGVtcHRlZCB0byByZWFkIGJleW9uZCB0aGUgYm91bmRzIG9mIHRoZSBtYW5hZ2VkIGRhdGEuJyxcbiAgICBJTlZBTElEX1dSSVRFX0JFWU9ORF9CT1VORFM6ICdBdHRlbXB0ZWQgdG8gd3JpdGUgYmV5b25kIHRoZSBib3VuZHMgb2YgdGhlIG1hbmFnZWQgZGF0YS4nXG59O1xuZXhwb3J0cy5FUlJPUlMgPSBFUlJPUlM7XG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGVuY29kaW5nIGlzIGEgdmFsaWQgQnVmZmVyIGVuY29kaW5nLiAoVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBjaGVjayBmYWlscylcbiAqXG4gKiBAcGFyYW0geyBTdHJpbmcgfSBlbmNvZGluZyBUaGUgZW5jb2Rpbmcgc3RyaW5nIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBjaGVja0VuY29kaW5nKGVuY29kaW5nKSB7XG4gICAgaWYgKCFidWZmZXJfMS5CdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SUy5JTlZBTElEX0VOQ09ESU5HKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrRW5jb2RpbmcgPSBjaGVja0VuY29kaW5nO1xuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBudW1iZXIgaXMgYSBmaW5pdGUgaW50ZWdlci4gKFRocm93cyBhbiBleGNlcHRpb24gaWYgY2hlY2sgZmFpbHMpXG4gKlxuICogQHBhcmFtIHsgTnVtYmVyIH0gdmFsdWUgVGhlIG51bWJlciB2YWx1ZSB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gaXNGaW5pdGVJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpICYmIGlzSW50ZWdlcih2YWx1ZSk7XG59XG5leHBvcnRzLmlzRmluaXRlSW50ZWdlciA9IGlzRmluaXRlSW50ZWdlcjtcbi8qKlxuICogQ2hlY2tzIGlmIGFuIG9mZnNldC9sZW5ndGggdmFsdWUgaXMgdmFsaWQuIChUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIGNoZWNrIGZhaWxzKVxuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gb2Zmc2V0IFRydWUgaWYgY2hlY2tpbmcgYW4gb2Zmc2V0LCBmYWxzZSBpZiBjaGVja2luZyBhIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXRPckxlbmd0aFZhbHVlKHZhbHVlLCBvZmZzZXQpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBDaGVjayBmb3Igbm9uIGZpbml0ZS9ub24gaW50ZWdlcnNcbiAgICAgICAgaWYgKCFpc0Zpbml0ZUludGVnZXIodmFsdWUpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG9mZnNldCA/IEVSUk9SUy5JTlZBTElEX09GRlNFVCA6IEVSUk9SUy5JTlZBTElEX0xFTkdUSCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihvZmZzZXQgPyBFUlJPUlMuSU5WQUxJRF9PRkZTRVRfTk9OX05VTUJFUiA6IEVSUk9SUy5JTlZBTElEX0xFTkdUSF9OT05fTlVNQkVSKTtcbiAgICB9XG59XG4vKipcbiAqIENoZWNrcyBpZiBhIGxlbmd0aCB2YWx1ZSBpcyB2YWxpZC4gKFRocm93cyBhbiBleGNlcHRpb24gaWYgY2hlY2sgZmFpbHMpXG4gKlxuICogQHBhcmFtIHsgTnVtYmVyIH0gbGVuZ3RoIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gY2hlY2tMZW5ndGhWYWx1ZShsZW5ndGgpIHtcbiAgICBjaGVja09mZnNldE9yTGVuZ3RoVmFsdWUobGVuZ3RoLCBmYWxzZSk7XG59XG5leHBvcnRzLmNoZWNrTGVuZ3RoVmFsdWUgPSBjaGVja0xlbmd0aFZhbHVlO1xuLyoqXG4gKiBDaGVja3MgaWYgYSBvZmZzZXQgdmFsdWUgaXMgdmFsaWQuIChUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIGNoZWNrIGZhaWxzKVxuICpcbiAqIEBwYXJhbSB7IE51bWJlciB9IG9mZnNldCBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KSB7XG4gICAgY2hlY2tPZmZzZXRPckxlbmd0aFZhbHVlKG9mZnNldCwgdHJ1ZSk7XG59XG5leHBvcnRzLmNoZWNrT2Zmc2V0VmFsdWUgPSBjaGVja09mZnNldFZhbHVlO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB0YXJnZXQgb2Zmc2V0IHZhbHVlIGlzIG91dCBvZiBib3VuZHMuIChUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIGNoZWNrIGZhaWxzKVxuICpcbiAqIEBwYXJhbSB7IE51bWJlciB9IG9mZnNldCBUaGUgb2Zmc2V0IHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHsgU21hcnRCdWZmZXIgfSBidWZmIFRoZSBTbWFydEJ1ZmZlciBpbnN0YW5jZSB0byBjaGVjayBhZ2FpbnN0LlxuICovXG5mdW5jdGlvbiBjaGVja1RhcmdldE9mZnNldChvZmZzZXQsIGJ1ZmYpIHtcbiAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBidWZmLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTLklOVkFMSURfVEFSR0VUX09GRlNFVCk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja1RhcmdldE9mZnNldCA9IGNoZWNrVGFyZ2V0T2Zmc2V0O1xuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBnaXZlbiBudW1iZXIgaXMgYSBpbnRlZ2VyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKSAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG59XG4vKipcbiAqIFRocm93cyBpZiBOb2RlLmpzIHZlcnNpb24gaXMgdG9vIGxvdyB0byBzdXBwb3J0IGJpZ2ludFxuICovXG5mdW5jdGlvbiBiaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKGJ1ZmZlck1ldGhvZCkge1xuICAgIGlmICh0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsYXRmb3JtIGRvZXMgbm90IHN1cHBvcnQgSlMgQmlnSW50IHR5cGUuJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYnVmZmVyXzEuQnVmZmVyLnByb3RvdHlwZVtidWZmZXJNZXRob2RdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBsYXRmb3JtIGRvZXMgbm90IHN1cHBvcnQgQnVmZmVyLnByb3RvdHlwZS4ke2J1ZmZlck1ldGhvZH0uYCk7XG4gICAgfVxufVxuZXhwb3J0cy5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrID0gYmlnSW50QW5kQnVmZmVySW50NjRDaGVjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImJ1ZmZlcl8xIiwicmVxdWlyZSIsIkVSUk9SUyIsIklOVkFMSURfRU5DT0RJTkciLCJJTlZBTElEX1NNQVJUQlVGRkVSX1NJWkUiLCJJTlZBTElEX1NNQVJUQlVGRkVSX0JVRkZFUiIsIklOVkFMSURfU01BUlRCVUZGRVJfT0JKRUNUIiwiSU5WQUxJRF9PRkZTRVQiLCJJTlZBTElEX09GRlNFVF9OT05fTlVNQkVSIiwiSU5WQUxJRF9MRU5HVEgiLCJJTlZBTElEX0xFTkdUSF9OT05fTlVNQkVSIiwiSU5WQUxJRF9UQVJHRVRfT0ZGU0VUIiwiSU5WQUxJRF9UQVJHRVRfTEVOR1RIIiwiSU5WQUxJRF9SRUFEX0JFWU9ORF9CT1VORFMiLCJJTlZBTElEX1dSSVRFX0JFWU9ORF9CT1VORFMiLCJjaGVja0VuY29kaW5nIiwiZW5jb2RpbmciLCJCdWZmZXIiLCJpc0VuY29kaW5nIiwiRXJyb3IiLCJpc0Zpbml0ZUludGVnZXIiLCJpc0Zpbml0ZSIsImlzSW50ZWdlciIsImNoZWNrT2Zmc2V0T3JMZW5ndGhWYWx1ZSIsIm9mZnNldCIsImNoZWNrTGVuZ3RoVmFsdWUiLCJsZW5ndGgiLCJjaGVja09mZnNldFZhbHVlIiwiY2hlY2tUYXJnZXRPZmZzZXQiLCJidWZmIiwiTWF0aCIsImZsb29yIiwiYmlnSW50QW5kQnVmZmVySW50NjRDaGVjayIsImJ1ZmZlck1ldGhvZCIsIkJpZ0ludCIsInByb3RvdHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/smart-buffer/build/utils.js\n");

/***/ })

};
;