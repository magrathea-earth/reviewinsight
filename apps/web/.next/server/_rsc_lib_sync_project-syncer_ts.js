"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_rsc_lib_sync_project-syncer_ts";
exports.ids = ["_rsc_lib_sync_project-syncer_ts"];
exports.modules = {

/***/ "(rsc)/./lib/sync/adapters/app-store-adapter.ts":
/*!************************************************!*\
  !*** ./lib/sync/adapters/app-store-adapter.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppStoreAdapter: () => (/* binding */ AppStoreAdapter)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(rsc)/../../node_modules/axios/lib/axios.js\");\n\nclass AppStoreAdapter {\n    constructor(){\n        this.apiKey = process.env.SERPAPI_API_KEY || \"\";\n    }\n    async fetchReviews(input, since) {\n        let appId = input.trim();\n        // Extract ID from URL if provided (e.g., https://apps.apple.com/us/app/twitter/id333903271)\n        // Matches \"id\" followed by digits\n        const idMatch = input.match(/id(\\d+)/);\n        if (idMatch) {\n            appId = idMatch[1];\n        }\n        console.log(`Fetching App Store reviews for ${appId} (Input: ${input}) via SerpApi`);\n        if (!this.apiKey || this.apiKey === \"your_serpapi_key_here\") {\n            console.warn(\"SerpApi key not set, returning empty results\");\n            return {\n                items: [],\n                errors: [\n                    \"SerpApi key not configured\"\n                ]\n            };\n        }\n        try {\n            let allReviews = [];\n            let page = 1;\n            const MAX_REVIEWS = 100;\n            while(allReviews.length < MAX_REVIEWS){\n                console.log(`Fetching App Store reviews page ${page}...`);\n                const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"https://serpapi.com/search\", {\n                    params: {\n                        engine: \"apple_reviews\",\n                        product_id: appId,\n                        api_key: this.apiKey,\n                        page: page,\n                        num: 10 // Requesting more, though it seems capped at 10-25 per page often\n                    }\n                });\n                const reviews = response.data.reviews || [];\n                if (reviews.length === 0) break;\n                // Check dates to see if we reached past the 'since' window\n                let stopPaging = false;\n                if (since) {\n                    for (const r of reviews){\n                        const rDate = r.review_date ? new Date(r.review_date) : r.date ? new Date(r.date) : new Date();\n                        if (rDate < since) {\n                            stopPaging = true;\n                        // We don't break here because we want to include the current batch potentially, \n                        // or just filter later. But we know we don't need *next* page.\n                        }\n                    }\n                }\n                allReviews = [\n                    ...allReviews,\n                    ...reviews\n                ];\n                if (stopPaging) {\n                    console.log(\"Reached reviews older than sync window, stopping pagination.\");\n                    break;\n                }\n                // Check if we have a next page\n                if (!response.data.serpapi_pagination?.next) break;\n                page++;\n                // Safety break to avoid infinite loops\n                if (page > 10) break;\n            }\n            console.log(`Found total ${allReviews.length} reviews for App Store ID ${appId}`);\n            const items = allReviews.map((r)=>({\n                    externalId: r.id || `as_${Math.random()}`,\n                    platform: \"APP_STORE\",\n                    text: r.text || r.title || \"\",\n                    rating: r.rating || 0,\n                    author: r.author?.name || r.user_name || \"Anonymous\",\n                    createdAt: r.review_date ? new Date(r.review_date) : r.date ? new Date(r.date) : new Date(),\n                    url: r.link || `https://apps.apple.com/app/id${appId}`\n                }));\n            // Deduplicate by externalId just in case\n            const uniqueItems = Array.from(new Map(items.map((item)=>[\n                    item.externalId,\n                    item\n                ])).values()).filter((item)=>{\n                if (!since) return true;\n                return item.createdAt ? item.createdAt >= since : true;\n            });\n            return {\n                items: uniqueItems,\n                errors: []\n            };\n        } catch (error) {\n            console.error(\"SerpApi App Store error:\", error.response?.data || error.message);\n            return {\n                items: [],\n                errors: [\n                    error.message\n                ]\n            };\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvc3luYy9hZGFwdGVycy9hcHAtc3RvcmUtYWRhcHRlci50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUUwQjtBQUVuQixNQUFNQztJQUdUQyxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxNQUFNLEdBQUdDLFFBQVFDLEdBQUcsQ0FBQ0MsZUFBZSxJQUFJO0lBQ2pEO0lBRUEsTUFBTUMsYUFBYUMsS0FBYSxFQUFFQyxLQUFZLEVBQXlCO1FBQ25FLElBQUlDLFFBQVFGLE1BQU1HLElBQUk7UUFFdEIsNEZBQTRGO1FBQzVGLGtDQUFrQztRQUNsQyxNQUFNQyxVQUFVSixNQUFNSyxLQUFLLENBQUM7UUFDNUIsSUFBSUQsU0FBUztZQUNURixRQUFRRSxPQUFPLENBQUMsRUFBRTtRQUN0QjtRQUVBRSxRQUFRQyxHQUFHLENBQUMsQ0FBQywrQkFBK0IsRUFBRUwsTUFBTSxTQUFTLEVBQUVGLE1BQU0sYUFBYSxDQUFDO1FBRW5GLElBQUksQ0FBQyxJQUFJLENBQUNMLE1BQU0sSUFBSSxJQUFJLENBQUNBLE1BQU0sS0FBSyx5QkFBeUI7WUFDekRXLFFBQVFFLElBQUksQ0FBQztZQUNiLE9BQU87Z0JBQUVDLE9BQU8sRUFBRTtnQkFBRUMsUUFBUTtvQkFBQztpQkFBNkI7WUFBQztRQUMvRDtRQUVBLElBQUk7WUFDQSxJQUFJQyxhQUFvQixFQUFFO1lBQzFCLElBQUlDLE9BQU87WUFDWCxNQUFNQyxjQUFjO1lBRXBCLE1BQU9GLFdBQVdHLE1BQU0sR0FBR0QsWUFBYTtnQkFDcENQLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLGdDQUFnQyxFQUFFSyxLQUFLLEdBQUcsQ0FBQztnQkFDeEQsTUFBTUcsV0FBVyxNQUFNdkIsNkNBQUtBLENBQUN3QixHQUFHLENBQUMsOEJBQThCO29CQUMzREMsUUFBUTt3QkFDSkMsUUFBUTt3QkFDUkMsWUFBWWpCO3dCQUNaa0IsU0FBUyxJQUFJLENBQUN6QixNQUFNO3dCQUNwQmlCLE1BQU1BO3dCQUNOUyxLQUFLLEdBQUcsa0VBQWtFO29CQUM5RTtnQkFDSjtnQkFFQSxNQUFNQyxVQUFVUCxTQUFTUSxJQUFJLENBQUNELE9BQU8sSUFBSSxFQUFFO2dCQUMzQyxJQUFJQSxRQUFRUixNQUFNLEtBQUssR0FBRztnQkFFMUIsMkRBQTJEO2dCQUMzRCxJQUFJVSxhQUFhO2dCQUNqQixJQUFJdkIsT0FBTztvQkFDUCxLQUFLLE1BQU13QixLQUFLSCxRQUFTO3dCQUNyQixNQUFNSSxRQUFRRCxFQUFFRSxXQUFXLEdBQUcsSUFBSUMsS0FBS0gsRUFBRUUsV0FBVyxJQUFLRixFQUFFSSxJQUFJLEdBQUcsSUFBSUQsS0FBS0gsRUFBRUksSUFBSSxJQUFJLElBQUlEO3dCQUN6RixJQUFJRixRQUFRekIsT0FBTzs0QkFDZnVCLGFBQWE7d0JBQ2IsaUZBQWlGO3dCQUNqRiwrREFBK0Q7d0JBQ25FO29CQUNKO2dCQUNKO2dCQUVBYixhQUFhO3VCQUFJQTt1QkFBZVc7aUJBQVE7Z0JBRXhDLElBQUlFLFlBQVk7b0JBQ1psQixRQUFRQyxHQUFHLENBQUM7b0JBQ1o7Z0JBQ0o7Z0JBRUEsK0JBQStCO2dCQUMvQixJQUFJLENBQUNRLFNBQVNRLElBQUksQ0FBQ08sa0JBQWtCLEVBQUVDLE1BQU07Z0JBRTdDbkI7Z0JBQ0EsdUNBQXVDO2dCQUN2QyxJQUFJQSxPQUFPLElBQUk7WUFDbkI7WUFFQU4sUUFBUUMsR0FBRyxDQUFDLENBQUMsWUFBWSxFQUFFSSxXQUFXRyxNQUFNLENBQUMsMEJBQTBCLEVBQUVaLE1BQU0sQ0FBQztZQUVoRixNQUFNTyxRQUErQkUsV0FBV3FCLEdBQUcsQ0FBQyxDQUFDUCxJQUFZO29CQUM3RFEsWUFBWVIsRUFBRVMsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFQyxLQUFLQyxNQUFNLEdBQUcsQ0FBQztvQkFDekNDLFVBQVU7b0JBQ1ZDLE1BQU1iLEVBQUVhLElBQUksSUFBSWIsRUFBRWMsS0FBSyxJQUFJO29CQUMzQkMsUUFBUWYsRUFBRWUsTUFBTSxJQUFJO29CQUNwQkMsUUFBUWhCLEVBQUVnQixNQUFNLEVBQUVDLFFBQVFqQixFQUFFa0IsU0FBUyxJQUFJO29CQUN6Q0MsV0FBV25CLEVBQUVFLFdBQVcsR0FBRyxJQUFJQyxLQUFLSCxFQUFFRSxXQUFXLElBQUtGLEVBQUVJLElBQUksR0FBRyxJQUFJRCxLQUFLSCxFQUFFSSxJQUFJLElBQUksSUFBSUQ7b0JBQ3RGaUIsS0FBS3BCLEVBQUVxQixJQUFJLElBQUksQ0FBQyw2QkFBNkIsRUFBRTVDLE1BQU0sQ0FBQztnQkFDMUQ7WUFFQSx5Q0FBeUM7WUFDekMsTUFBTTZDLGNBQWNDLE1BQU1DLElBQUksQ0FBQyxJQUFJQyxJQUFJekMsTUFBTXVCLEdBQUcsQ0FBQ21CLENBQUFBLE9BQVE7b0JBQUNBLEtBQUtsQixVQUFVO29CQUFFa0I7aUJBQUssR0FBR0MsTUFBTSxJQUNwRkMsTUFBTSxDQUFDRixDQUFBQTtnQkFDSixJQUFJLENBQUNsRCxPQUFPLE9BQU87Z0JBQ25CLE9BQU9rRCxLQUFLUCxTQUFTLEdBQUdPLEtBQUtQLFNBQVMsSUFBSTNDLFFBQVE7WUFDdEQ7WUFFSixPQUFPO2dCQUFFUSxPQUFPc0M7Z0JBQWFyQyxRQUFRLEVBQUU7WUFBQztRQUM1QyxFQUFFLE9BQU80QyxPQUFZO1lBQ2pCaEQsUUFBUWdELEtBQUssQ0FBQyw0QkFBNEJBLE1BQU12QyxRQUFRLEVBQUVRLFFBQVErQixNQUFNQyxPQUFPO1lBQy9FLE9BQU87Z0JBQUU5QyxPQUFPLEVBQUU7Z0JBQUVDLFFBQVE7b0JBQUM0QyxNQUFNQyxPQUFPO2lCQUFDO1lBQUM7UUFDaEQ7SUFDSjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbGliL3N5bmMvYWRhcHRlcnMvYXBwLXN0b3JlLWFkYXB0ZXIudHM/NmZmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFBsYXRmb3JtLCBSZXZpZXdJdGVtIH0gZnJvbSBcIkByZXBvL3NoYXJlZFwiO1xyXG5pbXBvcnQgdHlwZSB7IEluZ2VzdFJlc3VsdCB9IGZyb20gXCIuL3R5cGVzXCI7XHJcbmltcG9ydCBheGlvcyBmcm9tIFwiYXhpb3NcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBBcHBTdG9yZUFkYXB0ZXIge1xyXG4gICAgcHJpdmF0ZSBhcGlLZXk6IHN0cmluZztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmFwaUtleSA9IHByb2Nlc3MuZW52LlNFUlBBUElfQVBJX0tFWSB8fCBcIlwiO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGZldGNoUmV2aWV3cyhpbnB1dDogc3RyaW5nLCBzaW5jZT86IERhdGUpOiBQcm9taXNlPEluZ2VzdFJlc3VsdD4ge1xyXG4gICAgICAgIGxldCBhcHBJZCA9IGlucHV0LnRyaW0oKTtcclxuXHJcbiAgICAgICAgLy8gRXh0cmFjdCBJRCBmcm9tIFVSTCBpZiBwcm92aWRlZCAoZS5nLiwgaHR0cHM6Ly9hcHBzLmFwcGxlLmNvbS91cy9hcHAvdHdpdHRlci9pZDMzMzkwMzI3MSlcclxuICAgICAgICAvLyBNYXRjaGVzIFwiaWRcIiBmb2xsb3dlZCBieSBkaWdpdHNcclxuICAgICAgICBjb25zdCBpZE1hdGNoID0gaW5wdXQubWF0Y2goL2lkKFxcZCspLyk7XHJcbiAgICAgICAgaWYgKGlkTWF0Y2gpIHtcclxuICAgICAgICAgICAgYXBwSWQgPSBpZE1hdGNoWzFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYEZldGNoaW5nIEFwcCBTdG9yZSByZXZpZXdzIGZvciAke2FwcElkfSAoSW5wdXQ6ICR7aW5wdXR9KSB2aWEgU2VycEFwaWApO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuYXBpS2V5IHx8IHRoaXMuYXBpS2V5ID09PSBcInlvdXJfc2VycGFwaV9rZXlfaGVyZVwiKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNlcnBBcGkga2V5IG5vdCBzZXQsIHJldHVybmluZyBlbXB0eSByZXN1bHRzXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4geyBpdGVtczogW10sIGVycm9yczogW1wiU2VycEFwaSBrZXkgbm90IGNvbmZpZ3VyZWRcIl0gfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCBhbGxSZXZpZXdzOiBhbnlbXSA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgcGFnZSA9IDE7XHJcbiAgICAgICAgICAgIGNvbnN0IE1BWF9SRVZJRVdTID0gMTAwO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKGFsbFJldmlld3MubGVuZ3RoIDwgTUFYX1JFVklFV1MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyBBcHAgU3RvcmUgcmV2aWV3cyBwYWdlICR7cGFnZX0uLi5gKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KFwiaHR0cHM6Ly9zZXJwYXBpLmNvbS9zZWFyY2hcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmdpbmU6IFwiYXBwbGVfcmV2aWV3c1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0X2lkOiBhcHBJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBpX2tleTogdGhpcy5hcGlLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2U6IHBhZ2UsIC8vIFVzZSBwYWdlIHBhcmFtZXRlciBmb3IgcGFnaW5hdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW06IDEwIC8vIFJlcXVlc3RpbmcgbW9yZSwgdGhvdWdoIGl0IHNlZW1zIGNhcHBlZCBhdCAxMC0yNSBwZXIgcGFnZSBvZnRlblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHJldmlld3MgPSByZXNwb25zZS5kYXRhLnJldmlld3MgfHwgW107XHJcbiAgICAgICAgICAgICAgICBpZiAocmV2aWV3cy5sZW5ndGggPT09IDApIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGRhdGVzIHRvIHNlZSBpZiB3ZSByZWFjaGVkIHBhc3QgdGhlICdzaW5jZScgd2luZG93XHJcbiAgICAgICAgICAgICAgICBsZXQgc3RvcFBhZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCByIG9mIHJldmlld3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgckRhdGUgPSByLnJldmlld19kYXRlID8gbmV3IERhdGUoci5yZXZpZXdfZGF0ZSkgOiAoci5kYXRlID8gbmV3IERhdGUoci5kYXRlKSA6IG5ldyBEYXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAockRhdGUgPCBzaW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcFBhZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBicmVhayBoZXJlIGJlY2F1c2Ugd2Ugd2FudCB0byBpbmNsdWRlIHRoZSBjdXJyZW50IGJhdGNoIHBvdGVudGlhbGx5LCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIGp1c3QgZmlsdGVyIGxhdGVyLiBCdXQgd2Uga25vdyB3ZSBkb24ndCBuZWVkICpuZXh0KiBwYWdlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGFsbFJldmlld3MgPSBbLi4uYWxsUmV2aWV3cywgLi4ucmV2aWV3c107XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHN0b3BQYWdpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlJlYWNoZWQgcmV2aWV3cyBvbGRlciB0aGFuIHN5bmMgd2luZG93LCBzdG9wcGluZyBwYWdpbmF0aW9uLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGEgbmV4dCBwYWdlXHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLmRhdGEuc2VycGFwaV9wYWdpbmF0aW9uPy5uZXh0KSBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBwYWdlKys7XHJcbiAgICAgICAgICAgICAgICAvLyBTYWZldHkgYnJlYWsgdG8gYXZvaWQgaW5maW5pdGUgbG9vcHNcclxuICAgICAgICAgICAgICAgIGlmIChwYWdlID4gMTApIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgdG90YWwgJHthbGxSZXZpZXdzLmxlbmd0aH0gcmV2aWV3cyBmb3IgQXBwIFN0b3JlIElEICR7YXBwSWR9YCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBpdGVtczogUGFydGlhbDxSZXZpZXdJdGVtPltdID0gYWxsUmV2aWV3cy5tYXAoKHI6IGFueSkgPT4gKHtcclxuICAgICAgICAgICAgICAgIGV4dGVybmFsSWQ6IHIuaWQgfHwgYGFzXyR7TWF0aC5yYW5kb20oKX1gLFxyXG4gICAgICAgICAgICAgICAgcGxhdGZvcm06IFwiQVBQX1NUT1JFXCIgYXMgUGxhdGZvcm0sXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiByLnRleHQgfHwgci50aXRsZSB8fCBcIlwiLFxyXG4gICAgICAgICAgICAgICAgcmF0aW5nOiByLnJhdGluZyB8fCAwLFxyXG4gICAgICAgICAgICAgICAgYXV0aG9yOiByLmF1dGhvcj8ubmFtZSB8fCByLnVzZXJfbmFtZSB8fCBcIkFub255bW91c1wiLFxyXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiByLnJldmlld19kYXRlID8gbmV3IERhdGUoci5yZXZpZXdfZGF0ZSkgOiAoci5kYXRlID8gbmV3IERhdGUoci5kYXRlKSA6IG5ldyBEYXRlKCkpLFxyXG4gICAgICAgICAgICAgICAgdXJsOiByLmxpbmsgfHwgYGh0dHBzOi8vYXBwcy5hcHBsZS5jb20vYXBwL2lkJHthcHBJZH1gXHJcbiAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERlZHVwbGljYXRlIGJ5IGV4dGVybmFsSWQganVzdCBpbiBjYXNlXHJcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZUl0ZW1zID0gQXJyYXkuZnJvbShuZXcgTWFwKGl0ZW1zLm1hcChpdGVtID0+IFtpdGVtLmV4dGVybmFsSWQsIGl0ZW1dKSkudmFsdWVzKCkpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2luY2UpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmNyZWF0ZWRBdCA/IGl0ZW0uY3JlYXRlZEF0ID49IHNpbmNlIDogdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHsgaXRlbXM6IHVuaXF1ZUl0ZW1zLCBlcnJvcnM6IFtdIH07XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiU2VycEFwaSBBcHAgU3RvcmUgZXJyb3I6XCIsIGVycm9yLnJlc3BvbnNlPy5kYXRhIHx8IGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICByZXR1cm4geyBpdGVtczogW10sIGVycm9yczogW2Vycm9yLm1lc3NhZ2VdIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJheGlvcyIsIkFwcFN0b3JlQWRhcHRlciIsImNvbnN0cnVjdG9yIiwiYXBpS2V5IiwicHJvY2VzcyIsImVudiIsIlNFUlBBUElfQVBJX0tFWSIsImZldGNoUmV2aWV3cyIsImlucHV0Iiwic2luY2UiLCJhcHBJZCIsInRyaW0iLCJpZE1hdGNoIiwibWF0Y2giLCJjb25zb2xlIiwibG9nIiwid2FybiIsIml0ZW1zIiwiZXJyb3JzIiwiYWxsUmV2aWV3cyIsInBhZ2UiLCJNQVhfUkVWSUVXUyIsImxlbmd0aCIsInJlc3BvbnNlIiwiZ2V0IiwicGFyYW1zIiwiZW5naW5lIiwicHJvZHVjdF9pZCIsImFwaV9rZXkiLCJudW0iLCJyZXZpZXdzIiwiZGF0YSIsInN0b3BQYWdpbmciLCJyIiwickRhdGUiLCJyZXZpZXdfZGF0ZSIsIkRhdGUiLCJkYXRlIiwic2VycGFwaV9wYWdpbmF0aW9uIiwibmV4dCIsIm1hcCIsImV4dGVybmFsSWQiLCJpZCIsIk1hdGgiLCJyYW5kb20iLCJwbGF0Zm9ybSIsInRleHQiLCJ0aXRsZSIsInJhdGluZyIsImF1dGhvciIsIm5hbWUiLCJ1c2VyX25hbWUiLCJjcmVhdGVkQXQiLCJ1cmwiLCJsaW5rIiwidW5pcXVlSXRlbXMiLCJBcnJheSIsImZyb20iLCJNYXAiLCJpdGVtIiwidmFsdWVzIiwiZmlsdGVyIiwiZXJyb3IiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/sync/adapters/app-store-adapter.ts\n");

/***/ }),

/***/ "(rsc)/./lib/sync/adapters/google-play-adapter.ts":
/*!**************************************************!*\
  !*** ./lib/sync/adapters/google-play-adapter.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GooglePlayAdapter: () => (/* binding */ GooglePlayAdapter)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(rsc)/../../node_modules/axios/lib/axios.js\");\n\nclass GooglePlayAdapter {\n    constructor(){\n        this.apiKey = process.env.SERPAPI_API_KEY || \"\";\n    }\n    async fetchReviews(input, since) {\n        let packageName = input.trim();\n        // Extract package name from URL if provided\n        if (input.includes(\"id=\")) {\n            packageName = input.split(\"id=\")[1].split(\"&\")[0];\n        } else if (input.includes(\"details/\")) {\n            packageName = input.split(\"details/\")[1].split(\"/\")[0].split(\"?\")[0];\n        }\n        console.log(`Fetching Google Play reviews for ${packageName} via SerpApi`);\n        if (!this.apiKey || this.apiKey === \"your_serpapi_key_here\") {\n            console.warn(\"SerpApi key not set, returning empty results\");\n            return {\n                items: [],\n                errors: [\n                    \"SerpApi key not configured\"\n                ]\n            };\n        }\n        try {\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"https://serpapi.com/search\", {\n                params: {\n                    no_cache: \"true\",\n                    engine: \"google_play_product\",\n                    store: \"apps\",\n                    product_id: packageName,\n                    api_key: this.apiKey,\n                    all_reviews: \"true\",\n                    sort: \"1\",\n                    num: 100\n                }\n            });\n            console.log(\"SerpApi Response Keys:\", Object.keys(response.data));\n            const reviews = response.data.reviews || [];\n            if (!response.data.reviews) {\n                console.warn(\"WARNING: 'reviews' key missing in SerpApi response. Full Response:\", JSON.stringify(response.data).substring(0, 1000));\n            }\n            console.log(`Found ${reviews.length} reviews in response`);\n            if (reviews.length > 0) {\n                console.log(`First review date: ${reviews[0].iso_date || reviews[0].date}`);\n            }\n            const items = reviews.map((r)=>{\n                // Handle various date formats if iso_date is missing\n                let createdAt = new Date();\n                if (r.iso_date) {\n                    createdAt = new Date(r.iso_date);\n                } else if (r.date) {\n                    // Try parsing \"January 21, 2024\"\n                    const parsed = Date.parse(r.date);\n                    if (!isNaN(parsed)) {\n                        createdAt = new Date(parsed);\n                    } else {\n                        console.warn(`Could not parse date: ${r.date}`);\n                    }\n                }\n                return {\n                    externalId: r.id || `gp_${Math.random()}`,\n                    platform: \"GOOGLE_PLAY\",\n                    text: r.snippet || r.text || \"\",\n                    rating: r.rating || 0,\n                    author: r.title || \"Anonymous\",\n                    createdAt,\n                    url: r.link || `https://play.google.com/store/apps/details?id=${packageName}&reviewId=${r.id}`\n                };\n            }).filter((item)=>{\n                if (!since) return true;\n                return item.createdAt ? item.createdAt >= since : true;\n            });\n            return {\n                items,\n                errors: []\n            };\n        } catch (error) {\n            console.error(\"SerpApi error:\", error.response?.data || error.message);\n            return {\n                items: [],\n                errors: [\n                    error.message\n                ]\n            };\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvc3luYy9hZGFwdGVycy9nb29nbGUtcGxheS1hZGFwdGVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBRTBCO0FBRW5CLE1BQU1DO0lBR1RDLGFBQWM7UUFDVixJQUFJLENBQUNDLE1BQU0sR0FBR0MsUUFBUUMsR0FBRyxDQUFDQyxlQUFlLElBQUk7SUFDakQ7SUFFQSxNQUFNQyxhQUFhQyxLQUFhLEVBQUVDLEtBQVksRUFBeUI7UUFDbkUsSUFBSUMsY0FBY0YsTUFBTUcsSUFBSTtRQUU1Qiw0Q0FBNEM7UUFDNUMsSUFBSUgsTUFBTUksUUFBUSxDQUFDLFFBQVE7WUFDdkJGLGNBQWNGLE1BQU1LLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDQSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDckQsT0FBTyxJQUFJTCxNQUFNSSxRQUFRLENBQUMsYUFBYTtZQUNuQ0YsY0FBY0YsTUFBTUssS0FBSyxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUNBLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDQSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDeEU7UUFFQUMsUUFBUUMsR0FBRyxDQUFDLENBQUMsaUNBQWlDLEVBQUVMLFlBQVksWUFBWSxDQUFDO1FBRXpFLElBQUksQ0FBQyxJQUFJLENBQUNQLE1BQU0sSUFBSSxJQUFJLENBQUNBLE1BQU0sS0FBSyx5QkFBeUI7WUFDekRXLFFBQVFFLElBQUksQ0FBQztZQUNiLE9BQU87Z0JBQUVDLE9BQU8sRUFBRTtnQkFBRUMsUUFBUTtvQkFBQztpQkFBNkI7WUFBQztRQUMvRDtRQUVBLElBQUk7WUFDQSxNQUFNQyxXQUFXLE1BQU1uQiw2Q0FBS0EsQ0FBQ29CLEdBQUcsQ0FBQyw4QkFBOEI7Z0JBQzNEQyxRQUFRO29CQUNKQyxVQUFVO29CQUNWQyxRQUFRO29CQUNSQyxPQUFPO29CQUNQQyxZQUFZZjtvQkFDWmdCLFNBQVMsSUFBSSxDQUFDdkIsTUFBTTtvQkFDcEJ3QixhQUFhO29CQUNiQyxNQUFNO29CQUNOQyxLQUFLO2dCQUNUO1lBQ0o7WUFFQWYsUUFBUUMsR0FBRyxDQUFDLDBCQUEwQmUsT0FBT0MsSUFBSSxDQUFDWixTQUFTYSxJQUFJO1lBQy9ELE1BQU1DLFVBQVVkLFNBQVNhLElBQUksQ0FBQ0MsT0FBTyxJQUFJLEVBQUU7WUFFM0MsSUFBSSxDQUFDZCxTQUFTYSxJQUFJLENBQUNDLE9BQU8sRUFBRTtnQkFDeEJuQixRQUFRRSxJQUFJLENBQUMsc0VBQXNFa0IsS0FBS0MsU0FBUyxDQUFDaEIsU0FBU2EsSUFBSSxFQUFFSSxTQUFTLENBQUMsR0FBRztZQUNsSTtZQUNBdEIsUUFBUUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFa0IsUUFBUUksTUFBTSxDQUFDLG9CQUFvQixDQUFDO1lBQ3pELElBQUlKLFFBQVFJLE1BQU0sR0FBRyxHQUFHO2dCQUNwQnZCLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLG1CQUFtQixFQUFFa0IsT0FBTyxDQUFDLEVBQUUsQ0FBQ0ssUUFBUSxJQUFJTCxPQUFPLENBQUMsRUFBRSxDQUFDTSxJQUFJLENBQUMsQ0FBQztZQUM5RTtZQUVBLE1BQU10QixRQUErQmdCLFFBQVFPLEdBQUcsQ0FBQyxDQUFDQztnQkFDOUMscURBQXFEO2dCQUNyRCxJQUFJQyxZQUFZLElBQUlDO2dCQUNwQixJQUFJRixFQUFFSCxRQUFRLEVBQUU7b0JBQ1pJLFlBQVksSUFBSUMsS0FBS0YsRUFBRUgsUUFBUTtnQkFDbkMsT0FBTyxJQUFJRyxFQUFFRixJQUFJLEVBQUU7b0JBQ2YsaUNBQWlDO29CQUNqQyxNQUFNSyxTQUFTRCxLQUFLRSxLQUFLLENBQUNKLEVBQUVGLElBQUk7b0JBQ2hDLElBQUksQ0FBQ08sTUFBTUYsU0FBUzt3QkFDaEJGLFlBQVksSUFBSUMsS0FBS0M7b0JBQ3pCLE9BQU87d0JBQ0g5QixRQUFRRSxJQUFJLENBQUMsQ0FBQyxzQkFBc0IsRUFBRXlCLEVBQUVGLElBQUksQ0FBQyxDQUFDO29CQUNsRDtnQkFDSjtnQkFFQSxPQUFPO29CQUNIUSxZQUFZTixFQUFFTyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUVDLEtBQUtDLE1BQU0sR0FBRyxDQUFDO29CQUN6Q0MsVUFBVTtvQkFDVkMsTUFBTVgsRUFBRVksT0FBTyxJQUFJWixFQUFFVyxJQUFJLElBQUk7b0JBQzdCRSxRQUFRYixFQUFFYSxNQUFNLElBQUk7b0JBQ3BCQyxRQUFRZCxFQUFFZSxLQUFLLElBQUk7b0JBQ25CZDtvQkFDQWUsS0FBS2hCLEVBQUVpQixJQUFJLElBQUksQ0FBQyw4Q0FBOEMsRUFBRWhELFlBQVksVUFBVSxFQUFFK0IsRUFBRU8sRUFBRSxDQUFDLENBQUM7Z0JBQ2xHO1lBQ0osR0FBR1csTUFBTSxDQUFDQyxDQUFBQTtnQkFDTixJQUFJLENBQUNuRCxPQUFPLE9BQU87Z0JBQ25CLE9BQU9tRCxLQUFLbEIsU0FBUyxHQUFHa0IsS0FBS2xCLFNBQVMsSUFBSWpDLFFBQVE7WUFDdEQ7WUFFQSxPQUFPO2dCQUFFUTtnQkFBT0MsUUFBUSxFQUFFO1lBQUM7UUFDL0IsRUFBRSxPQUFPMkMsT0FBWTtZQUNqQi9DLFFBQVErQyxLQUFLLENBQUMsa0JBQWtCQSxNQUFNMUMsUUFBUSxFQUFFYSxRQUFRNkIsTUFBTUMsT0FBTztZQUNyRSxPQUFPO2dCQUFFN0MsT0FBTyxFQUFFO2dCQUFFQyxRQUFRO29CQUFDMkMsTUFBTUMsT0FBTztpQkFBQztZQUFDO1FBQ2hEO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL2xpYi9zeW5jL2FkYXB0ZXJzL2dvb2dsZS1wbGF5LWFkYXB0ZXIudHM/NzM2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFBsYXRmb3JtLCBSZXZpZXdJdGVtIH0gZnJvbSBcIkByZXBvL3NoYXJlZFwiO1xyXG5pbXBvcnQgdHlwZSB7IEluZ2VzdFJlc3VsdCB9IGZyb20gXCIuL3R5cGVzXCI7XHJcbmltcG9ydCBheGlvcyBmcm9tIFwiYXhpb3NcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVQbGF5QWRhcHRlciB7XHJcbiAgICBwcml2YXRlIGFwaUtleTogc3RyaW5nO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuYXBpS2V5ID0gcHJvY2Vzcy5lbnYuU0VSUEFQSV9BUElfS0VZIHx8IFwiXCI7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgZmV0Y2hSZXZpZXdzKGlucHV0OiBzdHJpbmcsIHNpbmNlPzogRGF0ZSk6IFByb21pc2U8SW5nZXN0UmVzdWx0PiB7XHJcbiAgICAgICAgbGV0IHBhY2thZ2VOYW1lID0gaW5wdXQudHJpbSgpO1xyXG5cclxuICAgICAgICAvLyBFeHRyYWN0IHBhY2thZ2UgbmFtZSBmcm9tIFVSTCBpZiBwcm92aWRlZFxyXG4gICAgICAgIGlmIChpbnB1dC5pbmNsdWRlcyhcImlkPVwiKSkge1xyXG4gICAgICAgICAgICBwYWNrYWdlTmFtZSA9IGlucHV0LnNwbGl0KFwiaWQ9XCIpWzFdLnNwbGl0KFwiJlwiKVswXTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmluY2x1ZGVzKFwiZGV0YWlscy9cIikpIHtcclxuICAgICAgICAgICAgcGFja2FnZU5hbWUgPSBpbnB1dC5zcGxpdChcImRldGFpbHMvXCIpWzFdLnNwbGl0KFwiL1wiKVswXS5zcGxpdChcIj9cIilbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgR29vZ2xlIFBsYXkgcmV2aWV3cyBmb3IgJHtwYWNrYWdlTmFtZX0gdmlhIFNlcnBBcGlgKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmFwaUtleSB8fCB0aGlzLmFwaUtleSA9PT0gXCJ5b3VyX3NlcnBhcGlfa2V5X2hlcmVcIikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJTZXJwQXBpIGtleSBub3Qgc2V0LCByZXR1cm5pbmcgZW1wdHkgcmVzdWx0c1wiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgaXRlbXM6IFtdLCBlcnJvcnM6IFtcIlNlcnBBcGkga2V5IG5vdCBjb25maWd1cmVkXCJdIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChcImh0dHBzOi8vc2VycGFwaS5jb20vc2VhcmNoXCIsIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtczoge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vX2NhY2hlOiBcInRydWVcIixcclxuICAgICAgICAgICAgICAgICAgICBlbmdpbmU6IFwiZ29vZ2xlX3BsYXlfcHJvZHVjdFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlOiBcImFwcHNcIixcclxuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0X2lkOiBwYWNrYWdlTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBhcGlfa2V5OiB0aGlzLmFwaUtleSxcclxuICAgICAgICAgICAgICAgICAgICBhbGxfcmV2aWV3czogXCJ0cnVlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc29ydDogXCIxXCIsIC8vIDEgPSBOZXdlc3QsIDAgPSBIZWxwZnVsXHJcbiAgICAgICAgICAgICAgICAgICAgbnVtOiAxMDBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNlcnBBcGkgUmVzcG9uc2UgS2V5czpcIiwgT2JqZWN0LmtleXMocmVzcG9uc2UuZGF0YSkpO1xyXG4gICAgICAgICAgICBjb25zdCByZXZpZXdzID0gcmVzcG9uc2UuZGF0YS5yZXZpZXdzIHx8IFtdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5kYXRhLnJldmlld3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIldBUk5JTkc6ICdyZXZpZXdzJyBrZXkgbWlzc2luZyBpbiBTZXJwQXBpIHJlc3BvbnNlLiBGdWxsIFJlc3BvbnNlOlwiLCBKU09OLnN0cmluZ2lmeShyZXNwb25zZS5kYXRhKS5zdWJzdHJpbmcoMCwgMTAwMCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke3Jldmlld3MubGVuZ3RofSByZXZpZXdzIGluIHJlc3BvbnNlYCk7XHJcbiAgICAgICAgICAgIGlmIChyZXZpZXdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGaXJzdCByZXZpZXcgZGF0ZTogJHtyZXZpZXdzWzBdLmlzb19kYXRlIHx8IHJldmlld3NbMF0uZGF0ZX1gKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgaXRlbXM6IFBhcnRpYWw8UmV2aWV3SXRlbT5bXSA9IHJldmlld3MubWFwKChyOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB2YXJpb3VzIGRhdGUgZm9ybWF0cyBpZiBpc29fZGF0ZSBpcyBtaXNzaW5nXHJcbiAgICAgICAgICAgICAgICBsZXQgY3JlYXRlZEF0ID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChyLmlzb19kYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlZEF0ID0gbmV3IERhdGUoci5pc29fZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHIuZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSBwYXJzaW5nIFwiSmFudWFyeSAyMSwgMjAyNFwiXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gRGF0ZS5wYXJzZShyLmRhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVkQXQgPSBuZXcgRGF0ZShwYXJzZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IHBhcnNlIGRhdGU6ICR7ci5kYXRlfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVybmFsSWQ6IHIuaWQgfHwgYGdwXyR7TWF0aC5yYW5kb20oKX1gLFxyXG4gICAgICAgICAgICAgICAgICAgIHBsYXRmb3JtOiBcIkdPT0dMRV9QTEFZXCIgYXMgUGxhdGZvcm0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogci5zbmlwcGV0IHx8IHIudGV4dCB8fCBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHJhdGluZzogci5yYXRpbmcgfHwgMCxcclxuICAgICAgICAgICAgICAgICAgICBhdXRob3I6IHIudGl0bGUgfHwgXCJBbm9ueW1vdXNcIixcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVkQXQsXHJcbiAgICAgICAgICAgICAgICAgICAgdXJsOiByLmxpbmsgfHwgYGh0dHBzOi8vcGxheS5nb29nbGUuY29tL3N0b3JlL2FwcHMvZGV0YWlscz9pZD0ke3BhY2thZ2VOYW1lfSZyZXZpZXdJZD0ke3IuaWR9YFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSkuZmlsdGVyKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzaW5jZSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5jcmVhdGVkQXQgPyBpdGVtLmNyZWF0ZWRBdCA+PSBzaW5jZSA6IHRydWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHsgaXRlbXMsIGVycm9yczogW10gfTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJTZXJwQXBpIGVycm9yOlwiLCBlcnJvci5yZXNwb25zZT8uZGF0YSB8fCBlcnJvci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgaXRlbXM6IFtdLCBlcnJvcnM6IFtlcnJvci5tZXNzYWdlXSB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOlsiYXhpb3MiLCJHb29nbGVQbGF5QWRhcHRlciIsImNvbnN0cnVjdG9yIiwiYXBpS2V5IiwicHJvY2VzcyIsImVudiIsIlNFUlBBUElfQVBJX0tFWSIsImZldGNoUmV2aWV3cyIsImlucHV0Iiwic2luY2UiLCJwYWNrYWdlTmFtZSIsInRyaW0iLCJpbmNsdWRlcyIsInNwbGl0IiwiY29uc29sZSIsImxvZyIsIndhcm4iLCJpdGVtcyIsImVycm9ycyIsInJlc3BvbnNlIiwiZ2V0IiwicGFyYW1zIiwibm9fY2FjaGUiLCJlbmdpbmUiLCJzdG9yZSIsInByb2R1Y3RfaWQiLCJhcGlfa2V5IiwiYWxsX3Jldmlld3MiLCJzb3J0IiwibnVtIiwiT2JqZWN0Iiwia2V5cyIsImRhdGEiLCJyZXZpZXdzIiwiSlNPTiIsInN0cmluZ2lmeSIsInN1YnN0cmluZyIsImxlbmd0aCIsImlzb19kYXRlIiwiZGF0ZSIsIm1hcCIsInIiLCJjcmVhdGVkQXQiLCJEYXRlIiwicGFyc2VkIiwicGFyc2UiLCJpc05hTiIsImV4dGVybmFsSWQiLCJpZCIsIk1hdGgiLCJyYW5kb20iLCJwbGF0Zm9ybSIsInRleHQiLCJzbmlwcGV0IiwicmF0aW5nIiwiYXV0aG9yIiwidGl0bGUiLCJ1cmwiLCJsaW5rIiwiZmlsdGVyIiwiaXRlbSIsImVycm9yIiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/sync/adapters/google-play-adapter.ts\n");

/***/ }),

/***/ "(rsc)/./lib/sync/adapters/index.ts":
/*!************************************!*\
  !*** ./lib/sync/adapters/index.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppStoreAdapter: () => (/* reexport safe */ _app_store_adapter__WEBPACK_IMPORTED_MODULE_2__.AppStoreAdapter),\n/* harmony export */   GooglePlayAdapter: () => (/* reexport safe */ _google_play_adapter__WEBPACK_IMPORTED_MODULE_1__.GooglePlayAdapter),\n/* harmony export */   InstagramAdapter: () => (/* reexport safe */ _instagram_adapter__WEBPACK_IMPORTED_MODULE_3__.InstagramAdapter),\n/* harmony export */   XAdapter: () => (/* reexport safe */ _x_adapter__WEBPACK_IMPORTED_MODULE_4__.XAdapter)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"(rsc)/./lib/sync/adapters/types.ts\");\n/* harmony import */ var _google_play_adapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./google-play-adapter */ \"(rsc)/./lib/sync/adapters/google-play-adapter.ts\");\n/* harmony import */ var _app_store_adapter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app-store-adapter */ \"(rsc)/./lib/sync/adapters/app-store-adapter.ts\");\n/* harmony import */ var _instagram_adapter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instagram-adapter */ \"(rsc)/./lib/sync/adapters/instagram-adapter.ts\");\n/* harmony import */ var _x_adapter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./x-adapter */ \"(rsc)/./lib/sync/adapters/x-adapter.ts\");\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvc3luYy9hZGFwdGVycy9pbmRleC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBd0I7QUFDYztBQUNGO0FBQ0E7QUFDUiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL2xpYi9zeW5jL2FkYXB0ZXJzL2luZGV4LnRzP2IxM2UiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4vdHlwZXNcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vZ29vZ2xlLXBsYXktYWRhcHRlclwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9hcHAtc3RvcmUtYWRhcHRlclwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9pbnN0YWdyYW0tYWRhcHRlclwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi94LWFkYXB0ZXJcIjtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/sync/adapters/index.ts\n");

/***/ }),

/***/ "(rsc)/./lib/sync/adapters/instagram-adapter.ts":
/*!************************************************!*\
  !*** ./lib/sync/adapters/instagram-adapter.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InstagramAdapter: () => (/* binding */ InstagramAdapter)\n/* harmony export */ });\n/* harmony import */ var apify_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apify-client */ \"(rsc)/../../node_modules/apify-client/dist/index.mjs\");\n\n/**\n * Fetches ONLY comments/replies ON the account's posts (from other people).\n * Does NOT fetch replies BY the account (comments the account wrote elsewhere).\n * Uses profile scraper to get posts authored by the account, then comment scraper on those post URLs.\n */ class InstagramAdapter {\n    constructor(){\n        this.client = new apify_client__WEBPACK_IMPORTED_MODULE_0__.ApifyClient({\n            token: process.env.APIFY_API_TOKEN || \"\"\n        });\n    }\n    async fetchComments(postUrls, since) {\n        console.log(`[InstagramAdapter] Fetching REPLIES ON the account's posts only (not replies BY the account)`);\n        if (!process.env.APIFY_API_TOKEN) {\n            console.warn(\"APIFY_API_TOKEN not set\");\n            return {\n                items: [],\n                errors: [\n                    \"APIFY_API_TOKEN not set\"\n                ]\n            };\n        }\n        try {\n            const query = postUrls.length > 0 ? postUrls[0] : \"\";\n            if (!query) return {\n                items: [],\n                errors: [\n                    \"No query provided\"\n                ]\n            };\n            let username = query;\n            if (query.includes(\"instagram.com\")) {\n                const parts = query.split(\"/\");\n                const idx = parts.findIndex((p)=>p.includes(\"instagram.com\"));\n                if (idx !== -1 && parts[idx + 1]) {\n                    username = parts[idx + 1];\n                }\n            }\n            username = username.replace(\"@\", \"\").split(\"?\")[0].trim();\n            if (!username) return {\n                items: [],\n                errors: [\n                    \"No username in query\"\n                ]\n            };\n            const accountUsernameLower = username.toLowerCase();\n            const cutoff30 = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n            const sinceDate = since && since > cutoff30 ? since : cutoff30;\n            // Step 1: Get posts authored BY this account (using instagram-scraper for better pagination)\n            console.log(`[InstagramAdapter] Step 1: Getting posts BY @${username} via apify/instagram-scraper`);\n            // \"apify/instagram-scraper\" is more robust for fetching a list of posts than \"profile-scraper\"\n            const postsRun = await this.client.actor(\"apify/instagram-scraper\").call({\n                usernames: [\n                    username\n                ],\n                resultsType: \"posts\",\n                resultsLimit: 50\n            });\n            if (!postsRun.defaultDatasetId) {\n                return {\n                    items: [],\n                    errors: [\n                        \"Instagram scraper failed to start\"\n                    ]\n                };\n            }\n            const { items: postsItems } = await this.client.dataset(postsRun.defaultDatasetId).listItems();\n            console.log(`[InstagramAdapter] Scraper found ${postsItems.length} raw posts`);\n            const accountPostUrls = new Set();\n            // The output of instagram-scraper is a list of posts\n            for (const p of postsItems){\n                // Filter by date\n                const postDate = p.timestamp || p.date || p.takenAt;\n                if (postDate && new Date(postDate) < sinceDate) {\n                    continue;\n                }\n                // Extract URL\n                const url = p.url || p.link || (p.shortCode ? `https://www.instagram.com/p/${p.shortCode}/` : null);\n                if (url) {\n                    // Ensure it's a valid post URL\n                    const normalized = normalizePostUrl(url);\n                    if (normalized) {\n                        accountPostUrls.add(normalized);\n                    }\n                }\n            }\n            const postUrlsList = Array.from(accountPostUrls);\n            console.log(`[InstagramAdapter] Identified ${postUrlsList.length} recent posts by @${username} (since ${sinceDate.toISOString()})`);\n            if (postUrlsList.length === 0) {\n                console.log(\"[InstagramAdapter] No recent posts found to check for comments.\");\n                return {\n                    items: [],\n                    errors: []\n                };\n            }\n            // Step 2: Get comments on those post URLs only\n            console.log(`[InstagramAdapter] Step 2: Fetching comments ON those ${postUrlsList.length} posts (apify/instagram-comment-scraper)`);\n            const commentsRun = await this.client.actor(\"apify/instagram-comment-scraper\").call({\n                directUrls: postUrlsList,\n                resultsLimit: 200\n            });\n            const allItems = [];\n            if (commentsRun.defaultDatasetId) {\n                const { items: comments } = await this.client.dataset(commentsRun.defaultDatasetId).listItems();\n                const raw = comments || [];\n                for (const comment of raw){\n                    const author = getCommentAuthor(comment);\n                    if (!author) continue;\n                    const authorLower = author.replace(\"@\", \"\").trim().toLowerCase();\n                    if (authorLower === accountUsernameLower) continue;\n                    if (authorLower === username.toLowerCase()) continue;\n                    const commentPostUrl = comment.postUrl || comment.url || comment.link || \"\";\n                    const normalizedCommentPost = normalizePostUrl(commentPostUrl);\n                    if (normalizedCommentPost && !accountPostUrls.has(normalizedCommentPost)) continue;\n                    const createdAt = new Date(comment.timestamp || comment.date || Date.now());\n                    if (since && createdAt < since) continue;\n                    allItems.push({\n                        externalId: String(comment.id),\n                        platform: \"INSTAGRAM\",\n                        text: comment.text || \"\",\n                        rating: 0,\n                        author: author.startsWith(\"@\") ? author : `@${author}`,\n                        createdAt,\n                        url: commentPostUrl || postUrlsList[0] || \"\"\n                    });\n                }\n            }\n            console.log(`[InstagramAdapter] Returning ${allItems.length} comments (replies ON @${username}'s posts, excluding @${username}'s own replies)`);\n            return {\n                items: allItems,\n                errors: []\n            };\n        } catch (error) {\n            console.error(\"[InstagramAdapter] Error:\", error);\n            return {\n                items: [],\n                errors: [\n                    error.message || \"Unknown Apify error\"\n                ]\n            };\n        }\n    }\n}\nfunction getCommentAuthor(c) {\n    const v = c.ownerUsername || c.owner?.username || c.user?.username || c.username || c.author || \"\";\n    return String(v || \"\").replace(/^@/, \"\").trim();\n}\nfunction normalizePostUrl(url) {\n    if (!url) return \"\";\n    try {\n        const u = String(url).trim().replace(/\\/$/, \"\");\n        const m = u.match(/instagram\\.com\\/p\\/([A-Za-z0-9_-]+)/);\n        return m ? `https://www.instagram.com/p/${m[1]}/` : u;\n    } catch  {\n        return url;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvc3luYy9hZGFwdGVycy9pbnN0YWdyYW0tYWRhcHRlci50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUUyQztBQUUzQzs7OztDQUlDLEdBQ00sTUFBTUM7SUFHVEMsYUFBYztRQUNWLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUlILHFEQUFXQSxDQUFDO1lBQzFCSSxPQUFPQyxRQUFRQyxHQUFHLENBQUNDLGVBQWUsSUFBSTtRQUMxQztJQUNKO0lBRUEsTUFBTUMsY0FBY0MsUUFBa0IsRUFBRUMsS0FBWSxFQUF5QjtRQUN6RUMsUUFBUUMsR0FBRyxDQUFDLENBQUMsNEZBQTRGLENBQUM7UUFFMUcsSUFBSSxDQUFDUCxRQUFRQyxHQUFHLENBQUNDLGVBQWUsRUFBRTtZQUM5QkksUUFBUUUsSUFBSSxDQUFDO1lBQ2IsT0FBTztnQkFBRUMsT0FBTyxFQUFFO2dCQUFFQyxRQUFRO29CQUFDO2lCQUEwQjtZQUFDO1FBQzVEO1FBRUEsSUFBSTtZQUNBLE1BQU1DLFFBQVFQLFNBQVNRLE1BQU0sR0FBRyxJQUFJUixRQUFRLENBQUMsRUFBRSxHQUFHO1lBQ2xELElBQUksQ0FBQ08sT0FBTyxPQUFPO2dCQUFFRixPQUFPLEVBQUU7Z0JBQUVDLFFBQVE7b0JBQUM7aUJBQW9CO1lBQUM7WUFFOUQsSUFBSUcsV0FBV0Y7WUFDZixJQUFJQSxNQUFNRyxRQUFRLENBQUMsa0JBQWtCO2dCQUNqQyxNQUFNQyxRQUFRSixNQUFNSyxLQUFLLENBQUM7Z0JBQzFCLE1BQU1DLE1BQU1GLE1BQU1HLFNBQVMsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUwsUUFBUSxDQUFDO2dCQUM1QyxJQUFJRyxRQUFRLENBQUMsS0FBS0YsS0FBSyxDQUFDRSxNQUFNLEVBQUUsRUFBRTtvQkFDOUJKLFdBQVdFLEtBQUssQ0FBQ0UsTUFBTSxFQUFFO2dCQUM3QjtZQUNKO1lBQ0FKLFdBQVdBLFNBQVNPLE9BQU8sQ0FBQyxLQUFLLElBQUlKLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDSyxJ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QUFRLEVBQUU7WUFBQztRQUN6QyxFQUFFLE9BQU9rRSxPQUFZO1lBQ2pCdEUsUUFBUXNFLEtBQUssQ0FBQyw2QkFBNkJBO1lBQzNDLE9BQU87Z0JBQUVuRSxPQUFPLEVBQUU7Z0JBQUVDLFFBQVE7b0JBQUNrRSxNQUFNQyxPQUFPLElBQUk7aUJBQXNCO1lBQUM7UUFDekU7SUFDSjtBQUNKO0FBRUEsU0FBU2hCLGlCQUFpQmlCLENBQU07SUFDNUIsTUFBTUMsSUFBSUQsRUFBRUUsYUFBYSxJQUFJRixFQUFFRyxLQUFLLEVBQUVwRSxZQUFZaUUsRUFBRUksSUFBSSxFQUFFckUsWUFBWWlFLEVBQUVqRSxRQUFRLElBQUlpRSxFQUFFbEIsTUFBTSxJQUFJO0lBQ2hHLE9BQU9VLE9BQU9TLEtBQUssSUFBSTNELE9BQU8sQ0FBQyxNQUFNLElBQUlDLElBQUk7QUFDakQ7QUFFQSxTQUFTMkIsaUJBQWlCSixHQUFXO0lBQ2pDLElBQUksQ0FBQ0EsS0FBSyxPQUFPO0lBQ2pCLElBQUk7UUFDQSxNQUFNdUMsSUFBSWIsT0FBTzFCLEtBQUt2QixJQUFJLEdBQUdELE9BQU8sQ0FBQyxPQUFPO1FBQzVDLE1BQU1nRSxJQUFJRCxFQUFFRSxLQUFLLENBQUM7UUFDbEIsT0FBT0QsSUFBSSxDQUFDLDRCQUE0QixFQUFFQSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHRDtJQUN4RCxFQUFFLE9BQU07UUFDSixPQUFPdkM7SUFDWDtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbGliL3N5bmMvYWRhcHRlcnMvaW5zdGFncmFtLWFkYXB0ZXIudHM/N2MyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFBsYXRmb3JtLCBSZXZpZXdJdGVtIH0gZnJvbSBcIkByZXBvL3NoYXJlZFwiO1xuaW1wb3J0IHR5cGUgeyBJbmdlc3RSZXN1bHQgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgQXBpZnlDbGllbnQgfSBmcm9tIFwiYXBpZnktY2xpZW50XCI7XG5cbi8qKlxuICogRmV0Y2hlcyBPTkxZIGNvbW1lbnRzL3JlcGxpZXMgT04gdGhlIGFjY291bnQncyBwb3N0cyAoZnJvbSBvdGhlciBwZW9wbGUpLlxuICogRG9lcyBOT1QgZmV0Y2ggcmVwbGllcyBCWSB0aGUgYWNjb3VudCAoY29tbWVudHMgdGhlIGFjY291bnQgd3JvdGUgZWxzZXdoZXJlKS5cbiAqIFVzZXMgcHJvZmlsZSBzY3JhcGVyIHRvIGdldCBwb3N0cyBhdXRob3JlZCBieSB0aGUgYWNjb3VudCwgdGhlbiBjb21tZW50IHNjcmFwZXIgb24gdGhvc2UgcG9zdCBVUkxzLlxuICovXG5leHBvcnQgY2xhc3MgSW5zdGFncmFtQWRhcHRlciB7XG4gICAgcHJpdmF0ZSBjbGllbnQ6IEFwaWZ5Q2xpZW50O1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gbmV3IEFwaWZ5Q2xpZW50KHtcbiAgICAgICAgICAgIHRva2VuOiBwcm9jZXNzLmVudi5BUElGWV9BUElfVE9LRU4gfHwgXCJcIixcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hDb21tZW50cyhwb3N0VXJsczogc3RyaW5nW10sIHNpbmNlPzogRGF0ZSk6IFByb21pc2U8SW5nZXN0UmVzdWx0PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbSW5zdGFncmFtQWRhcHRlcl0gRmV0Y2hpbmcgUkVQTElFUyBPTiB0aGUgYWNjb3VudCdzIHBvc3RzIG9ubHkgKG5vdCByZXBsaWVzIEJZIHRoZSBhY2NvdW50KWApO1xuXG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuQVBJRllfQVBJX1RPS0VOKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJBUElGWV9BUElfVE9LRU4gbm90IHNldFwiKTtcbiAgICAgICAgICAgIHJldHVybiB7IGl0ZW1zOiBbXSwgZXJyb3JzOiBbXCJBUElGWV9BUElfVE9LRU4gbm90IHNldFwiXSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gcG9zdFVybHMubGVuZ3RoID4gMCA/IHBvc3RVcmxzWzBdIDogXCJcIjtcbiAgICAgICAgICAgIGlmICghcXVlcnkpIHJldHVybiB7IGl0ZW1zOiBbXSwgZXJyb3JzOiBbXCJObyBxdWVyeSBwcm92aWRlZFwiXSB9O1xuXG4gICAgICAgICAgICBsZXQgdXNlcm5hbWUgPSBxdWVyeTtcbiAgICAgICAgICAgIGlmIChxdWVyeS5pbmNsdWRlcyhcImluc3RhZ3JhbS5jb21cIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHF1ZXJ5LnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpZHggPSBwYXJ0cy5maW5kSW5kZXgocCA9PiBwLmluY2x1ZGVzKFwiaW5zdGFncmFtLmNvbVwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEgJiYgcGFydHNbaWR4ICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWUgPSBwYXJ0c1tpZHggKyAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1c2VybmFtZSA9IHVzZXJuYW1lLnJlcGxhY2UoXCJAXCIsIFwiXCIpLnNwbGl0KFwiP1wiKVswXS50cmltKCk7XG4gICAgICAgICAgICBpZiAoIXVzZXJuYW1lKSByZXR1cm4geyBpdGVtczogW10sIGVycm9yczogW1wiTm8gdXNlcm5hbWUgaW4gcXVlcnlcIl0gfTtcblxuICAgICAgICAgICAgY29uc3QgYWNjb3VudFVzZXJuYW1lTG93ZXIgPSB1c2VybmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgY3V0b2ZmMzAgPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwKTtcbiAgICAgICAgICAgIGNvbnN0IHNpbmNlRGF0ZSA9IHNpbmNlICYmIHNpbmNlID4gY3V0b2ZmMzAgPyBzaW5jZSA6IGN1dG9mZjMwO1xuXG4gICAgICAgICAgICAvLyBTdGVwIDE6IEdldCBwb3N0cyBhdXRob3JlZCBCWSB0aGlzIGFjY291bnQgKHVzaW5nIGluc3RhZ3JhbS1zY3JhcGVyIGZvciBiZXR0ZXIgcGFnaW5hdGlvbilcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbSW5zdGFncmFtQWRhcHRlcl0gU3RlcCAxOiBHZXR0aW5nIHBvc3RzIEJZIEAke3VzZXJuYW1lfSB2aWEgYXBpZnkvaW5zdGFncmFtLXNjcmFwZXJgKTtcblxuICAgICAgICAgICAgLy8gXCJhcGlmeS9pbnN0YWdyYW0tc2NyYXBlclwiIGlzIG1vcmUgcm9idXN0IGZvciBmZXRjaGluZyBhIGxpc3Qgb2YgcG9zdHMgdGhhbiBcInByb2ZpbGUtc2NyYXBlclwiXG4gICAgICAgICAgICBjb25zdCBwb3N0c1J1biA9IGF3YWl0IHRoaXMuY2xpZW50LmFjdG9yKFwiYXBpZnkvaW5zdGFncmFtLXNjcmFwZXJcIikuY2FsbCh7XG4gICAgICAgICAgICAgICAgdXNlcm5hbWVzOiBbdXNlcm5hbWVdLFxuICAgICAgICAgICAgICAgIHJlc3VsdHNUeXBlOiBcInBvc3RzXCIsXG4gICAgICAgICAgICAgICAgcmVzdWx0c0xpbWl0OiA1MCwgLy8gRmV0Y2ggZW5vdWdoIHRvIGNvdmVyIDMwIGRheXMgKGFzc3VtaW5nIDwyIHBvc3RzL2RheSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIXBvc3RzUnVuLmRlZmF1bHREYXRhc2V0SWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpdGVtczogW10sIGVycm9yczogW1wiSW5zdGFncmFtIHNjcmFwZXIgZmFpbGVkIHRvIHN0YXJ0XCJdIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHsgaXRlbXM6IHBvc3RzSXRlbXMgfSA9IGF3YWl0IHRoaXMuY2xpZW50LmRhdGFzZXQocG9zdHNSdW4uZGVmYXVsdERhdGFzZXRJZCkubGlzdEl0ZW1zKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0luc3RhZ3JhbUFkYXB0ZXJdIFNjcmFwZXIgZm91bmQgJHtwb3N0c0l0ZW1zLmxlbmd0aH0gcmF3IHBvc3RzYCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRQb3N0VXJscyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgICAgICAgICAvLyBUaGUgb3V0cHV0IG9mIGluc3RhZ3JhbS1zY3JhcGVyIGlzIGEgbGlzdCBvZiBwb3N0c1xuICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIChwb3N0c0l0ZW1zIGFzIGFueVtdKSkge1xuICAgICAgICAgICAgICAgIC8vIEZpbHRlciBieSBkYXRlXG4gICAgICAgICAgICAgICAgY29uc3QgcG9zdERhdGUgPSBwLnRpbWVzdGFtcCB8fCBwLmRhdGUgfHwgcC50YWtlbkF0O1xuICAgICAgICAgICAgICAgIGlmIChwb3N0RGF0ZSAmJiBuZXcgRGF0ZShwb3N0RGF0ZSkgPCBzaW5jZURhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBVUkxcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBwLnVybCB8fCBwLmxpbmsgfHwgKHAuc2hvcnRDb2RlID8gYGh0dHBzOi8vd3d3Lmluc3RhZ3JhbS5jb20vcC8ke3Auc2hvcnRDb2RlfS9gIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgaXQncyBhIHZhbGlkIHBvc3QgVVJMXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVQb3N0VXJsKHVybCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50UG9zdFVybHMuYWRkKG5vcm1hbGl6ZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwb3N0VXJsc0xpc3QgPSBBcnJheS5mcm9tKGFjY291bnRQb3N0VXJscyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0luc3RhZ3JhbUFkYXB0ZXJdIElkZW50aWZpZWQgJHtwb3N0VXJsc0xpc3QubGVuZ3RofSByZWNlbnQgcG9zdHMgYnkgQCR7dXNlcm5hbWV9IChzaW5jZSAke3NpbmNlRGF0ZS50b0lTT1N0cmluZygpfSlgKTtcblxuICAgICAgICAgICAgaWYgKHBvc3RVcmxzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltJbnN0YWdyYW1BZGFwdGVyXSBObyByZWNlbnQgcG9zdHMgZm91bmQgdG8gY2hlY2sgZm9yIGNvbW1lbnRzLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpdGVtczogW10sIGVycm9yczogW10gfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RlcCAyOiBHZXQgY29tbWVudHMgb24gdGhvc2UgcG9zdCBVUkxzIG9ubHlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbSW5zdGFncmFtQWRhcHRlcl0gU3RlcCAyOiBGZXRjaGluZyBjb21tZW50cyBPTiB0aG9zZSAke3Bvc3RVcmxzTGlzdC5sZW5ndGh9IHBvc3RzIChhcGlmeS9pbnN0YWdyYW0tY29tbWVudC1zY3JhcGVyKWApO1xuICAgICAgICAgICAgY29uc3QgY29tbWVudHNSdW4gPSBhd2FpdCB0aGlzLmNsaWVudC5hY3RvcihcImFwaWZ5L2luc3RhZ3JhbS1jb21tZW50LXNjcmFwZXJcIikuY2FsbCh7XG4gICAgICAgICAgICAgICAgZGlyZWN0VXJsczogcG9zdFVybHNMaXN0LFxuICAgICAgICAgICAgICAgIHJlc3VsdHNMaW1pdDogMjAwLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFsbEl0ZW1zOiBQYXJ0aWFsPFJldmlld0l0ZW0+W10gPSBbXTtcblxuICAgICAgICAgICAgaWYgKGNvbW1lbnRzUnVuLmRlZmF1bHREYXRhc2V0SWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGl0ZW1zOiBjb21tZW50cyB9ID0gYXdhaXQgdGhpcy5jbGllbnQuZGF0YXNldChjb21tZW50c1J1bi5kZWZhdWx0RGF0YXNldElkKS5saXN0SXRlbXMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByYXcgPSAoY29tbWVudHMgfHwgW10pIGFzIGFueVtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb21tZW50IG9mIHJhdykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdXRob3IgPSBnZXRDb21tZW50QXV0aG9yKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWF1dGhvcikgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXV0aG9yTG93ZXIgPSBhdXRob3IucmVwbGFjZShcIkBcIiwgXCJcIikudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdXRob3JMb3dlciA9PT0gYWNjb3VudFVzZXJuYW1lTG93ZXIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXV0aG9yTG93ZXIgPT09IHVzZXJuYW1lLnRvTG93ZXJDYXNlKCkpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1lbnRQb3N0VXJsID0gY29tbWVudC5wb3N0VXJsIHx8IGNvbW1lbnQudXJsIHx8IGNvbW1lbnQubGluayB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkQ29tbWVudFBvc3QgPSBub3JtYWxpemVQb3N0VXJsKGNvbW1lbnRQb3N0VXJsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRDb21tZW50UG9zdCAmJiAhYWNjb3VudFBvc3RVcmxzLmhhcyhub3JtYWxpemVkQ29tbWVudFBvc3QpKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZShjb21tZW50LnRpbWVzdGFtcCB8fCBjb21tZW50LmRhdGUgfHwgRGF0ZS5ub3coKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaW5jZSAmJiBjcmVhdGVkQXQgPCBzaW5jZSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgYWxsSXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlcm5hbElkOiBTdHJpbmcoY29tbWVudC5pZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF0Zm9ybTogXCJJTlNUQUdSQU1cIiBhcyBQbGF0Zm9ybSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNvbW1lbnQudGV4dCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF0aW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aG9yOiBhdXRob3Iuc3RhcnRzV2l0aChcIkBcIikgPyBhdXRob3IgOiBgQCR7YXV0aG9yfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGNvbW1lbnRQb3N0VXJsIHx8IHBvc3RVcmxzTGlzdFswXSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbSW5zdGFncmFtQWRhcHRlcl0gUmV0dXJuaW5nICR7YWxsSXRlbXMubGVuZ3RofSBjb21tZW50cyAocmVwbGllcyBPTiBAJHt1c2VybmFtZX0ncyBwb3N0cywgZXhjbHVkaW5nIEAke3VzZXJuYW1lfSdzIG93biByZXBsaWVzKWApO1xuICAgICAgICAgICAgcmV0dXJuIHsgaXRlbXM6IGFsbEl0ZW1zLCBlcnJvcnM6IFtdIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbSW5zdGFncmFtQWRhcHRlcl0gRXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7IGl0ZW1zOiBbXSwgZXJyb3JzOiBbZXJyb3IubWVzc2FnZSB8fCBcIlVua25vd24gQXBpZnkgZXJyb3JcIl0gfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q29tbWVudEF1dGhvcihjOiBhbnkpOiBzdHJpbmcge1xuICAgIGNvbnN0IHYgPSBjLm93bmVyVXNlcm5hbWUgfHwgYy5vd25lcj8udXNlcm5hbWUgfHwgYy51c2VyPy51c2VybmFtZSB8fCBjLnVzZXJuYW1lIHx8IGMuYXV0aG9yIHx8IFwiXCI7XG4gICAgcmV0dXJuIFN0cmluZyh2IHx8IFwiXCIpLnJlcGxhY2UoL15ALywgXCJcIikudHJpbSgpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVQb3N0VXJsKHVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoIXVybCkgcmV0dXJuIFwiXCI7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdSA9IFN0cmluZyh1cmwpLnRyaW0oKS5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gICAgICAgIGNvbnN0IG0gPSB1Lm1hdGNoKC9pbnN0YWdyYW1cXC5jb21cXC9wXFwvKFtBLVphLXowLTlfLV0rKS8pO1xuICAgICAgICByZXR1cm4gbSA/IGBodHRwczovL3d3dy5pbnN0YWdyYW0uY29tL3AvJHttWzFdfS9gIDogdTtcbiAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiQXBpZnlDbGllbnQiLCJJbnN0YWdyYW1BZGFwdGVyIiwiY29uc3RydWN0b3IiLCJjbGllbnQiLCJ0b2tlbiIsInByb2Nlc3MiLCJlbnYiLCJBUElGWV9BUElfVE9LRU4iLCJmZXRjaENvbW1lbnRzIiwicG9zdFVybHMiLCJzaW5jZSIsImNvbnNvbGUiLCJsb2ciLCJ3YXJuIiwiaXRlbXMiLCJlcnJvcnMiLCJxdWVyeSIsImxlbmd0aCIsInVzZXJuYW1lIiwiaW5jbHVkZXMiLCJwYXJ0cyIsInNwbGl0IiwiaWR4IiwiZmluZEluZGV4IiwicCIsInJlcGxhY2UiLCJ0cmltIiwiYWNjb3VudFVzZXJuYW1lTG93ZXIiLCJ0b0xvd2VyQ2FzZSIsImN1dG9mZjMwIiwiRGF0ZSIsIm5vdyIsInNpbmNlRGF0ZSIsInBvc3RzUnVuIiwiYWN0b3IiLCJjYWxsIiwidXNlcm5hbWVzIiwicmVzdWx0c1R5cGUiLCJyZXN1bHRzTGltaXQiLCJkZWZhdWx0RGF0YXNldElkIiwicG9zdHNJdGVtcyIsImRhdGFzZXQiLCJsaXN0SXRlbXMiLCJhY2NvdW50UG9zdFVybHMiLCJTZXQiLCJwb3N0RGF0ZSIsInRpbWVzdGFtcCIsImRhdGUiLCJ0YWtlbkF0IiwidXJsIiwibGluayIsInNob3J0Q29kZSIsIm5vcm1hbGl6ZWQiLCJub3JtYWxpemVQb3N0VXJsIiwiYWRkIiwicG9zdFVybHNMaXN0IiwiQXJyYXkiLCJmcm9tIiwidG9JU09TdHJpbmciLCJjb21tZW50c1J1biIsImRpcmVjdFVybHMiLCJhbGxJdGVtcyIsImNvbW1lbnRzIiwicmF3IiwiY29tbWVudCIsImF1dGhvciIsImdldENvbW1lbnRBdXRob3IiLCJhdXRob3JMb3dlciIsImNvbW1lbnRQb3N0VXJsIiwicG9zdFVybCIsIm5vcm1hbGl6ZWRDb21tZW50UG9zdCIsImhhcyIsImNyZWF0ZWRBdCIsInB1c2giLCJleHRlcm5hbElkIiwiU3RyaW5nIiwiaWQiLCJwbGF0Zm9ybSIsInRleHQiLCJyYXRpbmciLCJzdGFydHNXaXRoIiwiZXJyb3IiLCJtZXNzYWdlIiwiYyIsInYiLCJvd25lclVzZXJuYW1lIiwib3duZXIiLCJ1c2VyIiwidSIsIm0iLCJtYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/sync/adapters/instagram-adapter.ts\n");

/***/ }),

/***/ "(rsc)/./lib/sync/adapters/types.ts":
/*!************************************!*\
  !*** ./lib/sync/adapters/types.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvc3luYy9hZGFwdGVycy90eXBlcy50cyIsIm1hcHBpbmdzIjoiO0FBS0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9saWIvc3luYy9hZGFwdGVycy90eXBlcy50cz83ZjBlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgUmV2aWV3SXRlbSB9IGZyb20gXCJAcmVwby9zaGFyZWRcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSW5nZXN0UmVzdWx0IHtcclxuICAgIGl0ZW1zOiBQYXJ0aWFsPFJldmlld0l0ZW0+W107XHJcbiAgICBlcnJvcnM6IHN0cmluZ1tdO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/sync/adapters/types.ts\n");

/***/ }),

/***/ "(rsc)/./lib/sync/adapters/x-adapter.ts":
/*!****************************************!*\
  !*** ./lib/sync/adapters/x-adapter.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   XAdapter: () => (/* binding */ XAdapter)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"(rsc)/../../node_modules/axios/lib/axios.js\");\n/* harmony import */ var _utils_date_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/date-parser */ \"(rsc)/./lib/sync/utils/date-parser.ts\");\n\n\nclass XAdapter {\n    constructor(){\n        this.apiKey = process.env.SERPAPI_API_KEY || \"\";\n    }\n    async fetchMentions(query, since) {\n        console.log(`[XAdapter] Fetching X content for query: ${query} via SerpApi`);\n        if (!this.apiKey || this.apiKey === \"your_serpapi_key_here\") {\n            console.warn(\"SerpApi key not set\");\n            return {\n                items: [],\n                errors: [\n                    \"SerpApi key not configured\"\n                ]\n            };\n        }\n        try {\n            // Clean the query - extract username from URL if provided\n            let cleanedQuery = query.trim();\n            if (cleanedQuery.includes(\"x.com/\") || cleanedQuery.includes(\"twitter.com/\")) {\n                const urlMatch = cleanedQuery.match(/(?:x\\.com|twitter\\.com)\\/([a-zA-Z0-9_]+)/);\n                if (urlMatch && urlMatch[1]) {\n                    cleanedQuery = urlMatch[1];\n                }\n            }\n            const isHandle = cleanedQuery.startsWith(\"@\") || !cleanedQuery.includes(\" \") && !cleanedQuery.includes(\"http\");\n            if (!isHandle) {\n                // Fallback for keyword searches (not profile sync)\n                const q = `site:x.com \"${cleanedQuery}\" OR site:twitter.com \"${cleanedQuery}\"`;\n                return await this.simpleSearch(q, \"\", since);\n            }\n            const username = cleanedQuery.replace(\"@\", \"\").trim();\n            return await this.fetchUserReplies(username, since);\n        } catch (error) {\n            console.error(\"SerpApi X search error:\", error.response?.data || error.message);\n            return {\n                items: [],\n                errors: [\n                    error.message\n                ]\n            };\n        }\n    }\n    /**\r\n     * 2-STEP PROCESS:\r\n     * 1. Discovery: Find user's own posts (timeline)\r\n     * 2. Collection: Find replies to those specific posts\r\n     */ async fetchUserReplies(username, since) {\n        console.log(`\\n[X ADAPTER] 2-Step Sync for @${username}`);\n        const allItems = [];\n        const errors = [];\n        // STEP 1: DISCOVERY - Get User's Own Posts\n        console.log(`[Step 1] Fetching @${username}'s posts from last 30 days...`);\n        const postsQuery = `site:x.com/${username}/status OR site:twitter.com/${username}/status`;\n        try {\n            const timelineResponse = await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"https://serpapi.com/search\", {\n                params: {\n                    engine: \"google\",\n                    q: postsQuery,\n                    api_key: this.apiKey,\n                    num: 20,\n                    tbs: \"qdr:m\" // Past month only\n                }\n            });\n            const userPosts = timelineResponse.data.organic_results || [];\n            console.log(` Found ${userPosts.length} posts by @${username}`);\n            if (userPosts.length === 0) {\n                return {\n                    items: [],\n                    errors: [\n                        \"No recent posts found for user\"\n                    ]\n                };\n            }\n            // STEP 2: COLLECTION - Get Replies for each post\n            console.log(`[Step 2] Fetching replies to these ${userPosts.length} posts...`);\n            // Limit to 10 posts to avoid excessive API calls/time per sync\n            const postsToScrape = userPosts.slice(0, 10);\n            for (const [index, post] of postsToScrape.entries()){\n                const link = post.link || \"\";\n                const postIdMatch = link.match(/status\\/(\\d+)/);\n                if (!postIdMatch) continue;\n                const postId = postIdMatch[1];\n                console.log(`   [${index + 1}/${postsToScrape.length}] Checking replies for post ${postId}...`);\n                try {\n                    // Start searching for replies\n                    // Query: \"{postId}\" \"Replying to @{username}\"\n                    // This is specific to Google's indexing of X replies\n                    const repliesQuery = `\"${postId}\" \"Replying to @${username}\"`;\n                    const repliesResponse = await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"https://serpapi.com/search\", {\n                        params: {\n                            engine: \"google\",\n                            q: repliesQuery,\n                            api_key: this.apiKey,\n                            num: 20 // Get up to 20 replies per post\n                        }\n                    });\n                    const replies = repliesResponse.data.organic_results || [];\n                    for (const r of replies){\n                        const replyLink = r.link || \"\";\n                        // Filter out the user's OWN replies/threads\n                        if (replyLink.includes(`/${username}/status`)) {\n                            continue;\n                        }\n                        // Parse author from Title or Snippet\n                        // Format often: \"Reply to @JohnDeere\" or \"User (@handle) on X: ...\"\n                        let author = \"One of your followers\";\n                        const title = r.title || \"\";\n                        // Try to extract handle from title\n                        // \"Bob (@bob123) on X: ...\"\n                        const authorMatch = title.match(/(.+) \\(@([a-zA-Z0-9_]+)\\)/);\n                        if (authorMatch) {\n                            author = `@${authorMatch[2]}`;\n                        }\n                        // Date parsing\n                        let createdAt = new Date();\n                        if (r.date) {\n                            createdAt = (0,_utils_date_parser__WEBPACK_IMPORTED_MODULE_0__.parseRelativeDate)(r.date);\n                        }\n                        if (since && createdAt < since) continue;\n                        allItems.push({\n                            externalId: replyLink,\n                            platform: \"X\",\n                            text: r.snippet || title,\n                            rating: 0,\n                            author: author,\n                            createdAt: createdAt,\n                            url: replyLink,\n                            metadata: {\n                                parentPostId: postId,\n                                parentPostUrl: link\n                            }\n                        });\n                    }\n                    // Respectful delay between calls\n                    await new Promise((r)=>setTimeout(r, 500));\n                } catch (err) {\n                    console.error(`   Failed to fetch replies for post ${postId}: ${err.message}`);\n                    errors.push(`Post ${postId}: ${err.message}`);\n                }\n            }\n        } catch (error) {\n            console.error(\"Step 1 (Discovery) failed:\", error.message);\n            return {\n                items: [],\n                errors: [\n                    error.message\n                ]\n            };\n        }\n        console.log(`[X ADAPTER] Completed. Found ${allItems.length} total replies.`);\n        return {\n            items: allItems,\n            errors\n        };\n    }\n    async simpleSearch(q, username, since) {\n        // ... (Existing simple search implementation, mostly for keyword monitoring)\n        const response = await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"https://serpapi.com/search\", {\n            params: {\n                engine: \"google\",\n                q: q,\n                api_key: this.apiKey,\n                num: 20,\n                tbs: \"qdr:m\"\n            }\n        });\n        const results = response.data.organic_results || [];\n        const items = results.map((r)=>({\n                externalId: r.link || `x_${Math.random()}`,\n                platform: \"X\",\n                text: r.snippet || \"\",\n                rating: 0,\n                author: \"Combined Search Result\",\n                createdAt: r.date ? (0,_utils_date_parser__WEBPACK_IMPORTED_MODULE_0__.parseRelativeDate)(r.date) : new Date(),\n                url: r.link\n            })).filter((item)=>!since || item.createdAt && item.createdAt >= since);\n        return {\n            items,\n            errors: []\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvc3luYy9hZGFwdGVycy94LWFkYXB0ZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRTBCO0FBQytCO0FBRWxELE1BQU1FO0lBR1RDLGFBQWM7UUFDVixJQUFJLENBQUNDLE1BQU0sR0FBR0MsUUFBUUMsR0FBRyxDQUFDQyxlQUFlLElBQUk7SUFDakQ7SUFFQSxNQUFNQyxjQUFjQyxLQUFhLEVBQUVDLEtBQVksRUFBeUI7UUFDcEVDLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHlDQUF5QyxFQUFFSCxNQUFNLFlBQVksQ0FBQztRQUUzRSxJQUFJLENBQUMsSUFBSSxDQUFDTCxNQUFNLElBQUksSUFBSSxDQUFDQSxNQUFNLEtBQUsseUJBQXlCO1lBQ3pETyxRQUFRRSxJQUFJLENBQUM7WUFDYixPQUFPO2dCQUFFQyxPQUFPLEVBQUU7Z0JBQUVDLFFBQVE7b0JBQUM7aUJBQTZCO1lBQUM7UUFDL0Q7UUFFQSxJQUFJO1lBQ0EsMERBQTBEO1lBQzFELElBQUlDLGVBQWVQLE1BQU1RLElBQUk7WUFDN0IsSUFBSUQsYUFBYUUsUUFBUSxDQUFDLGFBQWFGLGFBQWFFLFFBQVEsQ0FBQyxpQkFBaUI7Z0JBQzFFLE1BQU1DLFdBQVdILGFBQWFJLEtBQUssQ0FBQztnQkFDcEMsSUFBSUQsWUFBWUEsUUFBUSxDQUFDLEVBQUUsRUFBRTtvQkFDekJILGVBQWVHLFFBQVEsQ0FBQyxFQUFFO2dCQUM5QjtZQUNKO1lBRUEsTUFBTUUsV0FBV0wsYUFBYU0sVUFBVSxDQUFDLFFBQVMsQ0FBQ04sYUFBYUUsUUFBUSxDQUFDLFFBQVEsQ0FBQ0YsYUFBYUUsUUFBUSxDQUFDO1lBRXhHLElBQUksQ0FBQ0csVUFBVTtnQkFDWCxtREFBbUQ7Z0JBQ25ELE1BQU1FLElBQUksQ0FBQyxZQUFZLEVBQUVQLGFBQWEsdUJBQXVCLEVBQUVBLGFBQWEsQ0FBQyxDQUFDO2dCQUM5RSxPQUFPLE1BQU0sSUFBSSxDQUFDUSxZQUFZLENBQUNELEdBQUcsSUFBSWI7WUFDMUM7WUFFQSxNQUFNZSxXQUFXVCxhQUFhVSxPQUFPLENBQUMsS0FBSyxJQUFJVCxJQUFJO1lBQ25ELE9BQU8sTUFBTSxJQUFJLENBQUNVLGdCQUFnQixDQUFDRixVQUFVZjtRQUVqRCxFQUFFLE9BQU9rQixPQUFZO1lBQ2pCakIsUUFBUWlCLEtBQUssQ0FBQywyQkFBMkJBLE1BQU1DLFFBQVEsRUFBRUMsUUFBUUYsTUFBTUcsT0FBTztZQUM5RSxPQUFPO2dCQUFFakIsT0FBTyxFQUFFO2dCQUFFQyxRQUFRO29CQUFDYSxNQUFNRyxPQUFPO2lCQUFDO1lBQUM7UUFDaEQ7SUFDSjtJQUVBOzs7O0tBSUMsR0FDRCxNQUFjSixpQkFBaUJGLFFBQWdCLEVBQUVmLEtBQVksRUFBeUI7UUFDbEZDLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLCtCQUErQixFQUFFYSxTQUFTLENBQUM7UUFDeEQsTUFBTU8sV0FBa0MsRUFBRTtRQUMxQyxNQUFNakIsU0FBbUIsRUFBRTtRQUUzQiwyQ0FBMkM7UUFDM0NKLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLG1CQUFtQixFQUFFYSxTQUFTLDZCQUE2QixDQUFDO1FBQ3pFLE1BQU1RLGFBQWEsQ0FBQyxXQUFXLEVBQUVSLFNBQVMsNEJBQTRCLEVBQUVBLFNBQVMsT0FBTyxDQUFDO1FBRXpGLElBQUk7WUFDQSxNQUFNUyxtQkFBbUIsTUFBTWxDLDZDQUFLQSxDQUFDbUMsR0FBRyxDQUFDLDhCQUE4QjtnQkFDbkVDLFFBQVE7b0JBQ0pDLFFBQVE7b0JBQ1JkLEdBQUdVO29CQUNISyxTQUFTLElBQUksQ0FBQ2xDLE1BQU07b0JBQ3BCbUMsS0FBSztvQkFDTEMsS0FBSyxRQUFRLGtCQUFrQjtnQkFDbkM7WUFDSjtZQUVBLE1BQU1DLFlBQVlQLGlCQUFpQkosSUFBSSxDQUFDWSxlQUFlLElBQUksRUFBRTtZQUM3RC9CLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsRUFBRTZCLFVBQVVFLE1BQU0sQ0FBQyxXQUFXLEVBQUVsQixTQUFTLENBQUM7WUFFL0QsSUFBSWdCLFVBQVVFLE1BQU0sS0FBSyxHQUFHO2dCQUN4QixPQUFPO29CQUFFN0IsT0FBTyxFQUFFO29CQUFFQyxRQUFRO3dCQUFDO3FCQUFpQztnQkFBQztZQUNuRTtZQUVBLGlEQUFpRDtZQUNqREosUUFBUUMsR0FBRyxDQUFDLENBQUMsbUNBQW1DLEVBQUU2QixVQUFVRSxNQUFNLENBQUMsU0FBUyxDQUFDO1lBRTdFLCtEQUErRDtZQUMvRCxNQUFNQyxnQkFBZ0JILFVBQVVJLEtBQUssQ0FBQyxHQUFHO1lBRXpDLEtBQUssTUFBTSxDQUFDQyxPQUFPQyxLQUFLLElBQUlILGNBQWNJLE9BQU8sR0FBSTtnQkFDakQsTUFBTUMsT0FBT0YsS0FBS0UsSUFBSSxJQUFJO2dCQUMxQixNQUFNQyxjQUFjRCxLQUFLN0IsS0FBSyxDQUFDO2dCQUUvQixJQUFJLENBQUM4QixhQUFhO2dCQUVsQixNQUFNQyxTQUFTRCxXQUFXLENBQUMsRUFBRTtnQkFDN0J2QyxRQUFRQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUVrQyxRQUFRLEVBQUUsQ0FBQyxFQUFFRixjQUFjRCxNQUFNLENBQUMsNEJBQTRCLEVBQUVRLE9BQU8sR0FBRyxDQUFDO2dCQUU5RixJQUFJO29CQUNBLDhCQUE4QjtvQkFDOUIsOENBQThDO29CQUM5QyxxREFBcUQ7b0JBQ3JELE1BQU1DLGVBQWUsQ0FBQyxDQUFDLEVBQUVELE9BQU8sZ0JBQWdCLEVBQUUxQixTQUFTLENBQUMsQ0FBQztvQkFFN0QsTUFBTTRCLGtCQUFrQixNQUFNckQsNkNBQUtBLENBQUNtQyxHQUFHLENBQUMsOEJBQThCO3dCQUNsRUMsUUFBUTs0QkFDSkMsUUFBUTs0QkFDUmQsR0FBRzZCOzRCQUNIZCxTQUFTLElBQUksQ0FBQ2xDLE1BQU07NEJBQ3BCbUMsS0FBSyxHQUFHLGdDQUFnQzt3QkFDNUM7b0JBQ0o7b0JBRUEsTUFBTWUsVUFBVUQsZ0JBQWdCdkIsSUFBSSxDQUFDWSxlQUFlLElBQUksRUFBRTtvQkFFMUQsS0FBSyxNQUFNYSxLQUFLRCxRQUFTO3dCQUNyQixNQUFNRSxZQUFZRCxFQUFFTixJQUFJLElBQUk7d0JBRTVCLDRDQUE0Qzt3QkFDNUMsSUFBSU8sVUFBVXRDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRU8sU0FBUyxPQUFPLENBQUMsR0FBRzs0QkFDM0M7d0JBQ0o7d0JBRUEscUNBQXFDO3dCQUNyQyxvRUFBb0U7d0JBQ3BFLElBQUlnQyxTQUFTO3dCQUNiLE1BQU1DLFFBQVFILEVBQUVHLEtBQUssSUFBSTt3QkFFekIsbUNBQW1DO3dCQUNuQyw0QkFBNEI7d0JBQzVCLE1BQU1DLGNBQWNELE1BQU10QyxLQUFLLENBQUM7d0JBQ2hDLElBQUl1QyxhQUFhOzRCQUNiRixTQUFTLENBQUMsQ0FBQyxFQUFFRSxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUM7d0JBQ2pDO3dCQUVBLGVBQWU7d0JBQ2YsSUFBSUMsWUFBWSxJQUFJQzt3QkFDcEIsSUFBSU4sRUFBRU8sSUFBSSxFQUFFOzRCQUNSRixZQUFZM0QscUVBQWlCQSxDQUFDc0QsRUFBRU8sSUFBSTt3QkFDeEM7d0JBRUEsSUFBSXBELFNBQVNrRCxZQUFZbEQsT0FBTzt3QkFFaENzQixTQUFTK0IsSUFBSSxDQUFDOzRCQUNWQyxZQUFZUjs0QkFDWlMsVUFBVTs0QkFDVkMsTUFBTVgsRUFBRVksT0FBTyxJQUFJVDs0QkFDbkJVLFFBQVE7NEJBQ1JYLFFBQVFBOzRCQUNSRyxXQUFXQTs0QkFDWFMsS0FBS2I7NEJBQ0xjLFVBQVU7Z0NBQ05DLGNBQWNwQjtnQ0FDZHFCLGVBQWV2Qjs0QkFDbkI7d0JBQ0o7b0JBQ0o7b0JBRUEsaUNBQWlDO29CQUNqQyxNQUFNLElBQUl3QixRQUFRbEIsQ0FBQUEsSUFBS21CLFdBQVduQixHQUFHO2dCQUV6QyxFQUFFLE9BQU9vQixLQUFVO29CQUNmaEUsUUFBUWlCLEtBQUssQ0FBQyxDQUFDLG9DQUFvQyxFQUFFdUIsT0FBTyxFQUFFLEVBQUV3QixJQUFJNUMsT0FBTyxDQUFDLENBQUM7b0JBQzdFaEIsT0FBT2dELElBQUksQ0FBQyxDQUFDLEtBQUssRUFBRVosT0FBTyxFQUFFLEVBQUV3QixJQUFJNUMsT0FBTyxDQUFDLENBQUM7Z0JBQ2hEO1lBQ0o7UUFFSixFQUFFLE9BQU9ILE9BQVk7WUFDakJqQixRQUFRaUIsS0FBSyxDQUFDLDhCQUE4QkEsTUFBTUcsT0FBTztZQUN6RCxPQUFPO2dCQUFFakIsT0FBTyxFQUFFO2dCQUFFQyxRQUFRO29CQUFDYSxNQUFNRyxPQUFPO2lCQUFDO1lBQUM7UUFDaEQ7UUFFQXBCLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLDZCQUE2QixFQUFFb0IsU0FBU1csTUFBTSxDQUFDLGVBQWUsQ0FBQztRQUM1RSxPQUFPO1lBQUU3QixPQUFPa0I7WUFBVWpCO1FBQU87SUFDckM7SUFFQSxNQUFjUyxhQUFhRCxDQUFTLEVBQUVFLFFBQWdCLEVBQUVmLEtBQVksRUFBeUI7UUFDekYsNkVBQTZFO1FBQzdFLE1BQU1tQixXQUFXLE1BQU03Qiw2Q0FBS0EsQ0FBQ21DLEdBQUcsQ0FBQyw4QkFBOEI7WUFDM0RDLFFBQVE7Z0JBQ0pDLFFBQVE7Z0JBQ1JkLEdBQUdBO2dCQUNIZSxTQUFTLElBQUksQ0FBQ2xDLE1BQU07Z0JBQ3BCbUMsS0FBSztnQkFDTEMsS0FBSztZQUNUO1FBQ0o7UUFFQSxNQUFNb0MsVUFBVS9DLFNBQVNDLElBQUksQ0FBQ1ksZUFBZSxJQUFJLEVBQUU7UUFDbkQsTUFBTTVCLFFBQStCOEQsUUFBUUMsR0FBRyxDQUFDLENBQUN0QixJQUFZO2dCQUMxRFMsWUFBWVQsRUFBRU4sSUFBSSxJQUFJLENBQUMsRUFBRSxFQUFFNkIsS0FBS0MsTUFBTSxHQUFHLENBQUM7Z0JBQzFDZCxVQUFVO2dCQUNWQyxNQUFNWCxFQUFFWSxPQUFPLElBQUk7Z0JBQ25CQyxRQUFRO2dCQUNSWCxRQUFRO2dCQUNSRyxXQUFXTCxFQUFFTyxJQUFJLEdBQUc3RCxxRUFBaUJBLENBQUNzRCxFQUFFTyxJQUFJLElBQUksSUFBSUQ7Z0JBQ3BEUSxLQUFLZCxFQUFFTixJQUFJO1lBQ2YsSUFBSStCLE1BQU0sQ0FBQ0MsQ0FBQUEsT0FBUSxDQUFDdkUsU0FBVXVFLEtBQUtyQixTQUFTLElBQUlxQixLQUFLckIsU0FBUyxJQUFJbEQ7UUFFbEUsT0FBTztZQUFFSTtZQUFPQyxRQUFRLEVBQUU7UUFBQztJQUMvQjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbGliL3N5bmMvYWRhcHRlcnMveC1hZGFwdGVyLnRzPzhlOGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBQbGF0Zm9ybSwgUmV2aWV3SXRlbSB9IGZyb20gXCJAcmVwby9zaGFyZWRcIjtcclxuaW1wb3J0IHR5cGUgeyBJbmdlc3RSZXN1bHQgfSBmcm9tIFwiLi90eXBlc1wiO1xyXG5pbXBvcnQgYXhpb3MgZnJvbSBcImF4aW9zXCI7XHJcbmltcG9ydCB7IHBhcnNlUmVsYXRpdmVEYXRlIH0gZnJvbSBcIi4uL3V0aWxzL2RhdGUtcGFyc2VyXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgWEFkYXB0ZXIge1xyXG4gICAgcHJpdmF0ZSBhcGlLZXk6IHN0cmluZztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmFwaUtleSA9IHByb2Nlc3MuZW52LlNFUlBBUElfQVBJX0tFWSB8fCBcIlwiO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGZldGNoTWVudGlvbnMocXVlcnk6IHN0cmluZywgc2luY2U/OiBEYXRlKTogUHJvbWlzZTxJbmdlc3RSZXN1bHQ+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgW1hBZGFwdGVyXSBGZXRjaGluZyBYIGNvbnRlbnQgZm9yIHF1ZXJ5OiAke3F1ZXJ5fSB2aWEgU2VycEFwaWApO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuYXBpS2V5IHx8IHRoaXMuYXBpS2V5ID09PSBcInlvdXJfc2VycGFwaV9rZXlfaGVyZVwiKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNlcnBBcGkga2V5IG5vdCBzZXRcIik7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGl0ZW1zOiBbXSwgZXJyb3JzOiBbXCJTZXJwQXBpIGtleSBub3QgY29uZmlndXJlZFwiXSB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gQ2xlYW4gdGhlIHF1ZXJ5IC0gZXh0cmFjdCB1c2VybmFtZSBmcm9tIFVSTCBpZiBwcm92aWRlZFxyXG4gICAgICAgICAgICBsZXQgY2xlYW5lZFF1ZXJ5ID0gcXVlcnkudHJpbSgpO1xyXG4gICAgICAgICAgICBpZiAoY2xlYW5lZFF1ZXJ5LmluY2x1ZGVzKFwieC5jb20vXCIpIHx8IGNsZWFuZWRRdWVyeS5pbmNsdWRlcyhcInR3aXR0ZXIuY29tL1wiKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdXJsTWF0Y2ggPSBjbGVhbmVkUXVlcnkubWF0Y2goLyg/OnhcXC5jb218dHdpdHRlclxcLmNvbSlcXC8oW2EtekEtWjAtOV9dKykvKTtcclxuICAgICAgICAgICAgICAgIGlmICh1cmxNYXRjaCAmJiB1cmxNYXRjaFsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFuZWRRdWVyeSA9IHVybE1hdGNoWzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBpc0hhbmRsZSA9IGNsZWFuZWRRdWVyeS5zdGFydHNXaXRoKFwiQFwiKSB8fCAoIWNsZWFuZWRRdWVyeS5pbmNsdWRlcyhcIiBcIikgJiYgIWNsZWFuZWRRdWVyeS5pbmNsdWRlcyhcImh0dHBcIikpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFpc0hhbmRsZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgZm9yIGtleXdvcmQgc2VhcmNoZXMgKG5vdCBwcm9maWxlIHN5bmMpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBxID0gYHNpdGU6eC5jb20gXCIke2NsZWFuZWRRdWVyeX1cIiBPUiBzaXRlOnR3aXR0ZXIuY29tIFwiJHtjbGVhbmVkUXVlcnl9XCJgO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2ltcGxlU2VhcmNoKHEsIFwiXCIsIHNpbmNlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgdXNlcm5hbWUgPSBjbGVhbmVkUXVlcnkucmVwbGFjZShcIkBcIiwgXCJcIikudHJpbSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaFVzZXJSZXBsaWVzKHVzZXJuYW1lLCBzaW5jZSk7XHJcblxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlNlcnBBcGkgWCBzZWFyY2ggZXJyb3I6XCIsIGVycm9yLnJlc3BvbnNlPy5kYXRhIHx8IGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICByZXR1cm4geyBpdGVtczogW10sIGVycm9yczogW2Vycm9yLm1lc3NhZ2VdIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogMi1TVEVQIFBST0NFU1M6XHJcbiAgICAgKiAxLiBEaXNjb3Zlcnk6IEZpbmQgdXNlcidzIG93biBwb3N0cyAodGltZWxpbmUpXHJcbiAgICAgKiAyLiBDb2xsZWN0aW9uOiBGaW5kIHJlcGxpZXMgdG8gdGhvc2Ugc3BlY2lmaWMgcG9zdHNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyBmZXRjaFVzZXJSZXBsaWVzKHVzZXJuYW1lOiBzdHJpbmcsIHNpbmNlPzogRGF0ZSk6IFByb21pc2U8SW5nZXN0UmVzdWx0PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFxcbltYIEFEQVBURVJdIDItU3RlcCBTeW5jIGZvciBAJHt1c2VybmFtZX1gKTtcclxuICAgICAgICBjb25zdCBhbGxJdGVtczogUGFydGlhbDxSZXZpZXdJdGVtPltdID0gW107XHJcbiAgICAgICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICAgICAgICAvLyBTVEVQIDE6IERJU0NPVkVSWSAtIEdldCBVc2VyJ3MgT3duIFBvc3RzXHJcbiAgICAgICAgY29uc29sZS5sb2coYFtTdGVwIDFdIEZldGNoaW5nIEAke3VzZXJuYW1lfSdzIHBvc3RzIGZyb20gbGFzdCAzMCBkYXlzLi4uYCk7XHJcbiAgICAgICAgY29uc3QgcG9zdHNRdWVyeSA9IGBzaXRlOnguY29tLyR7dXNlcm5hbWV9L3N0YXR1cyBPUiBzaXRlOnR3aXR0ZXIuY29tLyR7dXNlcm5hbWV9L3N0YXR1c2A7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVsaW5lUmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoXCJodHRwczovL3NlcnBhcGkuY29tL3NlYXJjaFwiLCB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHtcclxuICAgICAgICAgICAgICAgICAgICBlbmdpbmU6IFwiZ29vZ2xlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcTogcG9zdHNRdWVyeSxcclxuICAgICAgICAgICAgICAgICAgICBhcGlfa2V5OiB0aGlzLmFwaUtleSxcclxuICAgICAgICAgICAgICAgICAgICBudW06IDIwLCAvLyBGZXRjaCB0b3AgMjAgcmVjZW50IHBvc3RzXHJcbiAgICAgICAgICAgICAgICAgICAgdGJzOiBcInFkcjptXCIgLy8gUGFzdCBtb250aCBvbmx5XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgdXNlclBvc3RzID0gdGltZWxpbmVSZXNwb25zZS5kYXRhLm9yZ2FuaWNfcmVzdWx0cyB8fCBbXTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCAke3VzZXJQb3N0cy5sZW5ndGh9IHBvc3RzIGJ5IEAke3VzZXJuYW1lfWApO1xyXG5cclxuICAgICAgICAgICAgaWYgKHVzZXJQb3N0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGl0ZW1zOiBbXSwgZXJyb3JzOiBbXCJObyByZWNlbnQgcG9zdHMgZm91bmQgZm9yIHVzZXJcIl0gfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU1RFUCAyOiBDT0xMRUNUSU9OIC0gR2V0IFJlcGxpZXMgZm9yIGVhY2ggcG9zdFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW1N0ZXAgMl0gRmV0Y2hpbmcgcmVwbGllcyB0byB0aGVzZSAke3VzZXJQb3N0cy5sZW5ndGh9IHBvc3RzLi4uYCk7XHJcblxyXG4gICAgICAgICAgICAvLyBMaW1pdCB0byAxMCBwb3N0cyB0byBhdm9pZCBleGNlc3NpdmUgQVBJIGNhbGxzL3RpbWUgcGVyIHN5bmNcclxuICAgICAgICAgICAgY29uc3QgcG9zdHNUb1NjcmFwZSA9IHVzZXJQb3N0cy5zbGljZSgwLCAxMCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgcG9zdF0gb2YgcG9zdHNUb1NjcmFwZS5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBwb3N0LmxpbmsgfHwgXCJcIjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvc3RJZE1hdGNoID0gbGluay5tYXRjaCgvc3RhdHVzXFwvKFxcZCspLyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFwb3N0SWRNYXRjaCkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9zdElkID0gcG9zdElkTWF0Y2hbMV07XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgWyR7aW5kZXggKyAxfS8ke3Bvc3RzVG9TY3JhcGUubGVuZ3RofV0gQ2hlY2tpbmcgcmVwbGllcyBmb3IgcG9zdCAke3Bvc3RJZH0uLi5gKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHNlYXJjaGluZyBmb3IgcmVwbGllc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFF1ZXJ5OiBcIntwb3N0SWR9XCIgXCJSZXBseWluZyB0byBAe3VzZXJuYW1lfVwiXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBzcGVjaWZpYyB0byBHb29nbGUncyBpbmRleGluZyBvZiBYIHJlcGxpZXNcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXBsaWVzUXVlcnkgPSBgXCIke3Bvc3RJZH1cIiBcIlJlcGx5aW5nIHRvIEAke3VzZXJuYW1lfVwiYDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwbGllc1Jlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KFwiaHR0cHM6Ly9zZXJwYXBpLmNvbS9zZWFyY2hcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZ2luZTogXCJnb29nbGVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHE6IHJlcGxpZXNRdWVyeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaV9rZXk6IHRoaXMuYXBpS2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtOiAyMCAvLyBHZXQgdXAgdG8gMjAgcmVwbGllcyBwZXIgcG9zdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxpZXMgPSByZXBsaWVzUmVzcG9uc2UuZGF0YS5vcmdhbmljX3Jlc3VsdHMgfHwgW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgciBvZiByZXBsaWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcGx5TGluayA9IHIubGluayB8fCBcIlwiO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXNlcidzIE9XTiByZXBsaWVzL3RocmVhZHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGx5TGluay5pbmNsdWRlcyhgLyR7dXNlcm5hbWV9L3N0YXR1c2ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgYXV0aG9yIGZyb20gVGl0bGUgb3IgU25pcHBldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3JtYXQgb2Z0ZW46IFwiUmVwbHkgdG8gQEpvaG5EZWVyZVwiIG9yIFwiVXNlciAoQGhhbmRsZSkgb24gWDogLi4uXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGF1dGhvciA9IFwiT25lIG9mIHlvdXIgZm9sbG93ZXJzXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpdGxlID0gci50aXRsZSB8fCBcIlwiO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGV4dHJhY3QgaGFuZGxlIGZyb20gdGl0bGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJCb2IgKEBib2IxMjMpIG9uIFg6IC4uLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF1dGhvck1hdGNoID0gdGl0bGUubWF0Y2goLyguKykgXFwoQChbYS16QS1aMC05X10rKVxcKS8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXV0aG9yTWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvciA9IGBAJHthdXRob3JNYXRjaFsyXX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEYXRlIHBhcnNpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmRhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRBdCA9IHBhcnNlUmVsYXRpdmVEYXRlKHIuZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaW5jZSAmJiBjcmVhdGVkQXQgPCBzaW5jZSkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVybmFsSWQ6IHJlcGx5TGluayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYXRmb3JtOiBcIlhcIiBhcyBQbGF0Zm9ybSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHIuc25pcHBldCB8fCB0aXRsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhdGluZzogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvcjogYXV0aG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZEF0OiBjcmVhdGVkQXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHJlcGx5TGluayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UG9zdElkOiBwb3N0SWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UG9zdFVybDogbGlua1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3BlY3RmdWwgZGVsYXkgYmV0d2VlbiBjYWxsc1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCA1MDApKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCAgIEZhaWxlZCB0byBmZXRjaCByZXBsaWVzIGZvciBwb3N0ICR7cG9zdElkfTogJHtlcnIubWVzc2FnZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChgUG9zdCAke3Bvc3RJZH06ICR7ZXJyLm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiU3RlcCAxIChEaXNjb3ZlcnkpIGZhaWxlZDpcIiwgZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGl0ZW1zOiBbXSwgZXJyb3JzOiBbZXJyb3IubWVzc2FnZV0gfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBbWCBBREFQVEVSXSBDb21wbGV0ZWQuIEZvdW5kICR7YWxsSXRlbXMubGVuZ3RofSB0b3RhbCByZXBsaWVzLmApO1xyXG4gICAgICAgIHJldHVybiB7IGl0ZW1zOiBhbGxJdGVtcywgZXJyb3JzIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBzaW1wbGVTZWFyY2gocTogc3RyaW5nLCB1c2VybmFtZTogc3RyaW5nLCBzaW5jZT86IERhdGUpOiBQcm9taXNlPEluZ2VzdFJlc3VsdD4ge1xyXG4gICAgICAgIC8vIC4uLiAoRXhpc3Rpbmcgc2ltcGxlIHNlYXJjaCBpbXBsZW1lbnRhdGlvbiwgbW9zdGx5IGZvciBrZXl3b3JkIG1vbml0b3JpbmcpXHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoXCJodHRwczovL3NlcnBhcGkuY29tL3NlYXJjaFwiLCB7XHJcbiAgICAgICAgICAgIHBhcmFtczoge1xyXG4gICAgICAgICAgICAgICAgZW5naW5lOiBcImdvb2dsZVwiLFxyXG4gICAgICAgICAgICAgICAgcTogcSxcclxuICAgICAgICAgICAgICAgIGFwaV9rZXk6IHRoaXMuYXBpS2V5LFxyXG4gICAgICAgICAgICAgICAgbnVtOiAyMCxcclxuICAgICAgICAgICAgICAgIHRiczogXCJxZHI6bVwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IHJlc3BvbnNlLmRhdGEub3JnYW5pY19yZXN1bHRzIHx8IFtdO1xyXG4gICAgICAgIGNvbnN0IGl0ZW1zOiBQYXJ0aWFsPFJldmlld0l0ZW0+W10gPSByZXN1bHRzLm1hcCgocjogYW55KSA9PiAoe1xyXG4gICAgICAgICAgICBleHRlcm5hbElkOiByLmxpbmsgfHwgYHhfJHtNYXRoLnJhbmRvbSgpfWAsXHJcbiAgICAgICAgICAgIHBsYXRmb3JtOiBcIlhcIiBhcyBQbGF0Zm9ybSxcclxuICAgICAgICAgICAgdGV4dDogci5zbmlwcGV0IHx8IFwiXCIsXHJcbiAgICAgICAgICAgIHJhdGluZzogMCxcclxuICAgICAgICAgICAgYXV0aG9yOiBcIkNvbWJpbmVkIFNlYXJjaCBSZXN1bHRcIixcclxuICAgICAgICAgICAgY3JlYXRlZEF0OiByLmRhdGUgPyBwYXJzZVJlbGF0aXZlRGF0ZShyLmRhdGUpIDogbmV3IERhdGUoKSxcclxuICAgICAgICAgICAgdXJsOiByLmxpbmtcclxuICAgICAgICB9KSkuZmlsdGVyKGl0ZW0gPT4gIXNpbmNlIHx8IChpdGVtLmNyZWF0ZWRBdCAmJiBpdGVtLmNyZWF0ZWRBdCA+PSBzaW5jZSkpO1xyXG5cclxuICAgICAgICByZXR1cm4geyBpdGVtcywgZXJyb3JzOiBbXSB9O1xyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJheGlvcyIsInBhcnNlUmVsYXRpdmVEYXRlIiwiWEFkYXB0ZXIiLCJjb25zdHJ1Y3RvciIsImFwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJTRVJQQVBJX0FQSV9LRVkiLCJmZXRjaE1lbnRpb25zIiwicXVlcnkiLCJzaW5jZSIsImNvbnNvbGUiLCJsb2ciLCJ3YXJuIiwiaXRlbXMiLCJlcnJvcnMiLCJjbGVhbmVkUXVlcnkiLCJ0cmltIiwiaW5jbHVkZXMiLCJ1cmxNYXRjaCIsIm1hdGNoIiwiaXNIYW5kbGUiLCJzdGFydHNXaXRoIiwicSIsInNpbXBsZVNlYXJjaCIsInVzZXJuYW1lIiwicmVwbGFjZSIsImZldGNoVXNlclJlcGxpZXMiLCJlcnJvciIsInJlc3BvbnNlIiwiZGF0YSIsIm1lc3NhZ2UiLCJhbGxJdGVtcyIsInBvc3RzUXVlcnkiLCJ0aW1lbGluZVJlc3BvbnNlIiwiZ2V0IiwicGFyYW1zIiwiZW5naW5lIiwiYXBpX2tleSIsIm51bSIsInRicyIsInVzZXJQb3N0cyIsIm9yZ2FuaWNfcmVzdWx0cyIsImxlbmd0aCIsInBvc3RzVG9TY3JhcGUiLCJzbGljZSIsImluZGV4IiwicG9zdCIsImVudHJpZXMiLCJsaW5rIiwicG9zdElkTWF0Y2giLCJwb3N0SWQiLCJyZXBsaWVzUXVlcnkiLCJyZXBsaWVzUmVzcG9uc2UiLCJyZXBsaWVzIiwiciIsInJlcGx5TGluayIsImF1dGhvciIsInRpdGxlIiwiYXV0aG9yTWF0Y2giLCJjcmVhdGVkQXQiLCJEYXRlIiwiZGF0ZSIsInB1c2giLCJleHRlcm5hbElkIiwicGxhdGZvcm0iLCJ0ZXh0Iiwic25pcHBldCIsInJhdGluZyIsInVybCIsIm1ldGFkYXRhIiwicGFyZW50UG9zdElkIiwicGFyZW50UG9zdFVybCIsIlByb21pc2UiLCJzZXRUaW1lb3V0IiwiZXJyIiwicmVzdWx0cyIsIm1hcCIsIk1hdGgiLCJyYW5kb20iLCJmaWx0ZXIiLCJpdGVtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/sync/adapters/x-adapter.ts\n");

/***/ }),

/***/ "(rsc)/./lib/sync/project-syncer.ts":
/*!************************************!*\
  !*** ./lib/sync/project-syncer.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProjectSyncer: () => (/* binding */ ProjectSyncer)\n/* harmony export */ });\n/* harmony import */ var _lib_prisma__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/prisma */ \"(rsc)/./lib/prisma.ts\");\n/* harmony import */ var _google_generative_ai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @google/generative-ai */ \"(rsc)/../../node_modules/@google/generative-ai/dist/index.mjs\");\n/* harmony import */ var _adapters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./adapters */ \"(rsc)/./lib/sync/adapters/index.ts\");\n\n\n\nclass ProjectSyncer {\n    constructor(){\n        this.genAI = new _google_generative_ai__WEBPACK_IMPORTED_MODULE_1__.GoogleGenerativeAI(process.env.GOOGLE_GENERATIVE_AI_API_KEY || \"\");\n        // Override with GEMINI_MODEL in .env (e.g. GEMINI_MODEL=gemini-2.5-flash)\n        const model = process.env.GEMINI_MODEL || \"gemini-2.5-flash\";\n        this.model = this.genAI.getGenerativeModel({\n            model\n        });\n    }\n    static async sync(projectId) {\n        const syncer = new ProjectSyncer();\n        await syncer.run(projectId);\n    }\n    async run(projectId) {\n        console.log(`[ProjectSyncer] Starting sync for project ${projectId}`);\n        const project = await _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.project.findUnique({\n            where: {\n                id: projectId\n            },\n            include: {\n                sources: true\n            }\n        });\n        if (!project) throw new Error(\"Project not found\");\n        // 1. Ingest Data\n        for (const source of project.sources){\n            await this.ingestSource(source, projectId);\n        }\n        // 2. Run Analysis\n        await this.analyzeProject(projectId);\n    }\n    async ingestSource(source, projectId) {\n        try {\n            await _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.dataSource.update({\n                where: {\n                    id: source.id\n                },\n                data: {\n                    status: \"SYNCING\"\n                }\n            });\n            // Artificial \"Human-Feel\" Delay (1 second)\n            await new Promise((resolve)=>setTimeout(resolve, 1000));\n            // Only require API keys for platforms that use them (each adapter validates its own key)\n            if (source.platform === \"X\") {\n                if (!process.env.SERPAPI_API_KEY || process.env.SERPAPI_API_KEY === \"your_serpapi_key_here\") {\n                    console.error(\"[ProjectSyncer] SERPAPI_API_KEY is missing or placeholder for X source\");\n                    await _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.dataSource.update({\n                        where: {\n                            id: source.id\n                        },\n                        data: {\n                            status: \"ERROR\"\n                        }\n                    });\n                    return;\n                }\n            }\n            if (source.platform === \"INSTAGRAM\") {\n                if (!process.env.APIFY_API_TOKEN) {\n                    console.error(\"[ProjectSyncer] APIFY_API_TOKEN is missing for Instagram source\");\n                    await _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.dataSource.update({\n                        where: {\n                            id: source.id\n                        },\n                        data: {\n                            status: \"ERROR\"\n                        }\n                    });\n                    return;\n                }\n            }\n            // Determine sync window (Smart Sync)\n            // Strategy:\n            // 1. New Project (lastSync is null) -> Fetch last 30 days (Initial Deep Pull)\n            // 2. Existing Project -> Fetch strictly from 1 second AFTER the last sync\n            let since;\n            if (source.lastSync) {\n                const lastSyncTime = new Date(source.lastSync).getTime();\n                // One second after the last sync to avoid duplicates\n                since = new Date(lastSyncTime + 1000);\n            } else {\n                // 30 Days ago\n                since = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n            }\n            console.log(`[ProjectSyncer] Smart Sync for ${source.platform} (Source ID: ${source.id})`);\n            console.log(`[ProjectSyncer] Fetching items strictly NEWER than: ${since.toISOString()}`);\n            const config = source.config;\n            console.log(`[ProjectSyncer] Config for ${source.platform}:`, JSON.stringify(config, null, 2));\n            let result;\n            if (source.platform === \"GOOGLE_PLAY\") {\n                result = await new _adapters__WEBPACK_IMPORTED_MODULE_2__.GooglePlayAdapter().fetchReviews(config.packageName, since);\n            } else if (source.platform === \"APP_STORE\") {\n                result = await new _adapters__WEBPACK_IMPORTED_MODULE_2__.AppStoreAdapter().fetchReviews(config.appId, since);\n            } else if (source.platform === \"INSTAGRAM\") {\n                console.log(`[ProjectSyncer] Calling Instagram adapter with postUrls:`, config.postUrls);\n                result = await new _adapters__WEBPACK_IMPORTED_MODULE_2__.InstagramAdapter().fetchComments(config.postUrls, since);\n            } else if (source.platform === \"X\") {\n                console.log(`[ProjectSyncer] Calling X adapter with query:`, config.query);\n                result = await new _adapters__WEBPACK_IMPORTED_MODULE_2__.XAdapter().fetchMentions(config.query, since);\n            }\n            console.log(`[ProjectSyncer] Adapter returned:`, result ? `${result.items?.length || 0} items, ${result.errors?.length || 0} errors` : \"null/undefined\");\n            if (result && result.items.length > 0) {\n                console.log(`[ProjectSyncer] Saving ${result.items.length} items for source ${source.id}`);\n                for (const item of result.items){\n                    try {\n                        // Validate required fields\n                        if (!item.externalId) {\n                            console.warn(`[ProjectSyncer] Skipping item without externalId:`, item.text?.substring(0, 50));\n                            continue;\n                        }\n                        if (!item.text) {\n                            console.warn(`[ProjectSyncer] Skipping item without text:`, item.externalId);\n                            continue;\n                        }\n                        console.log(`[ProjectSyncer] Upserting item: ${item.externalId?.substring(0, 50)}...`);\n                        await _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.reviewItem.upsert({\n                            where: {\n                                platform_externalId_projectId: {\n                                    platform: source.platform,\n                                    externalId: item.externalId,\n                                    projectId: projectId\n                                }\n                            },\n                            create: {\n                                ...item,\n                                projectId,\n                                platform: source.platform,\n                                text: item.text\n                            },\n                            update: {\n                                ...item,\n                                text: item.text\n                            }\n                        });\n                        console.log(`[ProjectSyncer]  Saved item: ${item.externalId?.substring(0, 50)}...`);\n                    } catch (itemError) {\n                        console.error(`[ProjectSyncer]  Failed to save item:`, {\n                            externalId: item.externalId,\n                            error: itemError.message,\n                            stack: itemError.stack\n                        });\n                    }\n                }\n                console.log(`[ProjectSyncer] Finished processing ${result.items.length} items`);\n            } else {\n                console.log(`[ProjectSyncer] No items returned from adapter for source ${source.id}`);\n            }\n            await _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.dataSource.update({\n                where: {\n                    id: source.id\n                },\n                data: {\n                    status: \"IDLE\",\n                    lastSync: new Date()\n                }\n            });\n        } catch (error) {\n            console.error(`[ProjectSyncer] Error syncing source ${source.id}:`, error);\n            await _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.dataSource.update({\n                where: {\n                    id: source.id\n                },\n                data: {\n                    status: \"ERROR\"\n                }\n            });\n        }\n    }\n    async analyzeProject(projectId) {\n        console.log(`[ProjectSyncer] Starting analysis for project ${projectId}`);\n        const poorItems = await _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.reviewItem.findMany({\n            where: {\n                projectId,\n                OR: [\n                    {\n                        rating: {\n                            lte: 3\n                        }\n                    },\n                    {\n                        sentiment: \"NEG\"\n                    }\n                ]\n            },\n            take: 100,\n            orderBy: {\n                createdAt: \"desc\"\n            }\n        });\n        const goodItems = await _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.reviewItem.findMany({\n            where: {\n                projectId,\n                OR: [\n                    {\n                        rating: {\n                            gte: 4\n                        }\n                    },\n                    {\n                        sentiment: \"POS\"\n                    }\n                ]\n            },\n            take: 100,\n            orderBy: {\n                createdAt: \"desc\"\n            }\n        });\n        if (poorItems.length === 0 && goodItems.length === 0) {\n            console.log(\"[ProjectSyncer] No items to analyze\");\n            return;\n        }\n        const prompt = `Analyze customer feedback for a project.\r\n        \r\n        CRITICAL FEEDBACK (Complaints):\r\n        ${poorItems.map((i)=>`- ${i.text}`).join(\"\\n\")}\r\n        \r\n        POSITIVE FEEDBACK (Highlights):\r\n        ${goodItems.map((i)=>`- ${i.text}`).join(\"\\n\")}\r\n        \r\n        Provide:\r\n        1. A general sentiment score (1-100).\r\n        2. \"criticisms\": { summary: \"1-sentence\", bullets: [{title, details, count, examples: [string]}], suggestions: [\"Short, actionable title like 'Fix Auth Flow'\", \"Suggestions should be specific\"] }\r\n        3. \"praises\": { summary: \"1-sentence\", bullets: [{title, details, count, examples: [string]}] }\r\n        \r\n        Return ONLY a JSON object with this structure:\r\n        {\r\n          \"score\": 85,\r\n          \"criticisms\": { \"summary\": \"...\", \"bullets\": [...], \"suggestions\": [\"...\", \"...\", \"...\"] },\r\n          \"praises\": { \"summary\": \"...\", \"bullets\": [...] }\r\n        }`;\n        try {\n            const resultResponse = await this.model.generateContent(prompt);\n            const responseText = resultResponse.response.text();\n            const cleaned = responseText.replace(/```json/g, \"\").replace(/```/g, \"\").trim();\n            const result = JSON.parse(cleaned);\n            await _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.projectAnalysis.create({\n                data: {\n                    projectId,\n                    periodStart: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),\n                    periodEnd: new Date(),\n                    json: {\n                        ...result,\n                        poorCount: poorItems.length,\n                        goodCount: goodItems.length,\n                        totalCount: await _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.reviewItem.count({\n                            where: {\n                                projectId\n                            }\n                        }),\n                        platformsBreakdown: {},\n                        trend: {\n                            label: \"Last 30 days\",\n                            value: 0,\n                            direction: \"steady\"\n                        },\n                        urgentIssues: []\n                    }\n                }\n            });\n            console.log(\"[ProjectSyncer] Analysis completed and saved\");\n        } catch (e) {\n            console.error(\"[ProjectSyncer] Analysis failed:\", e);\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QytFLGVBQWUsQ0FBQ0w7WUFDeEQsTUFBTU0sZUFBZUYsZUFBZUcsUUFBUSxDQUFDM0IsSUFBSTtZQUVqRCxNQUFNNEIsVUFBVUYsYUFBYUcsT0FBTyxDQUFDLFlBQVksSUFBSUEsT0FBTyxDQUFDLFFBQVEsSUFBSUMsSUFBSTtZQUM3RSxNQUFNNUMsU0FBU0YsS0FBSytDLEtBQUssQ0FBQ0g7WUFFMUIsTUFBTTlGLCtDQUFNQSxDQUFDa0csZUFBZSxDQUFDM0IsTUFBTSxDQUFDO2dCQUNoQ3RDLE1BQU07b0JBQ0ZqQjtvQkFDQW1GLGFBQWEsSUFBSXRELEtBQUtBLEtBQUtFLEdBQUcsS0FBSyxJQUFJLEtBQUssS0FBSyxLQUFLO29CQUN0RHFELFdBQVcsSUFBSXZEO29CQUNmd0QsTUFBTTt3QkFDRixHQUFHakQsTUFBTTt3QkFDVGtELFdBQVczQixVQUFVZCxNQUFNO3dCQUMzQjBDLFdBQVduQixVQUFVdkIsTUFBTTt3QkFDM0IyQyxZQUFZLE1BQU14RywrQ0FBTUEsQ0FBQ29FLFVBQVUsQ0FBQ3FDLEtBQUssQ0FBQzs0QkFBRWxGLE9BQU87Z0NBQUVQOzRCQUFVO3dCQUFFO3dCQUNqRTBGLG9CQUFvQixDQUFDO3dCQUNyQkMsT0FBTzs0QkFBRUMsT0FBTzs0QkFBZ0JDLE9BQU87NEJBQUdDLFdBQVc7d0JBQVM7d0JBQzlEQyxjQUFjLEVBQUU7b0JBQ3BCO2dCQUNKO1lBQ0o7WUFFQTVGLFFBQVFDLEdBQUcsQ0FBQztRQUNoQixFQUFFLE9BQU80RixHQUFHO1lBQ1I3RixRQUFRcUIsS0FBSyxDQUFDLG9DQUFvQ3dFO1FBQ3REO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL2xpYi9zeW5jL3Byb2plY3Qtc3luY2VyLnRzPzI0YTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcHJpc21hIH0gZnJvbSBcIkAvbGliL3ByaXNtYVwiO1xyXG5pbXBvcnQgeyBHb29nbGVHZW5lcmF0aXZlQUkgfSBmcm9tIFwiQGdvb2dsZS9nZW5lcmF0aXZlLWFpXCI7XHJcbmltcG9ydCB7XHJcbiAgICBHb29nbGVQbGF5QWRhcHRlcixcclxuICAgIEFwcFN0b3JlQWRhcHRlcixcclxuICAgIEluc3RhZ3JhbUFkYXB0ZXIsXHJcbiAgICBYQWRhcHRlclxyXG59IGZyb20gXCIuL2FkYXB0ZXJzXCI7XHJcbmltcG9ydCB0eXBlIHsgUmV2aWV3SXRlbSB9IGZyb20gXCJAcmVwby9zaGFyZWRcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBQcm9qZWN0U3luY2VyIHtcclxuICAgIHByaXZhdGUgZ2VuQUk6IEdvb2dsZUdlbmVyYXRpdmVBSTtcclxuICAgIHByaXZhdGUgbW9kZWw6IGFueTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmdlbkFJID0gbmV3IEdvb2dsZUdlbmVyYXRpdmVBSShwcm9jZXNzLmVudi5HT09HTEVfR0VORVJBVElWRV9BSV9BUElfS0VZIHx8IFwiXCIpO1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIHdpdGggR0VNSU5JX01PREVMIGluIC5lbnYgKGUuZy4gR0VNSU5JX01PREVMPWdlbWluaS0yLjUtZmxhc2gpXHJcbiAgICAgICAgY29uc3QgbW9kZWwgPSBwcm9jZXNzLmVudi5HRU1JTklfTU9ERUwgfHwgXCJnZW1pbmktMi41LWZsYXNoXCI7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IHRoaXMuZ2VuQUkuZ2V0R2VuZXJhdGl2ZU1vZGVsKHsgbW9kZWwgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGFzeW5jIHN5bmMocHJvamVjdElkOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBzeW5jZXIgPSBuZXcgUHJvamVjdFN5bmNlcigpO1xyXG4gICAgICAgIGF3YWl0IHN5bmNlci5ydW4ocHJvamVjdElkKTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBydW4ocHJvamVjdElkOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgW1Byb2plY3RTeW5jZXJdIFN0YXJ0aW5nIHN5bmMgZm9yIHByb2plY3QgJHtwcm9qZWN0SWR9YCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHByb2plY3QgPSBhd2FpdCBwcmlzbWEucHJvamVjdC5maW5kVW5pcXVlKHtcclxuICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IHByb2plY3RJZCB9LFxyXG4gICAgICAgICAgICBpbmNsdWRlOiB7IHNvdXJjZXM6IHRydWUgfSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKCFwcm9qZWN0KSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9qZWN0IG5vdCBmb3VuZFwiKTtcclxuXHJcbiAgICAgICAgLy8gMS4gSW5nZXN0IERhdGFcclxuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBwcm9qZWN0LnNvdXJjZXMpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5pbmdlc3RTb3VyY2Uoc291cmNlLCBwcm9qZWN0SWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gMi4gUnVuIEFuYWx5c2lzXHJcbiAgICAgICAgYXdhaXQgdGhpcy5hbmFseXplUHJvamVjdChwcm9qZWN0SWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgaW5nZXN0U291cmNlKHNvdXJjZTogYW55LCBwcm9qZWN0SWQ6IHN0cmluZykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHByaXNtYS5kYXRhU291cmNlLnVwZGF0ZSh7XHJcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogc291cmNlLmlkIH0sXHJcbiAgICAgICAgICAgICAgICBkYXRhOiB7IHN0YXR1czogXCJTWU5DSU5HXCIgfSxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBBcnRpZmljaWFsIFwiSHVtYW4tRmVlbFwiIERlbGF5ICgxIHNlY29uZClcclxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgcmVxdWlyZSBBUEkga2V5cyBmb3IgcGxhdGZvcm1zIHRoYXQgdXNlIHRoZW0gKGVhY2ggYWRhcHRlciB2YWxpZGF0ZXMgaXRzIG93biBrZXkpXHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UucGxhdGZvcm0gPT09IFwiWFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByb2Nlc3MuZW52LlNFUlBBUElfQVBJX0tFWSB8fCBwcm9jZXNzLmVudi5TRVJQQVBJX0FQSV9LRVkgPT09IFwieW91cl9zZXJwYXBpX2tleV9oZXJlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW1Byb2plY3RTeW5jZXJdIFNFUlBBUElfQVBJX0tFWSBpcyBtaXNzaW5nIG9yIHBsYWNlaG9sZGVyIGZvciBYIHNvdXJjZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBwcmlzbWEuZGF0YVNvdXJjZS51cGRhdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogc291cmNlLmlkIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgc3RhdHVzOiBcIkVSUk9SXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNvdXJjZS5wbGF0Zm9ybSA9PT0gXCJJTlNUQUdSQU1cIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5BUElGWV9BUElfVE9LRU4pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW1Byb2plY3RTeW5jZXJdIEFQSUZZX0FQSV9UT0tFTiBpcyBtaXNzaW5nIGZvciBJbnN0YWdyYW0gc291cmNlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHByaXNtYS5kYXRhU291cmNlLnVwZGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBzb3VyY2UuaWQgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogeyBzdGF0dXM6IFwiRVJST1JcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHN5bmMgd2luZG93IChTbWFydCBTeW5jKVxyXG4gICAgICAgICAgICAvLyBTdHJhdGVneTpcclxuICAgICAgICAgICAgLy8gMS4gTmV3IFByb2plY3QgKGxhc3RTeW5jIGlzIG51bGwpIC0+IEZldGNoIGxhc3QgMzAgZGF5cyAoSW5pdGlhbCBEZWVwIFB1bGwpXHJcbiAgICAgICAgICAgIC8vIDIuIEV4aXN0aW5nIFByb2plY3QgLT4gRmV0Y2ggc3RyaWN0bHkgZnJvbSAxIHNlY29uZCBBRlRFUiB0aGUgbGFzdCBzeW5jXHJcbiAgICAgICAgICAgIGxldCBzaW5jZTogRGF0ZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UubGFzdFN5bmMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RTeW5jVGltZSA9IG5ldyBEYXRlKHNvdXJjZS5sYXN0U3luYykuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gT25lIHNlY29uZCBhZnRlciB0aGUgbGFzdCBzeW5jIHRvIGF2b2lkIGR1cGxpY2F0ZXNcclxuICAgICAgICAgICAgICAgIHNpbmNlID0gbmV3IERhdGUobGFzdFN5bmNUaW1lICsgMTAwMCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyAzMCBEYXlzIGFnb1xyXG4gICAgICAgICAgICAgICAgc2luY2UgPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFtQcm9qZWN0U3luY2VyXSBTbWFydCBTeW5jIGZvciAke3NvdXJjZS5wbGF0Zm9ybX0gKFNvdXJjZSBJRDogJHtzb3VyY2UuaWR9KWApO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW1Byb2plY3RTeW5jZXJdIEZldGNoaW5nIGl0ZW1zIHN0cmljdGx5IE5FV0VSIHRoYW46ICR7c2luY2UudG9JU09TdHJpbmcoKX1gKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHNvdXJjZS5jb25maWcgYXMgYW55O1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW1Byb2plY3RTeW5jZXJdIENvbmZpZyBmb3IgJHtzb3VyY2UucGxhdGZvcm19OmAsIEpTT04uc3RyaW5naWZ5KGNvbmZpZywgbnVsbCwgMikpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UucGxhdGZvcm0gPT09IFwiR09PR0xFX1BMQVlcIikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgbmV3IEdvb2dsZVBsYXlBZGFwdGVyKCkuZmV0Y2hSZXZpZXdzKGNvbmZpZy5wYWNrYWdlTmFtZSwgc2luY2UpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5wbGF0Zm9ybSA9PT0gXCJBUFBfU1RPUkVcIikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgbmV3IEFwcFN0b3JlQWRhcHRlcigpLmZldGNoUmV2aWV3cyhjb25maWcuYXBwSWQsIHNpbmNlKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UucGxhdGZvcm0gPT09IFwiSU5TVEFHUkFNXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbUHJvamVjdFN5bmNlcl0gQ2FsbGluZyBJbnN0YWdyYW0gYWRhcHRlciB3aXRoIHBvc3RVcmxzOmAsIGNvbmZpZy5wb3N0VXJscyk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBuZXcgSW5zdGFncmFtQWRhcHRlcigpLmZldGNoQ29tbWVudHMoY29uZmlnLnBvc3RVcmxzLCBzaW5jZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnBsYXRmb3JtID09PSBcIlhcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtQcm9qZWN0U3luY2VyXSBDYWxsaW5nIFggYWRhcHRlciB3aXRoIHF1ZXJ5OmAsIGNvbmZpZy5xdWVyeSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBuZXcgWEFkYXB0ZXIoKS5mZXRjaE1lbnRpb25zKGNvbmZpZy5xdWVyeSwgc2luY2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW1Byb2plY3RTeW5jZXJdIEFkYXB0ZXIgcmV0dXJuZWQ6YCwgcmVzdWx0ID8gYCR7cmVzdWx0Lml0ZW1zPy5sZW5ndGggfHwgMH0gaXRlbXMsICR7cmVzdWx0LmVycm9ycz8ubGVuZ3RoIHx8IDB9IGVycm9yc2AgOiAnbnVsbC91bmRlZmluZWQnKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0Lml0ZW1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbUHJvamVjdFN5bmNlcl0gU2F2aW5nICR7cmVzdWx0Lml0ZW1zLmxlbmd0aH0gaXRlbXMgZm9yIHNvdXJjZSAke3NvdXJjZS5pZH1gKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcmVzdWx0Lml0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgcmVxdWlyZWQgZmllbGRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS5leHRlcm5hbElkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFtQcm9qZWN0U3luY2VyXSBTa2lwcGluZyBpdGVtIHdpdGhvdXQgZXh0ZXJuYWxJZDpgLCBpdGVtLnRleHQ/LnN1YnN0cmluZygwLCA1MCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS50ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFtQcm9qZWN0U3luY2VyXSBTa2lwcGluZyBpdGVtIHdpdGhvdXQgdGV4dDpgLCBpdGVtLmV4dGVybmFsSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbUHJvamVjdFN5bmNlcl0gVXBzZXJ0aW5nIGl0ZW06ICR7aXRlbS5leHRlcm5hbElkPy5zdWJzdHJpbmcoMCwgNTApfS4uLmApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcHJpc21hLnJldmlld0l0ZW0udXBzZXJ0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhdGZvcm1fZXh0ZXJuYWxJZF9wcm9qZWN0SWQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhdGZvcm06IHNvdXJjZS5wbGF0Zm9ybSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWxJZDogaXRlbS5leHRlcm5hbElkISxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvamVjdElkOiBwcm9qZWN0SWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5pdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3RJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGF0Zm9ybTogc291cmNlLnBsYXRmb3JtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGl0ZW0udGV4dCEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGFzIGFueSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLml0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogaXRlbS50ZXh0ISxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gYXMgYW55LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbUHJvamVjdFN5bmNlcl0g4pyFIFNhdmVkIGl0ZW06ICR7aXRlbS5leHRlcm5hbElkPy5zdWJzdHJpbmcoMCwgNTApfS4uLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGl0ZW1FcnJvcjogYW55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtQcm9qZWN0U3luY2VyXSDinYwgRmFpbGVkIHRvIHNhdmUgaXRlbTpgLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlcm5hbElkOiBpdGVtLmV4dGVybmFsSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogaXRlbUVycm9yLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogaXRlbUVycm9yLnN0YWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1Byb2plY3RTeW5jZXJdIEZpbmlzaGVkIHByb2Nlc3NpbmcgJHtyZXN1bHQuaXRlbXMubGVuZ3RofSBpdGVtc2ApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtQcm9qZWN0U3luY2VyXSBObyBpdGVtcyByZXR1cm5lZCBmcm9tIGFkYXB0ZXIgZm9yIHNvdXJjZSAke3NvdXJjZS5pZH1gKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYXdhaXQgcHJpc21hLmRhdGFTb3VyY2UudXBkYXRlKHtcclxuICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBzb3VyY2UuaWQgfSxcclxuICAgICAgICAgICAgICAgIGRhdGE6IHsgc3RhdHVzOiBcIklETEVcIiwgbGFzdFN5bmM6IG5ldyBEYXRlKCkgfSxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtQcm9qZWN0U3luY2VyXSBFcnJvciBzeW5jaW5nIHNvdXJjZSAke3NvdXJjZS5pZH06YCwgZXJyb3IpO1xyXG4gICAgICAgICAgICBhd2FpdCBwcmlzbWEuZGF0YVNvdXJjZS51cGRhdGUoe1xyXG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IHNvdXJjZS5pZCB9LFxyXG4gICAgICAgICAgICAgICAgZGF0YTogeyBzdGF0dXM6IFwiRVJST1JcIiB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBhbmFseXplUHJvamVjdChwcm9qZWN0SWQ6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBbUHJvamVjdFN5bmNlcl0gU3RhcnRpbmcgYW5hbHlzaXMgZm9yIHByb2plY3QgJHtwcm9qZWN0SWR9YCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHBvb3JJdGVtcyA9IGF3YWl0IHByaXNtYS5yZXZpZXdJdGVtLmZpbmRNYW55KHtcclxuICAgICAgICAgICAgd2hlcmU6IHtcclxuICAgICAgICAgICAgICAgIHByb2plY3RJZCxcclxuICAgICAgICAgICAgICAgIE9SOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgeyByYXRpbmc6IHsgbHRlOiAzIH0gfSxcclxuICAgICAgICAgICAgICAgICAgICB7IHNlbnRpbWVudDogXCJORUdcIiB9LFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdGFrZTogMTAwLFxyXG4gICAgICAgICAgICBvcmRlckJ5OiB7IGNyZWF0ZWRBdDogXCJkZXNjXCIgfSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgZ29vZEl0ZW1zID0gYXdhaXQgcHJpc21hLnJldmlld0l0ZW0uZmluZE1hbnkoe1xyXG4gICAgICAgICAgICB3aGVyZToge1xyXG4gICAgICAgICAgICAgICAgcHJvamVjdElkLFxyXG4gICAgICAgICAgICAgICAgT1I6IFtcclxuICAgICAgICAgICAgICAgICAgICB7IHJhdGluZzogeyBndGU6IDQgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsgc2VudGltZW50OiBcIlBPU1wiIH0sXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0YWtlOiAxMDAsXHJcbiAgICAgICAgICAgIG9yZGVyQnk6IHsgY3JlYXRlZEF0OiBcImRlc2NcIiB9LFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAocG9vckl0ZW1zLmxlbmd0aCA9PT0gMCAmJiBnb29kSXRlbXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1Byb2plY3RTeW5jZXJdIE5vIGl0ZW1zIHRvIGFuYWx5emVcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHByb21wdCA9IGBBbmFseXplIGN1c3RvbWVyIGZlZWRiYWNrIGZvciBhIHByb2plY3QuXHJcbiAgICAgICAgXHJcbiAgICAgICAgQ1JJVElDQUwgRkVFREJBQ0sgKENvbXBsYWludHMpOlxyXG4gICAgICAgICR7cG9vckl0ZW1zLm1hcChpID0+IGAtICR7aS50ZXh0fWApLmpvaW4oXCJcXG5cIil9XHJcbiAgICAgICAgXHJcbiAgICAgICAgUE9TSVRJVkUgRkVFREJBQ0sgKEhpZ2hsaWdodHMpOlxyXG4gICAgICAgICR7Z29vZEl0ZW1zLm1hcChpID0+IGAtICR7aS50ZXh0fWApLmpvaW4oXCJcXG5cIil9XHJcbiAgICAgICAgXHJcbiAgICAgICAgUHJvdmlkZTpcclxuICAgICAgICAxLiBBIGdlbmVyYWwgc2VudGltZW50IHNjb3JlICgxLTEwMCkuXHJcbiAgICAgICAgMi4gXCJjcml0aWNpc21zXCI6IHsgc3VtbWFyeTogXCIxLXNlbnRlbmNlXCIsIGJ1bGxldHM6IFt7dGl0bGUsIGRldGFpbHMsIGNvdW50LCBleGFtcGxlczogW3N0cmluZ119XSwgc3VnZ2VzdGlvbnM6IFtcIlNob3J0LCBhY3Rpb25hYmxlIHRpdGxlIGxpa2UgJ0ZpeCBBdXRoIEZsb3cnXCIsIFwiU3VnZ2VzdGlvbnMgc2hvdWxkIGJlIHNwZWNpZmljXCJdIH1cclxuICAgICAgICAzLiBcInByYWlzZXNcIjogeyBzdW1tYXJ5OiBcIjEtc2VudGVuY2VcIiwgYnVsbGV0czogW3t0aXRsZSwgZGV0YWlscywgY291bnQsIGV4YW1wbGVzOiBbc3RyaW5nXX1dIH1cclxuICAgICAgICBcclxuICAgICAgICBSZXR1cm4gT05MWSBhIEpTT04gb2JqZWN0IHdpdGggdGhpcyBzdHJ1Y3R1cmU6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCJzY29yZVwiOiA4NSxcclxuICAgICAgICAgIFwiY3JpdGljaXNtc1wiOiB7IFwic3VtbWFyeVwiOiBcIi4uLlwiLCBcImJ1bGxldHNcIjogWy4uLl0sIFwic3VnZ2VzdGlvbnNcIjogW1wiLi4uXCIsIFwiLi4uXCIsIFwiLi4uXCJdIH0sXHJcbiAgICAgICAgICBcInByYWlzZXNcIjogeyBcInN1bW1hcnlcIjogXCIuLi5cIiwgXCJidWxsZXRzXCI6IFsuLi5dIH1cclxuICAgICAgICB9YDtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0UmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1vZGVsLmdlbmVyYXRlQ29udGVudChwcm9tcHQpO1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZVRleHQgPSByZXN1bHRSZXNwb25zZS5yZXNwb25zZS50ZXh0KCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjbGVhbmVkID0gcmVzcG9uc2VUZXh0LnJlcGxhY2UoL2BgYGpzb24vZywgXCJcIikucmVwbGFjZSgvYGBgL2csIFwiXCIpLnRyaW0oKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShjbGVhbmVkKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IHByaXNtYS5wcm9qZWN0QW5hbHlzaXMuY3JlYXRlKHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0SWQsXHJcbiAgICAgICAgICAgICAgICAgICAgcGVyaW9kU3RhcnQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSA3ICogMjQgKiA2MCAqIDYwICogMTAwMCksXHJcbiAgICAgICAgICAgICAgICAgICAgcGVyaW9kRW5kOiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGpzb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucmVzdWx0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb29yQ291bnQ6IHBvb3JJdGVtcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvb2RDb3VudDogZ29vZEl0ZW1zLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxDb3VudDogYXdhaXQgcHJpc21hLnJldmlld0l0ZW0uY291bnQoeyB3aGVyZTogeyBwcm9qZWN0SWQgfSB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhdGZvcm1zQnJlYWtkb3duOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlbmQ6IHsgbGFiZWw6IFwiTGFzdCAzMCBkYXlzXCIsIHZhbHVlOiAwLCBkaXJlY3Rpb246IFwic3RlYWR5XCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJnZW50SXNzdWVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltQcm9qZWN0U3luY2VyXSBBbmFseXNpcyBjb21wbGV0ZWQgYW5kIHNhdmVkXCIpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltQcm9qZWN0U3luY2VyXSBBbmFseXNpcyBmYWlsZWQ6XCIsIGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOlsicHJpc21hIiwiR29vZ2xlR2VuZXJhdGl2ZUFJIiwiR29vZ2xlUGxheUFkYXB0ZXIiLCJBcHBTdG9yZUFkYXB0ZXIiLCJJbnN0YWdyYW1BZGFwdGVyIiwiWEFkYXB0ZXIiLCJQcm9qZWN0U3luY2VyIiwiY29uc3RydWN0b3IiLCJnZW5BSSIsInByb2Nlc3MiLCJlbnYiLCJHT09HTEVfR0VORVJBVElWRV9BSV9BUElfS0VZIiwibW9kZWwiLCJHRU1JTklfTU9ERUwiLCJnZXRHZW5lcmF0aXZlTW9kZWwiLCJzeW5jIiwicHJvamVjdElkIiwic3luY2VyIiwicnVuIiwiY29uc29sZSIsImxvZyIsInByb2plY3QiLCJmaW5kVW5pcXVlIiwid2hlcmUiLCJpZCIsImluY2x1ZGUiLCJzb3VyY2VzIiwiRXJyb3IiLCJzb3VyY2UiLCJpbmdlc3RTb3VyY2UiLCJhbmFseXplUHJvamVjdCIsImRhdGFTb3VyY2UiLCJ1cGRhdGUiLCJkYXRhIiwic3RhdHVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwicGxhdGZvcm0iLCJTRVJQQVBJX0FQSV9LRVkiLCJlcnJvciIsIkFQSUZZX0FQSV9UT0tFTiIsInNpbmNlIiwibGFzdFN5bmMiLCJsYXN0U3luY1RpbWUiLCJEYXRlIiwiZ2V0VGltZSIsIm5vdyIsInRvSVNPU3RyaW5nIiwiY29uZmlnIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlc3VsdCIsImZldGNoUmV2aWV3cyIsInBhY2thZ2VOYW1lIiwiYXBwSWQiLCJwb3N0VXJscyIsImZldGNoQ29tbWVudHMiLCJxdWVyeSIsImZldGNoTWVudGlvbnMiLCJpdGVtcyIsImxlbmd0aCIsImVycm9ycyIsIml0ZW0iLCJleHRlcm5hbElkIiwid2FybiIsInRleHQiLCJzdWJzdHJpbmciLCJyZXZpZXdJdGVtIiwidXBzZXJ0IiwicGxhdGZvcm1fZXh0ZXJuYWxJZF9wcm9qZWN0SWQiLCJjcmVhdGUiLCJpdGVtRXJyb3IiLCJtZXNzYWdlIiwic3RhY2siLCJwb29ySXRlbXMiLCJmaW5kTWFueSIsIk9SIiwicmF0aW5nIiwibHRlIiwic2VudGltZW50IiwidGFrZSIsIm9yZGVyQnkiLCJjcmVhdGVkQXQiLCJnb29kSXRlbXMiLCJndGUiLCJwcm9tcHQiLCJtYXAiLCJpIiwiam9pbiIsInJlc3VsdFJlc3BvbnNlIiwiZ2VuZXJhdGVDb250ZW50IiwicmVzcG9uc2VUZXh0IiwicmVzcG9uc2UiLCJjbGVhbmVkIiwicmVwbGFjZSIsInRyaW0iLCJwYXJzZSIsInByb2plY3RBbmFseXNpcyIsInBlcmlvZFN0YXJ0IiwicGVyaW9kRW5kIiwianNvbiIsInBvb3JDb3VudCIsImdvb2RDb3VudCIsInRvdGFsQ291bnQiLCJjb3VudCIsInBsYXRmb3Jtc0JyZWFrZG93biIsInRyZW5kIiwibGFiZWwiLCJ2YWx1ZSIsImRpcmVjdGlvbiIsInVyZ2VudElzc3VlcyIsImUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/sync/project-syncer.ts\n");

/***/ }),

/***/ "(rsc)/./lib/sync/utils/date-parser.ts":
/*!***************************************!*\
  !*** ./lib/sync/utils/date-parser.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseRelativeDate: () => (/* binding */ parseRelativeDate)\n/* harmony export */ });\nfunction parseRelativeDate(dateStr) {\n    if (!dateStr) return new Date();\n    const now = new Date();\n    const cleanStr = dateStr.toLowerCase().trim();\n    if (cleanStr.includes(\"ago\")) {\n        const num = parseInt(cleanStr.match(/\\d+/)?.[0] || \"0\");\n        if (cleanStr.includes(\"second\") || cleanStr.includes(\"sec\")) {\n            return new Date(now.getTime() - num * 1000);\n        } else if (cleanStr.includes(\"minute\") || cleanStr.includes(\"min\")) {\n            return new Date(now.getTime() - num * 60 * 1000);\n        } else if (cleanStr.includes(\"hour\")) {\n            return new Date(now.getTime() - num * 60 * 60 * 1000);\n        } else if (cleanStr.includes(\"day\")) {\n            return new Date(now.getTime() - num * 24 * 60 * 60 * 1000);\n        } else if (cleanStr.includes(\"week\")) {\n            return new Date(now.getTime() - num * 7 * 24 * 60 * 60 * 1000);\n        } else if (cleanStr.includes(\"month\")) {\n            return new Date(now.getTime() - num * 30 * 24 * 60 * 60 * 1000);\n        } else if (cleanStr.includes(\"year\")) {\n            return new Date(now.getTime() - num * 365 * 24 * 60 * 60 * 1000);\n        }\n    }\n    // Try standard parsing\n    const parsed = Date.parse(dateStr);\n    if (!isNaN(parsed)) {\n        return new Date(parsed);\n    }\n    // If snippet had a date like \"Feb 5, 2024\" at start\n    // Already handled by regex in adapter, but let's be safe\n    return new Date();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvc3luYy91dGlscy9kYXRlLXBhcnNlci50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQ08sU0FBU0Esa0JBQWtCQyxPQUFlO0lBQzdDLElBQUksQ0FBQ0EsU0FBUyxPQUFPLElBQUlDO0lBRXpCLE1BQU1DLE1BQU0sSUFBSUQ7SUFDaEIsTUFBTUUsV0FBV0gsUUFBUUksV0FBVyxHQUFHQyxJQUFJO0lBRTNDLElBQUlGLFNBQVNHLFFBQVEsQ0FBQyxRQUFRO1FBQzFCLE1BQU1DLE1BQU1DLFNBQVNMLFNBQVNNLEtBQUssQ0FBQyxRQUFRLENBQUMsRUFBRSxJQUFJO1FBQ25ELElBQUlOLFNBQVNHLFFBQVEsQ0FBQyxhQUFhSCxTQUFTRyxRQUFRLENBQUMsUUFBUTtZQUN6RCxPQUFPLElBQUlMLEtBQUtDLElBQUlRLE9BQU8sS0FBS0gsTUFBTTtRQUMxQyxPQUFPLElBQUlKLFNBQVNHLFFBQVEsQ0FBQyxhQUFhSCxTQUFTRyxRQUFRLENBQUMsUUFBUTtZQUNoRSxPQUFPLElBQUlMLEtBQUtDLElBQUlRLE9BQU8sS0FBS0gsTUFBTSxLQUFLO1FBQy9DLE9BQU8sSUFBSUosU0FBU0csUUFBUSxDQUFDLFNBQVM7WUFDbEMsT0FBTyxJQUFJTCxLQUFLQyxJQUFJUSxPQUFPLEtBQUtILE1BQU0sS0FBSyxLQUFLO1FBQ3BELE9BQU8sSUFBSUosU0FBU0csUUFBUSxDQUFDLFFBQVE7WUFDakMsT0FBTyxJQUFJTCxLQUFLQyxJQUFJUSxPQUFPLEtBQUtILE1BQU0sS0FBSyxLQUFLLEtBQUs7UUFDekQsT0FBTyxJQUFJSixTQUFTRyxRQUFRLENBQUMsU0FBUztZQUNsQyxPQUFPLElBQUlMLEtBQUtDLElBQUlRLE9BQU8sS0FBS0gsTUFBTSxJQUFJLEtBQUssS0FBSyxLQUFLO1FBQzdELE9BQU8sSUFBSUosU0FBU0csUUFBUSxDQUFDLFVBQVU7WUFDbkMsT0FBTyxJQUFJTCxLQUFLQyxJQUFJUSxPQUFPLEtBQUtILE1BQU0sS0FBSyxLQUFLLEtBQUssS0FBSztRQUM5RCxPQUFPLElBQUlKLFNBQVNHLFFBQVEsQ0FBQyxTQUFTO1lBQ2xDLE9BQU8sSUFBSUwsS0FBS0MsSUFBSVEsT0FBTyxLQUFLSCxNQUFNLE1BQU0sS0FBSyxLQUFLLEtBQUs7UUFDL0Q7SUFDSjtJQUVBLHVCQUF1QjtJQUN2QixNQUFNSSxTQUFTVixLQUFLVyxLQUFLLENBQUNaO0lBQzFCLElBQUksQ0FBQ2EsTUFBTUYsU0FBUztRQUNoQixPQUFPLElBQUlWLEtBQUtVO0lBQ3BCO0lBRUEsb0RBQW9EO0lBQ3BELHlEQUF5RDtJQUN6RCxPQUFPLElBQUlWO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9saWIvc3luYy91dGlscy9kYXRlLXBhcnNlci50cz83ZDk0Il0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZWxhdGl2ZURhdGUoZGF0ZVN0cjogc3RyaW5nKTogRGF0ZSB7XHJcbiAgICBpZiAoIWRhdGVTdHIpIHJldHVybiBuZXcgRGF0ZSgpO1xyXG5cclxuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgICBjb25zdCBjbGVhblN0ciA9IGRhdGVTdHIudG9Mb3dlckNhc2UoKS50cmltKCk7XHJcblxyXG4gICAgaWYgKGNsZWFuU3RyLmluY2x1ZGVzKFwiYWdvXCIpKSB7XHJcbiAgICAgICAgY29uc3QgbnVtID0gcGFyc2VJbnQoY2xlYW5TdHIubWF0Y2goL1xcZCsvKT8uWzBdIHx8IFwiMFwiKTtcclxuICAgICAgICBpZiAoY2xlYW5TdHIuaW5jbHVkZXMoXCJzZWNvbmRcIikgfHwgY2xlYW5TdHIuaW5jbHVkZXMoXCJzZWNcIikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgLSBudW0gKiAxMDAwKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNsZWFuU3RyLmluY2x1ZGVzKFwibWludXRlXCIpIHx8IGNsZWFuU3RyLmluY2x1ZGVzKFwibWluXCIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShub3cuZ2V0VGltZSgpIC0gbnVtICogNjAgKiAxMDAwKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNsZWFuU3RyLmluY2x1ZGVzKFwiaG91clwiKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobm93LmdldFRpbWUoKSAtIG51bSAqIDYwICogNjAgKiAxMDAwKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNsZWFuU3RyLmluY2x1ZGVzKFwiZGF5XCIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShub3cuZ2V0VGltZSgpIC0gbnVtICogMjQgKiA2MCAqIDYwICogMTAwMCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjbGVhblN0ci5pbmNsdWRlcyhcIndlZWtcIikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgLSBudW0gKiA3ICogMjQgKiA2MCAqIDYwICogMTAwMCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjbGVhblN0ci5pbmNsdWRlcyhcIm1vbnRoXCIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShub3cuZ2V0VGltZSgpIC0gbnVtICogMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNsZWFuU3RyLmluY2x1ZGVzKFwieWVhclwiKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobm93LmdldFRpbWUoKSAtIG51bSAqIDM2NSAqIDI0ICogNjAgKiA2MCAqIDEwMDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBUcnkgc3RhbmRhcmQgcGFyc2luZ1xyXG4gICAgY29uc3QgcGFyc2VkID0gRGF0ZS5wYXJzZShkYXRlU3RyKTtcclxuICAgIGlmICghaXNOYU4ocGFyc2VkKSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShwYXJzZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHNuaXBwZXQgaGFkIGEgZGF0ZSBsaWtlIFwiRmViIDUsIDIwMjRcIiBhdCBzdGFydFxyXG4gICAgLy8gQWxyZWFkeSBoYW5kbGVkIGJ5IHJlZ2V4IGluIGFkYXB0ZXIsIGJ1dCBsZXQncyBiZSBzYWZlXHJcbiAgICByZXR1cm4gbmV3IERhdGUoKTtcclxufVxyXG4iXSwibmFtZXMiOlsicGFyc2VSZWxhdGl2ZURhdGUiLCJkYXRlU3RyIiwiRGF0ZSIsIm5vdyIsImNsZWFuU3RyIiwidG9Mb3dlckNhc2UiLCJ0cmltIiwiaW5jbHVkZXMiLCJudW0iLCJwYXJzZUludCIsIm1hdGNoIiwiZ2V0VGltZSIsInBhcnNlZCIsInBhcnNlIiwiaXNOYU4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/sync/utils/date-parser.ts\n");

/***/ })

};
;